SCRIPT  /Users/klangton/.yadr/vim/bundle/vim-rails/compiler/rails.vim
Sourced 10 times
Total time:   0.012996
 Self time:   0.011589

count  total (s)   self (s)
                            " Vim compiler file
                            
   10              0.000057 if exists("current_compiler")
                              finish
                            endif
                            
   10              0.000214 CompilerSet errorformat=%D(in\ %f),
                                  \%\\s%#from\ %f:%l:%m,
                                  \%\\s%#from\ %f:%l:,
                                  \%\\s%##\ %f:%l:%m,
                                  \%\\s%##\ %f:%l,
                                  \%\\s%#[%f:%l:\ %#%m,
                                  \%\\s%#%f:%l:\ %#%m,
                                  \%\\s%#%f:%l:,
                                  \%m\ [%f:%l]:,
                                  \%+Erake\ aborted!,
                                  \%+EDon't\ know\ how\ to\ build\ task\ %.%#,
                                  \%+Einvalid\ option:%.%#,
                                  \%+Irake\ %\\S%\\+%\\s%\\+#\ %.%#
                            
   10              0.002403 runtime! compiler/rake.vim
                            
   10              0.000038 let current_compiler = "rails"
                            
   10              0.000078 CompilerSet makeprg=rails
                            " CompilerSet makeprg=ruby\ bin/rails
                            " CompilerSet makeprg=ruby\ script/rails
                            
   10              0.000231 CompilerSet errorformat^=
                                  \%\\S%\\+\ \ %#%[cefi]%[rxod]%[eir]%[a-z]%#%\\x1b[0m\ %\\+%\\S%\\+%$
                                  \%\\&%\\x1b%\\S%\\+\ \ %#%m%\\>%\\x1b[0m\ \ %#%f,
                                  \%\\s\ %#%[cefi]%[rxod]%[eir]%[a-z]%#\ %\\+%\\S%\\+%$
                                  \%\\&%\\s\ %#%m%\\>\ \ %#%f,
                                  \Overwrite%.%#%\\S%\\+\ \ %#%m%\\x1b[0m\ \ %#%f,
                                  \%-GOverwrite%.%#\"h\"%.%#,
                                  \%+GCurrent\ version:%.%#,
                                  \%+G\ %#Status\ %#Migration\ ID%.%#,
                                  \%+G\ %#Prefix\ %#Verb%.%#,
                                  \%+G\ %#Code\ LOC:\ %.%#,
                                  \%+GAbout\ your\ application's\ environment,
                                  \%+Grun\ %\\S%#::Application.routes,
                                  \%+Eruby:%.%#(LoadError),
                                  \%+EUsage:%.%#,
                                  \%+ECould\ not\ find\ generator%.%#,
                                  \%+EType\ 'rails'\ for\ help.
                            
                            " -complete=customlist,rails#complete_rails

SCRIPT  /Users/klangton/.yadr/vim/bundle/vim-ruby/compiler/rake.vim
Sourced 10 times
Total time:   0.000743
 Self time:   0.000743

count  total (s)   self (s)
                            " Vim compiler file
                            " Language:		Rake
                            " Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            
   10              0.000049 if exists("current_compiler")
                              finish
                            endif
   10              0.000029 let current_compiler = "rake"
                            
   10              0.000046 if exists(":CompilerSet") != 2		" older Vim always used :setlocal
                              command -nargs=* CompilerSet setlocal <args>
                            endif
                            
   10              0.000067 let s:cpo_save = &cpo
   10              0.000061 set cpo-=C
                            
   10              0.000058 CompilerSet makeprg=rake
                            
   10              0.000189 CompilerSet errorformat=
                                  \%D(in\ %f),
                                  \%\\s%#from\ %f:%l:%m,
                                  \%\\s%#from\ %f:%l:,
                                  \%\\s%##\ %f:%l:%m,
                                  \%\\s%##\ %f:%l,
                                  \%\\s%#[%f:%l:\ %#%m,
                                  \%\\s%#%f:%l:\ %#%m,
                                  \%\\s%#%f:%l:,
                                  \%m\ [%f:%l]:,
                                  \%+Erake\ aborted!,
                                  \%+EDon't\ know\ how\ to\ build\ task\ %.%#,
                                  \%+Einvalid\ option:%.%#,
                                  \%+Irake\ %\\S%\\+%\\s%\\+#\ %.%#
                            
   10              0.000060 let &cpo = s:cpo_save
   10              0.000020 unlet s:cpo_save
                            
                            " vim: nowrap sw=2 sts=2 ts=8:

SCRIPT  /usr/local/Cellar/macvim/7.4-73/MacVim.app/Contents/Resources/vim/runtime/compiler/rake.vim
Sourced 10 times
Total time:   0.000159
 Self time:   0.000159

count  total (s)   self (s)
                            " Vim compiler file
                            " Language:		Rake
                            " Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            
   10              0.000091 if exists("current_compiler")
   10              0.000014   finish

SCRIPT  /usr/local/Cellar/macvim/7.4-73/MacVim.app/Contents/Resources/vim/runtime/scripts.vim
Sourced 2 times
Total time:   0.001526
 Self time:   0.001526

count  total (s)   self (s)
                            " Vim support file to detect file types in scripts
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2013 May 24
                            
                            " This file is called by an autocommand for every file that has just been
                            " loaded into a buffer.  It checks if the type of file can be recognized by
                            " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
                            
                            
                            " Only do the rest when the FileType autocommand has not been triggered yet.
    2              0.000008 if did_filetype()
                              finish
                            endif
                            
                            " Load the user defined scripts file first
                            " Only do this when the FileType autocommand has not been triggered yet
    2              0.000010 if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
                              execute "source " . myscriptsfile
                              if did_filetype()
                                finish
                              endif
                            endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    2              0.000022 let s:cpo_save = &cpo
    2              0.000017 set cpo&vim
                            
    2              0.000008 let s:line1 = getline(1)
                            
    2              0.000012 if s:line1 =~ "^#!"
                              " A script that starts with "#!".
                            
                              " Check for a line like "#!/usr/bin/env VAR=val bash".  Turn it into
                              " "#!/usr/bin/bash" to make matching easier.
                              if s:line1 =~ '^#!\s*\S*\<env\s'
                                let s:line1 = substitute(s:line1, '\S\+=\S\+', '', 'g')
                                let s:line1 = substitute(s:line1, '\<env\s\+', '', '')
                              endif
                            
                              " Get the program name.
                              " Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                              " If the word env is used, use the first word after the space:
                              " "#!/usr/bin/env perl [path/args]"
                              " If there is no path use the first word: "#!perl [path/args]".
                              " Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                              if s:line1 =~ '^#!\s*\a:[/\\]'
                                let s:name = substitute(s:line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                              elseif s:line1 =~ '^#!.*\<env\>'
                                let s:name = substitute(s:line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                              elseif s:line1 =~ '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                let s:name = substitute(s:line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                              else
                                let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
                              endif
                            
                              " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                              " third line.  Suggested by Steven Atkinson.
                              if getline(3) =~ '^exec wish'
                                let s:name = 'wish'
                              endif
                            
                              " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
                              if s:name =~ '^\(bash\d*\|\|ksh\d*\|sh\)\>'
                                call SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " csh scripts
                              elseif s:name =~ '^csh\>'
                                if exists("g:filetype_csh")
                                  call SetFileTypeShell(g:filetype_csh)
                                else
                                  call SetFileTypeShell("csh")
                                endif
                            
                                " tcsh scripts
                              elseif s:name =~ '^tcsh\>'
                                call SetFileTypeShell("tcsh")
                            
                                " Z shell scripts
                              elseif s:name =~ '^zsh\>'
                                set ft=zsh
                            
                                " TCL scripts
                              elseif s:name =~ '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                set ft=tcl
                            
                                " Expect scripts
                              elseif s:name =~ '^expect\>'
                                set ft=expect
                            
                                " Gnuplot scripts
                              elseif s:name =~ '^gnuplot\>'
                                set ft=gnuplot
                            
                                " Makefiles
                              elseif s:name =~ 'make\>'
                                set ft=make
                            
                                " Lua
                              elseif s:name =~ 'lua'
                                set ft=lua
                            
                                " Perl 6
                              elseif s:name =~ 'perl6'
                                set ft=perl6
                            
                                " Perl
                              elseif s:name =~ 'perl'
                                set ft=perl
                            
                                " PHP
                              elseif s:name =~ 'php'
                                set ft=php
                            
                                " Python
                              elseif s:name =~ 'python'
                                set ft=python
                            
                                " Groovy
                              elseif s:name =~ '^groovy\>'
                                set ft=groovy
                            
                                " Ruby
                              elseif s:name =~ 'ruby'
                                set ft=ruby
                            
                                " BC calculator
                              elseif s:name =~ '^bc\>'
                                set ft=bc
                            
                                " sed
                              elseif s:name =~ 'sed\>'
                                set ft=sed
                            
                                " OCaml-scripts
                              elseif s:name =~ 'ocaml'
                                set ft=ocaml
                            
                                " Awk scripts
                              elseif s:name =~ 'awk\>'
                                set ft=awk
                            
                                " Website MetaLanguage
                              elseif s:name =~ 'wml'
                                set ft=wml
                            
                                " Scheme scripts
                              elseif s:name =~ 'scheme'
                                set ft=scheme
                            
                                " CFEngine scripts
                              elseif s:name =~ 'cfengine'
                                set ft=cfengine
                            
                                " Erlang scripts
                              elseif s:name =~ 'escript'
                                set ft=erlang
                            
                              endif
                              unlet s:name
                            
                            else
                              " File does not start with "#!".
                            
    2              0.000008   let s:line2 = getline(2)
    2              0.000008   let s:line3 = getline(3)
    2              0.000006   let s:line4 = getline(4)
    2              0.000004   let s:line5 = getline(5)
                            
                              " Bourne-like shell scripts: sh ksh bash bash2
    2              0.000011   if s:line1 =~ '^:$'
                                call SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " Z shell scripts
                              elseif s:line1 =~ '^#compdef\>' || s:line1 =~ '^#autoload\>' ||
                                    \ "\n".s:line1."\n".s:line2."\n".s:line3."\n".s:line4."\n".s:line5 =~ '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                set ft=zsh
                            
                              " ELM Mail files
                              elseif s:line1 =~ '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                set ft=mail
                            
                                " Mason
                              elseif s:line1 =~ '^<[%&].*>'
                                set ft=mason
                            
                                " Vim scripts (must have '" vim' as the first line to trigger this)
                              elseif s:line1 =~ '^" *[vV]im$'
                                set ft=vim
                            
                                " MOO
                              elseif s:line1 =~ '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                set ft=moo
                            
                                " Diff file:
                                " - "diff" in first line (context diff)
                                " - "Only in " in first line
                                " - "--- " in first line and "+++ " in second line (unified diff).
                                " - "*** " in first line and "--- " in second line (context diff).
                                " - "# It was generated by makepatch " in the second line (makepatch diff).
                                " - "Index: <filename>" in the first line (CVS file)
                                " - "=== ", line of "=", "---", "+++ " (SVK diff)
                                " - "=== ", "--- ", "+++ " (bzr diff, common case)
                                " - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                                " - "# HG changeset patch" in first line (Mercurial export format)
                              elseif s:line1 =~ '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)'
                            	\ || (s:line1 =~ '^--- ' && s:line2 =~ '^+++ ')
                            	\ || (s:line1 =~ '^\* looking for ' && s:line2 =~ '^\* comparing to ')
                            	\ || (s:line1 =~ '^\*\*\* ' && s:line2 =~ '^--- ')
                            	\ || (s:line1 =~ '^=== ' && ((s:line2 =~ '^=\{66\}' && s:line3 =~ '^--- ' && s:line4 =~ '^+++') || (s:line2 =~ '^--- ' && s:line3 =~ '^+++ ')))
                            	\ || (s:line1 =~ '^=== \(removed\|added\|renamed\|modified\)')
                                set ft=diff
                            
                                " PostScript Files (must have %!PS as the first line, like a2ps output)
                              elseif s:line1 =~ '^%![ \t]*PS'
                                set ft=postscr
                            
                                " M4 scripts: Guess there is a line that starts with "dnl".
                              elseif s:line1 =~ '^\s*dnl\>'
                            	\ || s:line2 =~ '^\s*dnl\>'
                            	\ || s:line3 =~ '^\s*dnl\>'
                            	\ || s:line4 =~ '^\s*dnl\>'
                            	\ || s:line5 =~ '^\s*dnl\>'
                                set ft=m4
                            
                                " AmigaDos scripts
                              elseif $TERM == "amiga"
                            	\ && (s:line1 =~ "^;" || s:line1 =~ '^\.[bB][rR][aA]')
                                set ft=amiga
                            
                                " SiCAD scripts (must have procn or procd as the first line to trigger this)
                              elseif s:line1 =~? '^ *proc[nd] *$'
                                set ft=sicad
                            
                                " Purify log files start with "****  Purify"
                              elseif s:line1 =~ '^\*\*\*\*  Purify'
                                set ft=purifylog
                            
                                " XML
                              elseif s:line1 =~ '<?\s*xml.*?>'
                                set ft=xml
                            
                                " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
                              elseif s:line1 =~ '\<DTD\s\+XHTML\s'
                                set ft=xhtml
                            
                                " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                              elseif s:line1 =~? '\<DOCTYPE\s\+html\>'
                                set ft=html
                            
                                " PDF
                              elseif s:line1 =~ '^%PDF-'
                                set ft=pdf
                            
                                " XXD output
                              elseif s:line1 =~ '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                set ft=xxd
                            
                                " RCS/CVS log output
                              elseif s:line1 =~ '^RCS file:' || s:line2 =~ '^RCS file:'
                                set ft=rcslog
                            
                                " CVS commit
                              elseif s:line2 =~ '^CVS:' || getline("$") =~ '^CVS: '
                                set ft=cvs
                            
                                " Prescribe
                              elseif s:line1 =~ '^!R!'
                                set ft=prescribe
                            
                                " Send-pr
                              elseif s:line1 =~ '^SEND-PR:'
                                set ft=sendpr
                            
                                " SNNS files
                              elseif s:line1 =~ '^SNNS network definition file'
                                set ft=snnsnet
                              elseif s:line1 =~ '^SNNS pattern definition file'
                                set ft=snnspat
                              elseif s:line1 =~ '^SNNS result file'
                                set ft=snnsres
                            
                                " Virata
                              elseif s:line1 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line2 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line3 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line4 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line5 =~ '^%.\{-}[Vv]irata'
                                set ft=virata
                            
                                " Strace
                              elseif s:line1 =~ '^\(\[pid \d\+\] \)\=[0-9:.]* *execve(' || s:line1 =~ '^__libc_start_main'
                                set ft=strace
                            
                                " VSE JCL
                              elseif s:line1 =~ '^\* $$ JOB\>' || s:line1 =~ '^// *JOB\>'
                                set ft=vsejcl
                            
                                " TAK and SINDA
                              elseif s:line4 =~ 'K & K  Associates' || s:line2 =~ 'TAK 2000'
                                set ft=takout
                              elseif s:line3 =~ 'S Y S T E M S   I M P R O V E D '
                                set ft=sindaout
                              elseif getline(6) =~ 'Run Date: '
                                set ft=takcmp
                              elseif getline(9) =~ 'Node    File  1'
                                set ft=sindacmp
                            
                                " DNS zone files
                              elseif s:line1.s:line2.s:line3.s:line4 =~ '^; <<>> DiG [0-9.]\+ <<>>\|BIND.*named\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                set ft=bindzone
                            
                                " BAAN
                              elseif s:line1 =~ '|\*\{1,80}' && s:line2 =~ 'VRC '
                            	\ || s:line2 =~ '|\*\{1,80}' && s:line3 =~ 'VRC '
                                set ft=baan
                            
                              " Valgrind
                              elseif s:line1 =~ '^==\d\+== valgrind' || s:line3 =~ '^==\d\+== Using valgrind'
                                set ft=valgrind
                            
                              " Renderman Interface Bytestream
                              elseif s:line1 =~ '^##RenderMan'
                                set ft=rib
                            
                              " Scheme scripts
                              elseif s:line1 =~ 'exec\s\+\S*scheme' || s:line2 =~ 'exec\s\+\S*scheme'
                                set ft=scheme
                            
                              " Git output
                              elseif s:line1 =~ '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$'
                                set ft=git
                            
                               " Gprof (gnu profiler)
                               elseif s:line1 == 'Flat profile:'
                                 \ && s:line2 == ''
                                 \ && s:line3 =~ '^Each sample counts as .* seconds.$'
                                 set ft=gprof
                            
                              " Erlang terms
                              " (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
                              elseif s:line1 =~? '-\*-.*erlang.*-\*-'
                                set ft=erlang
                            
                              " CVS diff
                              else
    2              0.000004     let s:lnum = 1
    2              0.000013     while getline(s:lnum) =~ "^? " && s:lnum < line("$")
                                  let s:lnum += 1
                                endwhile
    2              0.000011     if getline(s:lnum) =~ '^Index:\s\+\f\+$'
                                  set ft=diff
                            
                                  " locale input files: Formal Definitions of Cultural Conventions
                                  " filename must be like en_US, fr_FR@euro or en_US.UTF-8
                                elseif expand("%") =~ '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                  let s:lnum = 1
                                  while s:lnum < 100 && s:lnum < line("$")
                            	if getline(s:lnum) =~ '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                            	  setf fdcc
                            	  break
                            	endif
                            	let s:lnum += 1
                                  endwhile
                                endif
    2              0.000007     unlet s:lnum
                            
    2              0.000002   endif
                            
    2              0.000004   unlet s:line2 s:line3 s:line4 s:line5
                            
    2              0.000002 endif
                            
                            " Restore 'cpoptions'
    2              0.000013 let &cpo = s:cpo_save
                            
    2              0.000008 unlet s:cpo_save s:line1

SCRIPT  /Users/klangton/.yadr/vim/bundle/vim-ruby/ftplugin/ruby.vim
Sourced 4 times
Total time:   0.005980
 Self time:   0.005808

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:		Ruby
                            " Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:  Doug Kearns <dougkearns@gmail.com>
                            " ----------------------------------------------------------------------------
                            
    4              0.000024 if (exists("b:did_ftplugin"))
                              finish
                            endif
    4              0.000013 let b:did_ftplugin = 1
                            
    4              0.000022 let s:cpo_save = &cpo
    4              0.000025 set cpo&vim
                            
    4              0.000021 if has("gui_running") && !has("gui_win32")
                              setlocal keywordprg=ri\ -T\ -f\ bs
                            else
    4              0.000009   setlocal keywordprg=ri
    4              0.000004 endif
                            
                            " Matchit support
    4              0.000018 if exists("loaded_matchit") && !exists("b:match_words")
    4              0.000009   let b:match_ignorecase = 0
                            
    4              0.000062   let b:match_words =
                            	\ '\<\%(if\|unless\|case\|while\|until\|for\|do\|class\|module\|def\|begin\)\>=\@!' .
                            	\ ':' .
                            	\ '\<\%(else\|elsif\|ensure\|when\|rescue\|break\|redo\|next\|retry\)\>' .
                            	\ ':' .
                                    \ '\%(^\|[^.\:@$]\)\@<=\<end\:\@!\>' .
                            	\ ',{:},\[:\],(:)'
                            
    4              0.000061   let b:match_skip =
                            	\ "synIDattr(synID(line('.'),col('.'),0),'name') =~ '" .
                            	\ "\\<ruby\\%(String\\|StringDelimiter\\|ASCIICode\\|Escape\\|" .
                                    \ "Regexp\\|RegexpDelimiter\\|" .
                            	\ "Interpolation\\|NoInterpolation\\|Comment\\|Documentation\\|" .
                            	\ "ConditionalModifier\\|RepeatModifier\\|OptionalDo\\|" .
                            	\ "Function\\|BlockArgument\\|KeywordAsMethod\\|ClassVariable\\|" .
                            	\ "InstanceVariable\\|GlobalVariable\\|Symbol\\)\\>'"
    4              0.000005 endif
                            
    4              0.000017 setlocal formatoptions-=t formatoptions+=croql
                            
    4              0.000016 setlocal include=^\\s*\\<\\(load\\>\\\|require\\>\\\|autoload\\s*:\\=[\"']\\=\\h\\w*[\"']\\=,\\)
    4              0.000012 setlocal includeexpr=substitute(substitute(v:fname,'::','/','g'),'$','.rb','')
    4              0.000008 setlocal suffixesadd=.rb
                            
    4              0.000021 if exists("&ofu") && has("ruby")
    4              0.000009   setlocal omnifunc=rubycomplete#Complete
    4              0.000004 endif
                            
                            " To activate, :set ballooneval
    4              0.000015 if has('balloon_eval') && exists('+balloonexpr')
    4              0.000008   setlocal balloonexpr=RubyBalloonexpr()
    4              0.000004 endif
                            
                            
                            " TODO:
                            "setlocal define=^\\s*def
                            
    4              0.000013 setlocal comments=:#
    4              0.000019 setlocal commentstring=#\ %s
                            
    4              0.000015 if !exists('g:ruby_version_paths')
                              let g:ruby_version_paths = {}
                            endif
                            
    4              0.000016 function! s:query_path(root)
                              let code = "print $:.join %q{,}"
                              if &shell =~# 'sh'
                                let prefix = 'env PATH='.shellescape($PATH).' '
                              else
                                let prefix = ''
                              endif
                              if &shellxquote == "'"
                                let path_check = prefix.'ruby -e "' . code . '"'
                              else
                                let path_check = prefix."ruby -e '" . code . "'"
                              endif
                            
                              let cd = haslocaldir() ? 'lcd' : 'cd'
                              let cwd = getcwd()
                              try
                                exe cd fnameescape(a:root)
                                let path = split(system(path_check),',')
                                exe cd fnameescape(cwd)
                                return path
                              finally
                                exe cd fnameescape(cwd)
                              endtry
                            endfunction
                            
    4              0.000012 function! s:build_path(path)
                              let path = join(map(copy(a:path), 'v:val ==# "." ? "" : v:val'), ',')
                              if &g:path !~# '\v^\.%(,/%(usr|emx)/include)=,,$'
                                let path = substitute(&g:path,',,$',',','') . ',' . path
                              endif
                              return path
                            endfunction
                            
    4              0.000128 if !exists('b:ruby_version') && !exists('g:ruby_path') && isdirectory(expand('%:p:h'))
    4              0.001363   let s:version_file = findfile('.ruby-version', '.;')
    4              0.000022   if !empty(s:version_file)
                                let b:ruby_version = get(readfile(s:version_file, '', 1), '')
                                if !has_key(g:ruby_version_paths, b:ruby_version)
                                  let g:ruby_version_paths[b:ruby_version] = s:query_path(fnamemodify(s:version_file, ':p:h'))
                                endif
                              endif
    4              0.000007 endif
                            
    4              0.000012 if exists("g:ruby_path")
                              let s:ruby_path = type(g:ruby_path) == type([]) ? join(g:ruby_path, ',') : g:ruby_path
                            elseif has_key(g:ruby_version_paths, get(b:, 'ruby_version', ''))
                              let s:ruby_paths = g:ruby_version_paths[b:ruby_version]
                              let s:ruby_path = s:build_path(s:ruby_paths)
                            else
    4              0.000012   if !exists('g:ruby_default_path')
                                if has("ruby") && has("win32")
                                  ruby ::VIM::command( 'let g:ruby_default_path = split("%s",",")' % $:.join(%q{,}) )
                                elseif executable('ruby')
                                  let g:ruby_default_path = s:query_path($HOME)
                                else
                                  let g:ruby_default_path = map(split($RUBYLIB,':'), 'v:val ==# "." ? "" : v:val')
                                endif
                              endif
    4              0.000008   let s:ruby_paths = g:ruby_default_path
    4   0.000214   0.000042   let s:ruby_path = s:build_path(s:ruby_paths)
    4              0.000006 endif
                            
    4              0.000014 if stridx(&l:path, s:ruby_path) == -1
    4              0.000013   let &l:path = s:ruby_path
    4              0.000004 endif
    4              0.000119 if exists('s:ruby_paths') && stridx(&l:tags, join(map(copy(s:ruby_paths),'v:val."/tags"'),',')) == -1
    4              0.000096   let &l:tags = &tags . ',' . join(map(copy(s:ruby_paths),'v:val."/tags"'),',')
    4              0.000005 endif
                            
    4              0.000017 if has("gui_win32") && !exists("b:browsefilter")
                              let b:browsefilter = "Ruby Source Files (*.rb)\t*.rb\n" .
                                                 \ "All Files (*.*)\t*.*\n"
                            endif
                            
    4              0.000036 let b:undo_ftplugin = "setl fo< inc< inex< sua< def< com< cms< path< tags< kp<"
                                  \."| unlet! b:browsefilter b:match_ignorecase b:match_words b:match_skip"
                                  \."| if exists('&ofu') && has('ruby') | setl ofu< | endif"
                                  \."| if has('balloon_eval') && exists('+bexpr') | setl bexpr< | endif"
                            
    4              0.000017 if !exists("g:no_plugin_maps") && !exists("g:no_ruby_maps")
    4              0.000219   nnoremap <silent> <buffer> [m :<C-U>call <SID>searchsyn('\<def\>','rubyDefine','b','n')<CR>
    4              0.000060   nnoremap <silent> <buffer> ]m :<C-U>call <SID>searchsyn('\<def\>','rubyDefine','','n')<CR>
    4              0.000056   nnoremap <silent> <buffer> [M :<C-U>call <SID>searchsyn('\<end\>','rubyDefine','b','n')<CR>
    4              0.000062   nnoremap <silent> <buffer> ]M :<C-U>call <SID>searchsyn('\<end\>','rubyDefine','','n')<CR>
    4              0.000059   xnoremap <silent> <buffer> [m :<C-U>call <SID>searchsyn('\<def\>','rubyDefine','b','v')<CR>
    4              0.000056   xnoremap <silent> <buffer> ]m :<C-U>call <SID>searchsyn('\<def\>','rubyDefine','','v')<CR>
    4              0.000061   xnoremap <silent> <buffer> [M :<C-U>call <SID>searchsyn('\<end\>','rubyDefine','b','v')<CR>
    4              0.000061   xnoremap <silent> <buffer> ]M :<C-U>call <SID>searchsyn('\<end\>','rubyDefine','','v')<CR>
                            
    4              0.000069   nnoremap <silent> <buffer> [[ :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>','rubyModule\<Bar>rubyClass','b','n')<CR>
    4              0.000069   nnoremap <silent> <buffer> ]] :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>','rubyModule\<Bar>rubyClass','','n')<CR>
    4              0.000062   nnoremap <silent> <buffer> [] :<C-U>call <SID>searchsyn('\<end\>','rubyModule\<Bar>rubyClass','b','n')<CR>
    4              0.000062   nnoremap <silent> <buffer> ][ :<C-U>call <SID>searchsyn('\<end\>','rubyModule\<Bar>rubyClass','','n')<CR>
    4              0.000074   xnoremap <silent> <buffer> [[ :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>','rubyModule\<Bar>rubyClass','b','v')<CR>
    4              0.000072   xnoremap <silent> <buffer> ]] :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>','rubyModule\<Bar>rubyClass','','v')<CR>
    4              0.000062   xnoremap <silent> <buffer> [] :<C-U>call <SID>searchsyn('\<end\>','rubyModule\<Bar>rubyClass','b','v')<CR>
    4              0.000062   xnoremap <silent> <buffer> ][ :<C-U>call <SID>searchsyn('\<end\>','rubyModule\<Bar>rubyClass','','v')<CR>
                            
    4              0.000046   let b:undo_ftplugin = b:undo_ftplugin
                                    \."| sil! exe 'unmap <buffer> [[' | sil! exe 'unmap <buffer> ]]' | sil! exe 'unmap <buffer> []' | sil! exe 'unmap <buffer> ]['"
                                    \."| sil! exe 'unmap <buffer> [m' | sil! exe 'unmap <buffer> ]m' | sil! exe 'unmap <buffer> [M' | sil! exe 'unmap <buffer> ]M'"
                            
    4              0.000047   if maparg('im','n') == ''
    4              0.000052     onoremap <silent> <buffer> im :<C-U>call <SID>wrap_i('[m',']M')<CR>
    4              0.000047     onoremap <silent> <buffer> am :<C-U>call <SID>wrap_a('[m',']M')<CR>
    4              0.000048     xnoremap <silent> <buffer> im :<C-U>call <SID>wrap_i('[m',']M')<CR>
    4              0.000047     xnoremap <silent> <buffer> am :<C-U>call <SID>wrap_a('[m',']M')<CR>
    4              0.000030     let b:undo_ftplugin = b:undo_ftplugin
                                      \."| sil! exe 'ounmap <buffer> im' | sil! exe 'ounmap <buffer> am'"
                                      \."| sil! exe 'xunmap <buffer> im' | sil! exe 'xunmap <buffer> am'"
    4              0.000004   endif
                            
    4              0.000046   if maparg('iM','n') == ''
    4              0.000051     onoremap <silent> <buffer> iM :<C-U>call <SID>wrap_i('[[','][')<CR>
    4              0.000059     onoremap <silent> <buffer> aM :<C-U>call <SID>wrap_a('[[','][')<CR>
    4              0.000059     xnoremap <silent> <buffer> iM :<C-U>call <SID>wrap_i('[[','][')<CR>
    4              0.000046     xnoremap <silent> <buffer> aM :<C-U>call <SID>wrap_a('[[','][')<CR>
    4              0.000045     let b:undo_ftplugin = b:undo_ftplugin
                                      \."| sil! exe 'ounmap <buffer> iM' | sil! exe 'ounmap <buffer> aM'"
                                      \."| sil! exe 'xunmap <buffer> iM' | sil! exe 'xunmap <buffer> aM'"
    4              0.000004   endif
                            
    4              0.000042   if maparg("\<C-]>",'n') == ''
    4              0.000068     cnoremap <buffer> <SID>foldopen <Bar>if &foldopen =~# 'tag'<Bar>exe 'norm! zv'<Bar>endif
    4              0.000064     nnoremap <silent> <script> <buffer> <C-]>       :<C-U>exe  v:count1."tag <C-R>=RubyCursorIdentifier()<CR>"<SID>foldopen<CR>
    4              0.000094     nnoremap <silent> <script> <buffer> g<C-]>      :<C-U>exe         "tjump <C-R>=RubyCursorIdentifier()<CR>"<SID>foldopen<CR>
    4              0.000063     nnoremap <silent> <script> <buffer> g]          :<C-U>exe       "tselect <C-R>=RubyCursorIdentifier()<CR>"<SID>foldopen<CR>
    4              0.000061     nnoremap <silent> <script> <buffer> <C-W>]      :<C-U>exe v:count1."stag <C-R>=RubyCursorIdentifier()<CR>"<SID>foldopen<CR>
    4              0.000062     nnoremap <silent> <script> <buffer> <C-W><C-]>  :<C-U>exe v:count1."stag <C-R>=RubyCursorIdentifier()<CR>"<SID>foldopen<CR>
    4              0.000064     nnoremap <silent> <script> <buffer> <C-W>g<C-]> :<C-U>exe        "stjump <C-R>=RubyCursorIdentifier()<CR>"<SID>foldopen<CR>
    4              0.000062     nnoremap <silent> <script> <buffer> <C-W>g]     :<C-U>exe      "stselect <C-R>=RubyCursorIdentifier()<CR>"<SID>foldopen<CR>
    4              0.000057     nnoremap <silent> <script> <buffer> <C-W>}      :<C-U>exe          "ptag <C-R>=RubyCursorIdentifier()<CR>"<CR>
    4              0.000058     nnoremap <silent> <script> <buffer> <C-W>g}     :<C-U>exe        "ptjump <C-R>=RubyCursorIdentifier()<CR>"<CR>
    4              0.000056     let b:undo_ftplugin = b:undo_ftplugin
                                      \."| sil! exe 'nunmap <buffer> <C-]>'| sil! exe 'nunmap <buffer> g<C-]>'| sil! exe 'nunmap <buffer> g]'"
                                      \."| sil! exe 'nunmap <buffer> <C-W>]'| sil! exe 'nunmap <buffer> <C-W><C-]>'"
                                      \."| sil! exe 'nunmap <buffer> <C-W>g<C-]>'| sil! exe 'nunmap <buffer> <C-W>g]'"
                                      \."| sil! exe 'nunmap <buffer> <C-W>}'| sil! exe 'nunmap <buffer> <C-W>g}'"
    4              0.000004   endif
                            
    4              0.000044   if maparg("gf",'n') == ''
                                " By using findfile() rather than gf's normal behavior, we prevent
                                " erroneously editing a directory.
    4              0.000055     nnoremap <silent> <buffer> gf         :<C-U>exe <SID>gf(v:count1,"gf",'edit')<CR>
    4              0.000064     nnoremap <silent> <buffer> <C-W>f     :<C-U>exe <SID>gf(v:count1,"\<Lt>C-W>f",'split')<CR>
    4              0.000063     nnoremap <silent> <buffer> <C-W><C-F> :<C-U>exe <SID>gf(v:count1,"\<Lt>C-W>\<Lt>C-F>",'split')<CR>
    4              0.000059     nnoremap <silent> <buffer> <C-W>gf    :<C-U>exe <SID>gf(v:count1,"\<Lt>C-W>gf",'tabedit')<CR>
    4              0.000036     let b:undo_ftplugin = b:undo_ftplugin
                                      \."| sil! exe 'nunmap <buffer> gf' | sil! exe 'nunmap <buffer> <C-W>f' | sil! exe 'nunmap <buffer> <C-W><C-F>' | sil! exe 'nunmap <buffer> <C-W>gf'"
    4              0.000004   endif
    4              0.000008 endif
                            
    4              0.000028 let &cpo = s:cpo_save
    4              0.000008 unlet s:cpo_save
                            
    4              0.000015 if exists("g:did_ruby_ftplugin_functions")
    4              0.000004   finish

SCRIPT  /Users/klangton/.yadr/vim/bundle/splitjoin.vim/ftplugin/ruby/splitjoin.vim
Sourced 4 times
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
                            if !exists('b:splitjoin_split_callbacks')
    4              0.000054   let b:splitjoin_split_callbacks = [
                                    \ 'sj#ruby#SplitArrayLiteral',
                                    \ 'sj#ruby#SplitProcShorthand',
                                    \ 'sj#ruby#SplitBlock',
                                    \ 'sj#ruby#SplitIfClause',
                                    \ 'sj#ruby#SplitOptions',
                                    \ 'sj#ruby#SplitCachingConstruct',
                                    \ 'sj#ruby#SplitString',
                                    \ 'sj#ruby#SplitWhenThen',
                                    \ 'sj#ruby#SplitCase',
                                    \ 'sj#ruby#SplitTernaryClause',
                                    \ ]
    4              0.000005 endif
                            
    4              0.000013 if !exists('b:splitjoin_join_callbacks')
    4              0.000048   let b:splitjoin_join_callbacks = [
                                    \ 'sj#ruby#JoinArrayLiteral',
                                    \ 'sj#ruby#JoinBlock',
                                    \ 'sj#ruby#JoinHash',
                                    \ 'sj#ruby#JoinIfClause',
                                    \ 'sj#ruby#JoinTernaryClause',
                                    \ 'sj#ruby#JoinCachingConstruct',
                                    \ 'sj#ruby#JoinContinuedMethodCall',
                                    \ 'sj#ruby#JoinHeredoc',
                                    \ 'sj#ruby#JoinWhenThen',
                                    \ 'sj#ruby#JoinCase',
                                    \ ]
    4              0.000011 endif

SCRIPT  /usr/local/Cellar/macvim/7.4-73/MacVim.app/Contents/Resources/vim/runtime/ftplugin/ruby.vim
Sourced 4 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:		Ruby
                            " Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:  Doug Kearns <dougkearns@gmail.com>
                            " ----------------------------------------------------------------------------
                            
    4              0.000021 if (exists("b:did_ftplugin"))
    4              0.000005   finish

SCRIPT  /Users/klangton/.yadr/vim/bundle/vim-ruby/indent/ruby.vim
Sourced 5 times
Total time:   0.000304
 Self time:   0.000304

count  total (s)   self (s)
                            " Vim indent file
                            " Language:		Ruby
                            " Maintainer:		Nikolai Weibull <now at bitwi.se>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            
                            " 0. Initialization {{{1
                            " =================
                            
                            " Only load this indent file when no other was loaded.
    5              0.000030 if exists("b:did_indent")
                              finish
                            endif
    5              0.000015 let b:did_indent = 1
                            
    5              0.000021 if !exists('g:ruby_indent_access_modifier_style')
                              " Possible values: "normal", "indent", "outdent"
                              let g:ruby_indent_access_modifier_style = 'normal'
                            endif
                            
    5              0.000018 setlocal nosmartindent
                            
                            " Now, set up our indentation expression and keys that trigger it.
    5              0.000018 setlocal indentexpr=GetRubyIndent(v:lnum)
    5              0.000019 setlocal indentkeys=0{,0},0),0],!^F,o,O,e,:,.
    5              0.000018 setlocal indentkeys+==end,=else,=elsif,=when,=ensure,=rescue,==begin,==end
    5              0.000017 setlocal indentkeys+==private,=protected,=public
                            
                            " Only define the function once.
    5              0.000020 if exists("*GetRubyIndent")
    5              0.000006   finish

SCRIPT  /usr/local/Cellar/macvim/7.4-73/MacVim.app/Contents/Resources/vim/runtime/indent/ruby.vim
Sourced 5 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
                            " Vim indent file
                            " Language:		Ruby
                            " Maintainer:		Nikolai Weibull <now at bitwi.se>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            
                            " 0. Initialization {{{1
                            " =================
                            
                            " Only load this indent file when no other was loaded.
    5              0.000032 if exists("b:did_indent")
    5              0.000009   finish

SCRIPT  /Users/klangton/.yadr/vim/bundle/vim-ruby/syntax/ruby.vim
Sourced 8 times
Total time:   0.030397
 Self time:   0.030397

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:		Ruby
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            " ----------------------------------------------------------------------------
                            "
                            " Previous Maintainer:	Mirko Nasato
                            " Thanks to perl.vim authors, and to Reimer Behrends. :-) (MN)
                            " ----------------------------------------------------------------------------
                            
    8              0.000045 if exists("b:current_syntax")
                              finish
                            endif
                            
    8              0.000037 if has("folding") && exists("ruby_fold")
                              setlocal foldmethod=syntax
                            endif
                            
    8              0.000321 syn cluster rubyNotTop contains=@rubyExtendedStringSpecial,@rubyRegexpSpecial,@rubyDeclaration,rubyConditional,rubyExceptional,rubyMethodExceptional,rubyTodo
                            
    8              0.000026 if exists("ruby_space_errors")
                              if !exists("ruby_no_trail_space_error")
                                syn match rubySpaceError display excludenl "\s\+$"
                              endif
                              if !exists("ruby_no_tab_space_error")
                                syn match rubySpaceError display " \+\t"me=e-1
                              endif
                            endif
                            
                            " Operators
    8              0.000057 if exists("ruby_operators")
                              syn match  rubyOperator "[~!^&|*/%+-]\|\%(class\s*\)\@<!<<\|<=>\|<=\|\%(<\|\<class\s\+\u\w*\s*\)\@<!<[^<]\@=\|===\|==\|=\~\|>>\|>=\|=\@<!>\|\*\*\|\.\.\.\|\.\.\|::"
                              syn match  rubyOperator "->\|-=\|/=\|\*\*=\|\*=\|&&=\|&=\|&&\|||=\||=\|||\|%=\|+=\|!\~\|!="
                              syn region rubyBracketOperator matchgroup=rubyOperator start="\%(\w[?!]\=\|[]})]\)\@<=\[\s*" end="\s*]" contains=ALLBUT,@rubyNotTop
                            endif
                            
                            " Expression Substitution and Backslash Notation
    8              0.000101 syn match rubyStringEscape "\\\\\|\\[abefnrstv]\|\\\o\{1,3}\|\\x\x\{1,2}"						    contained display
    8              0.000108 syn match rubyStringEscape "\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=\S\)" contained display
    8              0.000070 syn match rubyQuoteEscape  "\\[\\']"											    contained display
                            
    8              0.000114 syn region rubyInterpolation	      matchgroup=rubyInterpolationDelimiter start="#{" end="}" contained contains=ALLBUT,@rubyNotTop
    8              0.000284 syn match  rubyInterpolation	      "#\%(\$\|@@\=\)\w\+"    display contained contains=rubyInterpolationDelimiter,rubyInstanceVariable,rubyClassVariable,rubyGlobalVariable,rubyPredefinedVariable
    8              0.000071 syn match  rubyInterpolationDelimiter "#\ze\%(\$\|@@\=\)\w\+" display contained
    8              0.000198 syn match  rubyInterpolation	      "#\$\%(-\w\|\W\)"       display contained contains=rubyInterpolationDelimiter,rubyPredefinedVariable,rubyInvalidVariable
    8              0.000059 syn match  rubyInterpolationDelimiter "#\ze\$\%(-\w\|\W\)"    display contained
    8              0.000086 syn region rubyNoInterpolation	      start="\\#{" end="}"            contained
    8              0.000051 syn match  rubyNoInterpolation	      "\\#{"		      display contained
    8              0.000064 syn match  rubyNoInterpolation	      "\\#\%(\$\|@@\=\)\w\+"  display contained
    8              0.000054 syn match  rubyNoInterpolation	      "\\#\$\W"		      display contained
                            
    8              0.000104 syn match rubyDelimEscape	"\\[(<{\[)>}\]]" transparent display contained contains=NONE
                            
    8              0.000116 syn region rubyNestedParentheses    start="("  skip="\\\\\|\\)"  matchgroup=rubyString end=")"	transparent contained
    8              0.000123 syn region rubyNestedCurlyBraces    start="{"  skip="\\\\\|\\}"  matchgroup=rubyString end="}"	transparent contained
    8              0.000106 syn region rubyNestedAngleBrackets  start="<"  skip="\\\\\|\\>"  matchgroup=rubyString end=">"	transparent contained
    8              0.000100 syn region rubyNestedSquareBrackets start="\[" skip="\\\\\|\\\]" matchgroup=rubyString end="\]"	transparent contained
                            
                            " These are mostly Oniguruma ready
    8              0.000101 syn region rubyRegexpComment	matchgroup=rubyRegexpSpecial   start="(?#"								  skip="\\)"  end=")"  contained
    8              0.000154 syn region rubyRegexpParens	matchgroup=rubyRegexpSpecial   start="(\(?:\|?<\=[=!]\|?>\|?<[a-z_]\w*>\|?[imx]*-[imx]*:\=\|\%(?#\)\@!\)" skip="\\)"  end=")"  contained transparent contains=@rubyRegexpSpecial
    8              0.000235 syn region rubyRegexpBrackets	matchgroup=rubyRegexpCharClass start="\[\^\="								  skip="\\\]" end="\]" contained transparent contains=rubyStringEscape,rubyRegexpEscape,rubyRegexpCharClass oneline
    8              0.000098 syn match  rubyRegexpCharClass	"\\[DdHhSsWw]"	       contained display
    8              0.000158 syn match  rubyRegexpCharClass	"\[:\^\=\%(alnum\|alpha\|ascii\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\):\]" contained
    8              0.000059 syn match  rubyRegexpEscape	"\\[].*?+^$|\\/(){}[]" contained
    8              0.000063 syn match  rubyRegexpQuantifier	"[*?+][?+]\="	       contained display
    8              0.000063 syn match  rubyRegexpQuantifier	"{\d\+\%(,\d*\)\=}?\=" contained display
    8              0.000063 syn match  rubyRegexpAnchor	"[$^]\|\\[ABbGZz]"     contained display
    8              0.000048 syn match  rubyRegexpDot	"\."		       contained display
    8              0.000045 syn match  rubyRegexpSpecial	"|"		       contained display
    8              0.000053 syn match  rubyRegexpSpecial	"\\[1-9]\d\=\d\@!"     contained display
    8              0.000076 syn match  rubyRegexpSpecial	"\\k<\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\=>" contained display
    8              0.000066 syn match  rubyRegexpSpecial	"\\k'\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\='" contained display
    8              0.000071 syn match  rubyRegexpSpecial	"\\g<\%([a-z_]\w*\|-\=\d\+\)>" contained display
    8              0.000064 syn match  rubyRegexpSpecial	"\\g'\%([a-z_]\w*\|-\=\d\+\)'" contained display
                            
    8              0.000148 syn cluster rubyStringSpecial	      contains=rubyInterpolation,rubyNoInterpolation,rubyStringEscape
    8              0.000203 syn cluster rubyExtendedStringSpecial contains=@rubyStringSpecial,rubyNestedParentheses,rubyNestedCurlyBraces,rubyNestedAngleBrackets,rubyNestedSquareBrackets
    8              0.000492 syn cluster rubyRegexpSpecial	      contains=rubyInterpolation,rubyNoInterpolation,rubyStringEscape,rubyRegexpSpecial,rubyRegexpEscape,rubyRegexpBrackets,rubyRegexpCharClass,rubyRegexpDot,rubyRegexpQuantifier,rubyRegexpAnchor,rubyRegexpParens,rubyRegexpComment
                            
                            " Numbers and ASCII Codes
    8              0.000121 syn match rubyASCIICode	"\%(\w\|[]})\"'/]\)\@<!\%(?\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\=\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=\S\)\)"
    8              0.000088 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<0[xX]\x\+\%(_\x\+\)*\>"								display
    8              0.000090 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<\%(0[dD]\)\=\%(0\|[1-9]\d*\%(_\d\+\)*\)\>"						display
    8              0.000080 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<0[oO]\=\o\+\%(_\o\+\)*\>"								display
    8              0.000079 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<0[bB][01]\+\%(_[01]\+\)*\>"								display
    8              0.000085 syn match rubyFloat	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\.\d\+\%(_\d\+\)*\>"					display
    8              0.000099 syn match rubyFloat	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\%(\.\d\+\%(_\d\+\)*\)\=\%([eE][-+]\=\d\+\%(_\d\+\)*\)\>"	display
                            
                            " Identifiers
    8              0.000103 syn match rubyLocalVariableOrMethod "\<[_[:lower:]][_[:alnum:]]*[?!=]\=" contains=NONE display transparent
    8              0.000100 syn match rubyBlockArgument	    "&[_[:lower:]][_[:alnum:]]"		 contains=NONE display transparent
                            
    8              0.000095 syn match  rubyConstant		"\%(\%(^\|[^.]\)\.\s*\)\@<!\<\u\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@!"
    8              0.000114 syn match  rubyClassVariable	"@@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*" display
    8              0.000081 syn match  rubyInstanceVariable "@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"  display
    8              0.000073 syn match  rubyGlobalVariable	"$\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\|-.\)"
    8              0.000107 syn match  rubySymbol		"[]})\"':]\@<!:\%(\^\|\~\|<<\|<=>\|<=\|<\|===\|[=!]=\|[=!]\~\|!\|>>\|>=\|>\||\|-@\|-\|/\|\[]=\|\[]\|\*\*\|\*\|&\|%\|+@\|+\|`\)"
    8              0.000073 syn match  rubySymbol		"[]})\"':]\@<!:\$\%(-.\|[`~<=>_,;:!?/.'"@$*\&+0]\)"
    8              0.000081 syn match  rubySymbol		"[]})\"':]\@<!:\%(\$\|@@\=\)\=\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"
    8              0.000077 syn match  rubySymbol		"[]})\"':]\@<!:\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\%([?!=]>\@!\)\="
    8              0.000168 syn region rubySymbol		start="[]})\"':]\@<!:'"  end="'"  skip="\\\\\|\\'"  contains=rubyQuoteEscape fold
    8              0.000124 syn region rubySymbol		start="[]})\"':]\@<!:\"" end="\"" skip="\\\\\|\\\"" contains=@rubyStringSpecial fold
                            
    8              0.000095 syn match  rubyCapitalizedMethod	"\%(\%(^\|[^.]\)\.\s*\)\@<!\<\u\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)*\s*(\@="
                            
    8              0.000069 syn match  rubyBlockParameter	  "\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*" contained
    8              0.000131 syn region rubyBlockParameterList start="\%(\%(\<do\>\|{\)\s*\)\@<=|" end="|" oneline display contains=rubyBlockParameter
                            
    8              0.000069 syn match rubyInvalidVariable	 "$[^ A-Za-z_-]"
    8              0.000062 syn match rubyPredefinedVariable #$[!$&"'*+,./0:;<=>?@\`~]#
    8              0.000047 syn match rubyPredefinedVariable "$\d\+"										   display
    8              0.000047 syn match rubyPredefinedVariable "$_\>"											   display
    8              0.000064 syn match rubyPredefinedVariable "$-[0FIKadilpvw]\>"									   display
    8              0.000128 syn match rubyPredefinedVariable "$\%(deferr\|defout\|stderr\|stdin\|stdout\)\>"					   display
    8              0.000091 syn match rubyPredefinedVariable "$\%(DEBUG\|FILENAME\|KCODE\|LOADED_FEATURES\|LOAD_PATH\|PROGRAM_NAME\|SAFE\|VERBOSE\)\>" display
    8              0.000111 syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(ARGF\|ARGV\|ENV\|DATA\|FALSE\|NIL\|STDERR\|STDIN\|STDOUT\|TOPLEVEL_BINDING\|TRUE\)\>\%(\s*(\)\@!"
    8              0.000111 syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(RUBY_\%(VERSION\|RELEASE_DATE\|PLATFORM\|PATCHLEVEL\|REVISION\|DESCRIPTION\|COPYRIGHT\|ENGINE\)\)\>\%(\s*(\)\@!"
                            
                            " Normal Regular Expression
    8              0.000196 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\%(^\|\<\%(and\|or\|while\|until\|unless\|if\|elsif\|when\|not\|then\|else\)\|[;\~=!|&(,{[<>?:*+-]\)\s*\)\@<=/" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial fold
    8              0.000164 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\h\k*\s\+\)\@<=/[ \t=]\@!" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial fold
                            
                            " Generalized Regular Expression
    8              0.000148 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\z([~`!@#$%^&*_\-+=|\:;"',.? /]\)" end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial fold
    8              0.000140 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r{"				 end="}[iomxneus]*"   skip="\\\\\|\\}"	 contains=@rubyRegexpSpecial fold
    8              0.000250 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r<"				 end=">[iomxneus]*"   skip="\\\\\|\\>"	 contains=@rubyRegexpSpecial,rubyNestedAngleBrackets,rubyDelimEscape fold
    8              0.000129 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\["				 end="\][iomxneus]*"  skip="\\\\\|\\\]"	 contains=@rubyRegexpSpecial fold
    8              0.000124 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r("				 end=")[iomxneus]*"   skip="\\\\\|\\)"	 contains=@rubyRegexpSpecial fold
                            
                            " Normal String and Shell Command Output
    8              0.000037 if exists('ruby_spellcheck_strings')
                              syn region rubyString matchgroup=rubyStringDelimiter start="\"" end="\"" skip="\\\\\|\\\"" contains=@rubyStringSpecial,@Spell fold
                              syn region rubyString matchgroup=rubyStringDelimiter start="'"  end="'"  skip="\\\\\|\\'"  contains=rubyQuoteEscape,@Spell    fold
                            else
    8              0.000114   syn region rubyString matchgroup=rubyStringDelimiter start="\"" end="\"" skip="\\\\\|\\\"" contains=@rubyStringSpecial fold
    8              0.000151   syn region rubyString matchgroup=rubyStringDelimiter start="'"  end="'"  skip="\\\\\|\\'"  contains=rubyQuoteEscape    fold
    8              0.000010 endif
    8              0.000119 syn region rubyString matchgroup=rubyStringDelimiter start="`" end="`" skip="\\\\\|\\`" contains=@rubyStringSpecial fold
                            
                            " Generalized Single Quoted String, Symbol and Array of Strings
    8              0.000131 syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" fold
    8              0.000191 syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]{"				   end="}"   skip="\\\\\|\\}"	fold contains=rubyNestedCurlyBraces,rubyDelimEscape
    8              0.000203 syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]<"				   end=">"   skip="\\\\\|\\>"	fold contains=rubyNestedAngleBrackets,rubyDelimEscape
    8              0.000192 syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]\["				   end="\]"  skip="\\\\\|\\\]"	fold contains=rubyNestedSquareBrackets,rubyDelimEscape
    8              0.000191 syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]("				   end=")"   skip="\\\\\|\\)"	fold contains=rubyNestedParentheses,rubyDelimEscape
    8              0.000102 syn region rubyString matchgroup=rubyStringDelimiter start="%q "				   end=" "   skip="\\\\\|\\)"	fold
    8              0.000131 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s\z([~`!@#$%^&*_\-+=|\:;"',.? /]\)"   end="\z1" skip="\\\\\|\\\z1" fold
    8              0.000187 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s{"				   end="}"   skip="\\\\\|\\}"	fold contains=rubyNestedCurlyBraces,rubyDelimEscape
    8              0.000187 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s<"				   end=">"   skip="\\\\\|\\>"	fold contains=rubyNestedAngleBrackets,rubyDelimEscape
    8              0.000185 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s\["				   end="\]"  skip="\\\\\|\\\]"	fold contains=rubyNestedSquareBrackets,rubyDelimEscape
    8              0.000184 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s("				   end=")"   skip="\\\\\|\\)"	fold contains=rubyNestedParentheses,rubyDelimEscape
                            
                            " Generalized Double Quoted String and Array of Strings and Shell Command Output
                            " Note: %= is not matched here as the beginning of a double quoted string
    8              0.000159 syn region rubyString matchgroup=rubyStringDelimiter start="%\z([~`!@#$%^&*_\-+|\:;"',.?/]\)"	    end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial fold
    8              0.000139 syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial fold
    8              0.000211 syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\={"				    end="}"   skip="\\\\\|\\}"	 contains=@rubyStringSpecial,rubyNestedCurlyBraces,rubyDelimEscape    fold
    8              0.000256 syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=<"				    end=">"   skip="\\\\\|\\>"	 contains=@rubyStringSpecial,rubyNestedAngleBrackets,rubyDelimEscape  fold
    8              0.000206 syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=\["				    end="\]"  skip="\\\\\|\\\]"	 contains=@rubyStringSpecial,rubyNestedSquareBrackets,rubyDelimEscape fold
    8              0.000203 syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=("				    end=")"   skip="\\\\\|\\)"	 contains=@rubyStringSpecial,rubyNestedParentheses,rubyDelimEscape    fold
    8              0.000117 syn region rubyString matchgroup=rubyStringDelimiter start="%[Qx] "				    end=" "   skip="\\\\\|\\)"   contains=@rubyStringSpecial fold
                            
                            " Array of Symbols
    8              0.000129 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" fold
    8              0.000186 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i{"				end="}"   skip="\\\\\|\\}"	fold contains=rubyNestedCurlyBraces,rubyDelimEscape
    8              0.000191 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i<"				end=">"   skip="\\\\\|\\>"	fold contains=rubyNestedAngleBrackets,rubyDelimEscape
    8              0.000195 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i\["				end="\]"  skip="\\\\\|\\\]"	fold contains=rubyNestedSquareBrackets,rubyDelimEscape
    8              0.000192 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i("				end=")"   skip="\\\\\|\\)"	fold contains=rubyNestedParentheses,rubyDelimEscape
                            
                            " Array of interpolated Symbols
    8              0.000134 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial fold
    8              0.000195 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I\={"				end="}"   skip="\\\\\|\\}"	 contains=@rubyStringSpecial,rubyNestedCurlyBraces,rubyDelimEscape    fold
    8              0.000200 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I\=<"				end=">"   skip="\\\\\|\\>"	 contains=@rubyStringSpecial,rubyNestedAngleBrackets,rubyDelimEscape  fold
    8              0.000201 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I\=\["				end="\]"  skip="\\\\\|\\\]"	 contains=@rubyStringSpecial,rubyNestedSquareBrackets,rubyDelimEscape fold
    8              0.000207 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I\=("				end=")"   skip="\\\\\|\\)"	 contains=@rubyStringSpecial,rubyNestedParentheses,rubyDelimEscape    fold
                            
                            " Here Document
    8              0.000166 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<-\=\zs\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)+	 end=+$+ oneline contains=ALLBUT,@rubyNotTop
    8              0.000138 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<-\=\zs"\%([^"]*\)"+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
    8              0.000138 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<-\=\zs'\%([^']*\)'+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
    8              0.000134 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<-\=\zs`\%([^`]*\)`+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
                            
    8              0.000306 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial fold keepend
    8              0.000233 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<"\z([^"]*\)"\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial fold keepend
    8              0.000213 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<'\z([^']*\)'\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc			fold keepend
    8              0.000248 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<`\z([^`]*\)`\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial fold keepend
                            
    8              0.000221 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<-\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+3    matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial fold keepend
    8              0.000203 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<-"\z([^"]*\)"\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial fold keepend
    8              0.000241 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<-'\z([^']*\)'\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart		     fold keepend
    8              0.000207 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<-`\z([^`]*\)`\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial fold keepend
                            
    8              0.000042 if exists('main_syntax') && main_syntax == 'eruby'
    1              0.000003   let b:ruby_no_expensive = 1
    1              0.000001 end
                            
    8              0.000265 syn match  rubyAliasDeclaration    "[^[:space:];#.()]\+" contained contains=rubySymbol,rubyGlobalVariable,rubyPredefinedVariable nextgroup=rubyAliasDeclaration2 skipwhite
    8              0.000207 syn match  rubyAliasDeclaration2   "[^[:space:];#.()]\+" contained contains=rubySymbol,rubyGlobalVariable,rubyPredefinedVariable
    8              0.000313 syn match  rubyMethodDeclaration   "[^[:space:];#(]\+"	 contained contains=rubyConstant,rubyBoolean,rubyPseudoVariable,rubyInstanceVariable,rubyClassVariable,rubyGlobalVariable
    8              0.000131 syn match  rubyClassDeclaration    "[^[:space:];#<]\+"	 contained contains=rubyConstant,rubyOperator
    8              0.000142 syn match  rubyModuleDeclaration   "[^[:space:];#<]\+"	 contained contains=rubyConstant,rubyOperator
    8              0.000107 syn match  rubyFunction "\<[_[:alpha:]][_[:alnum:]]*[?!=]\=[[:alnum:]_.:?!=]\@!" contained containedin=rubyMethodDeclaration
    8              0.000150 syn match  rubyFunction "\%(\s\|^\)\@<=[_[:alpha:]][_[:alnum:]]*[?!=]\=\%(\s\|$\)\@=" contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2
    8              0.000226 syn match  rubyFunction "\%([[:space:].]\|^\)\@<=\%(\[\]=\=\|\*\*\|[+-]@\=\|[*/%|&^~]\|<<\|>>\|[<>]=\=\|<=>\|===\|[=!]=\|[=!]\~\|!\|`\)\%([[:space:];#(]\|$\)\@=" contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration
                            
    8              0.000284 syn cluster rubyDeclaration contains=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration,rubyModuleDeclaration,rubyClassDeclaration,rubyFunction,rubyBlockParameter
                            
                            " Keywords
                            " Note: the following keywords have already been defined:
                            " begin case class def do end for if module unless until while
    8              0.000088 syn match   rubyControl	       "\<\%(and\|break\|in\|next\|not\|or\|redo\|rescue\|retry\|return\)\>[?!]\@!"
    8              0.000049 syn match   rubyOperator       "\<defined?" display
    8              0.000059 syn match   rubyKeyword	       "\<\%(super\|yield\)\>[?!]\@!"
    8              0.000070 syn match   rubyBoolean	       "\<\%(true\|false\)\>[?!]\@!"
    8              0.000091 syn match   rubyPseudoVariable "\<\%(nil\|self\|__ENCODING__\|__dir__\|__FILE__\|__LINE__\|__callee__\|__method__\)\>[?!]\@!" " TODO: reorganise
    8              0.000059 syn match   rubyBeginEnd       "\<\%(BEGIN\|END\)\>[?!]\@!"
                            
                            " Expensive Mode - match 'end' with the appropriate opening keyword for syntax
                            " based folding and special highlighting of module/class/method definitions
    8              0.000045 if !exists("b:ruby_no_expensive") && !exists("ruby_no_expensive")
    5              0.000111   syn match  rubyDefine "\<alias\>"  nextgroup=rubyAliasDeclaration  skipwhite skipnl
    5              0.000125   syn match  rubyDefine "\<def\>"    nextgroup=rubyMethodDeclaration skipwhite skipnl
    5              0.000064   syn match  rubyDefine "\<undef\>"  nextgroup=rubyFunction	     skipwhite skipnl
    5              0.000052   syn match  rubyClass	"\<class\>"  nextgroup=rubyClassDeclaration  skipwhite skipnl
    5              0.000050   syn match  rubyModule "\<module\>" nextgroup=rubyModuleDeclaration skipwhite skipnl
                            
    5              0.000103   syn region rubyMethodBlock start="\<def\>"	matchgroup=rubyDefine end="\%(\<def\_s\+\)\@<!\<end\>" contains=ALLBUT,@rubyNotTop fold
    5              0.000062   syn region rubyBlock	     start="\<class\>"	matchgroup=rubyClass  end="\<end\>"		       contains=ALLBUT,@rubyNotTop fold
    5              0.000056   syn region rubyBlock	     start="\<module\>" matchgroup=rubyModule end="\<end\>"		       contains=ALLBUT,@rubyNotTop fold
                            
                              " modifiers
    5              0.000033   syn match rubyConditionalModifier "\<\%(if\|unless\)\>"    display
    5              0.000075   syn match rubyRepeatModifier	     "\<\%(while\|until\)\>" display
                            
    5              0.000058   syn region rubyDoBlock      matchgroup=rubyControl start="\<do\>" end="\<end\>"                 contains=ALLBUT,@rubyNotTop fold
                              " curly bracket block or hash literal
    5              0.000056   syn region rubyCurlyBlock	matchgroup=rubyCurlyBlockDelimiter  start="{" end="}"				contains=ALLBUT,@rubyNotTop fold
    5              0.000062   syn region rubyArrayLiteral	matchgroup=rubyArrayDelimiter	    start="\%(\w\|[\]})]\)\@<!\[" end="]"	contains=ALLBUT,@rubyNotTop fold
                            
                              " statements without 'do'
    5              0.000055   syn region rubyBlockExpression       matchgroup=rubyControl	  start="\<begin\>" end="\<end\>" contains=ALLBUT,@rubyNotTop fold
    5              0.000079   syn region rubyCaseExpression	       matchgroup=rubyConditional start="\<case\>"  end="\<end\>" contains=ALLBUT,@rubyNotTop fold
    5              0.000107   syn region rubyConditionalExpression matchgroup=rubyConditional start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*%&^|+=-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![?!]\)\s*\)\@<=\%(if\|unless\)\>" end="\%(\%(\%(\.\@<!\.\)\|::\)\s*\)\@<!\<end\>" contains=ALLBUT,@rubyNotTop fold
                            
    5              0.000073   syn match rubyConditional "\<\%(then\|else\|when\)\>[?!]\@!"	contained containedin=rubyCaseExpression
    5              0.000064   syn match rubyConditional "\<\%(then\|else\|elsif\)\>[?!]\@!" contained containedin=rubyConditionalExpression
                            
    5              0.000069   syn match rubyExceptional	  "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>[?!]\@!" contained containedin=rubyBlockExpression
    5              0.000067   syn match rubyMethodExceptional "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>[?!]\@!" contained containedin=rubyMethodBlock
                            
                              " statements with optional 'do'
    5              0.000135   syn region rubyOptionalDoLine   matchgroup=rubyRepeat start="\<for\>[?!]\@!" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![!=?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyOptionalDo end="\%(\<do\>\)" end="\ze\%(;\|$\)" oneline contains=ALLBUT,@rubyNotTop
    5              0.000162   syn region rubyRepeatExpression start="\<for\>[?!]\@!" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![!=?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyRepeat end="\<end\>" contains=ALLBUT,@rubyNotTop nextgroup=rubyOptionalDoLine fold
                            
    5              0.000024   if !exists("ruby_minlines")
                                let ruby_minlines = 500
                              endif
    5              0.000034   exec "syn sync minlines=" . ruby_minlines
                            
    5              0.000006 else
    3              0.000044   syn match rubyControl "\<def\>[?!]\@!"    nextgroup=rubyMethodDeclaration skipwhite skipnl
    3              0.000039   syn match rubyControl "\<class\>[?!]\@!"  nextgroup=rubyClassDeclaration  skipwhite skipnl
    3              0.000044   syn match rubyControl "\<module\>[?!]\@!" nextgroup=rubyModuleDeclaration skipwhite skipnl
    3              0.000037   syn match rubyControl "\<\%(case\|begin\|do\|for\|if\|unless\|while\|until\|else\|elsif\|ensure\|then\|when\|end\)\>[?!]\@!"
    3              0.000024   syn match rubyKeyword "\<\%(alias\|undef\)\>[?!]\@!"
    3              0.000003 endif
                            
                            " Special Methods
    8              0.000027 if !exists("ruby_no_special_methods")
    8              0.000060   syn keyword rubyAccess    public protected private public_class_method private_class_method public_constant private_constant module_function
                              " attr is a common variable name
    8              0.000071   syn match   rubyAttribute "\%(\%(^\|;\)\s*\)\@<=attr\>\(\s*[.=]\)\@!"
    8              0.000042   syn keyword rubyAttribute attr_accessor attr_reader attr_writer
    8              0.000076   syn match   rubyControl   "\<\%(exit!\|\%(abort\|at_exit\|exit\|fork\|loop\|trap\)\>[?!]\@!\)"
    8              0.000045   syn keyword rubyEval	    eval class_eval instance_eval module_eval
    8              0.000040   syn keyword rubyException raise fail catch throw
                              " false positive with 'include?'
    8              0.000109   syn match   rubyInclude   "\<include\>[?!]\@!"
    8              0.000056   syn keyword rubyInclude   autoload extend load prepend refine require require_relative using
    8              0.000043   syn keyword rubyKeyword   callcc caller lambda proc
    8              0.000006 endif
                            
                            " Comments and Documentation
    8              0.000057 syn match   rubySharpBang "\%^#!.*" display
    8              0.000063 syn keyword rubyTodo	  FIXME NOTE TODO OPTIMIZE XXX todo contained
    8              0.000205 syn match   rubyComment   "#.*" contains=rubySharpBang,rubySpaceError,rubyTodo,@Spell
    8              0.000036 if !exists("ruby_no_comment_fold")
    8              0.000191   syn region rubyMultilineComment start="\%(\%(^\s*#.*\n\)\@<!\%(^\s*#.*\n\)\)\%(\(^\s*#.*\n\)\{1,}\)\@=" end="\%(^\s*#.*\n\)\@<=\%(^\s*#.*\n\)\%(^\s*#\)\@!" contains=rubyComment transparent fold keepend
    8              0.000181   syn region rubyDocumentation	  start="^=begin\ze\%(\s.*\)\=$" end="^=end\%(\s.*\)\=$" contains=rubySpaceError,rubyTodo,@Spell fold
    8              0.000012 else
                              syn region rubyDocumentation	  start="^=begin\s*$" end="^=end\s*$" contains=rubySpaceError,rubyTodo,@Spell
                            endif
                            
                            " Note: this is a hack to prevent 'keywords' being highlighted as such when called as methods with an explicit receiver
    8              0.000141 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(alias\|and\|begin\|break\|case\|class\|def\|defined\|do\|else\)\>"		  transparent contains=NONE
    8              0.000129 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(elsif\|end\|ensure\|false\|for\|if\|in\|module\|next\|nil\)\>"		  transparent contains=NONE
    8              0.000138 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(not\|or\|redo\|refine\|rescue\|retry\|return\|self\|super\|then\|true\)\>"		  transparent contains=NONE
    8              0.000137 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(undef\|unless\|until\|when\|while\|yield\|BEGIN\|END\|__FILE__\|__LINE__\)\>" transparent contains=NONE
                            
    8              0.000118 syn match rubyKeywordAsMethod "\<\%(alias\|begin\|case\|class\|def\|do\|end\)[?!]" transparent contains=NONE
    8              0.000111 syn match rubyKeywordAsMethod "\<\%(if\|module\|refine\|undef\|unless\|until\|while\)[?!]" transparent contains=NONE
                            
    8              0.000122 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(abort\|at_exit\|attr\|attr_accessor\|attr_reader\)\>"	transparent contains=NONE
    8              0.000118 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(attr_writer\|autoload\|callcc\|catch\|caller\)\>"		transparent contains=NONE
    8              0.000164 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(eval\|class_eval\|instance_eval\|module_eval\|exit\)\>"	transparent contains=NONE
    8              0.000123 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(extend\|fail\|fork\|include\|lambda\)\>"			transparent contains=NONE
    8              0.000121 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(load\|loop\|prepend\|private\|proc\|protected\)\>"		transparent contains=NONE
    8              0.000125 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(public\|require\|require_relative\|raise\|throw\|trap\|using\)\>"	transparent contains=NONE
                            
    8              0.000071 syn match  rubySymbol		"\%([{(,]\_s*\)\@<=\l\w*[!?]\=::\@!"he=e-1
    8              0.000096 syn match  rubySymbol		"[]})\"':]\@<!\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:[[:space:],]\@="he=e-1
    8              0.000081 syn match  rubySymbol		"\%([{(,]\_s*\)\@<=[[:space:],{]\l\w*[!?]\=::\@!"hs=s+1,he=e-1
    8              0.000087 syn match  rubySymbol		"[[:space:],{(]\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:[[:space:],]\@="hs=s+1,he=e-1
                            
                            " __END__ Directive
    8              0.000084 syn region rubyData matchgroup=rubyDataDirective start="^__END__$" end="\%$" fold
                            
    8              0.000119 hi def link rubyClass			rubyDefine
    8              0.000057 hi def link rubyModule			rubyDefine
    8              0.000058 hi def link rubyMethodExceptional	rubyDefine
    8              0.000081 hi def link rubyDefine			Define
    8              0.000058 hi def link rubyFunction		Function
    8              0.000063 hi def link rubyConditional		Conditional
    8              0.000045 hi def link rubyConditionalModifier	rubyConditional
    8              0.000045 hi def link rubyExceptional		rubyConditional
    8              0.000054 hi def link rubyRepeat			Repeat
    8              0.000047 hi def link rubyRepeatModifier		rubyRepeat
    8              0.000039 hi def link rubyOptionalDo		rubyRepeat
    8              0.000062 hi def link rubyControl			Statement
    8              0.000057 hi def link rubyInclude			Include
    8              0.000059 hi def link rubyInteger			Number
    8              0.000060 hi def link rubyASCIICode		Character
    8              0.000057 hi def link rubyFloat			Float
    8              0.000062 hi def link rubyBoolean			Boolean
    8              0.000058 hi def link rubyException		Exception
    8              0.000034 if !exists("ruby_no_identifiers")
    8              0.000063   hi def link rubyIdentifier		Identifier
    8              0.000008 else
                              hi def link rubyIdentifier		NONE
                            endif
    8              0.000045 hi def link rubyClassVariable		rubyIdentifier
    8              0.000056 hi def link rubyConstant		Type
    8              0.000041 hi def link rubyGlobalVariable		rubyIdentifier
    8              0.000083 hi def link rubyBlockParameter		rubyIdentifier
    8              0.000043 hi def link rubyInstanceVariable	rubyIdentifier
    8              0.000039 hi def link rubyPredefinedIdentifier	rubyIdentifier
    8              0.000038 hi def link rubyPredefinedConstant	rubyPredefinedIdentifier
    8              0.000041 hi def link rubyPredefinedVariable	rubyPredefinedIdentifier
    8              0.000068 hi def link rubySymbol			Constant
    8              0.000098 hi def link rubyKeyword			Keyword
    8              0.000062 hi def link rubyOperator		Operator
    8              0.000057 hi def link rubyBeginEnd		Statement
    8              0.000054 hi def link rubyAccess			Statement
    8              0.000057 hi def link rubyAttribute		Statement
    8              0.000058 hi def link rubyEval			Statement
    8              0.000060 hi def link rubyPseudoVariable		Constant
    8              0.000045 hi def link rubyCapitalizedMethod	rubyLocalVariableOrMethod
                            
    8              0.000059 hi def link rubyComment			Comment
    8              0.000056 hi def link rubyData			Comment
    8              0.000056 hi def link rubyDataDirective		Delimiter
    8              0.000056 hi def link rubyDocumentation		Comment
    8              0.000058 hi def link rubyTodo			Todo
                            
    8              0.000046 hi def link rubyQuoteEscape		rubyStringEscape
    8              0.000060 hi def link rubyStringEscape		Special
    8              0.000061 hi def link rubyInterpolationDelimiter	Delimiter
    8              0.000045 hi def link rubyNoInterpolation		rubyString
    8              0.000055 hi def link rubySharpBang		PreProc
    8              0.000044 hi def link rubyRegexpDelimiter		rubyStringDelimiter
    8              0.000041 hi def link rubySymbolDelimiter		rubySymbol
    8              0.000058 hi def link rubyStringDelimiter		Delimiter
    8              0.000042 hi def link rubyHeredoc			rubyString
    8              0.000059 hi def link rubyString			String
    8              0.000043 hi def link rubyRegexpEscape		rubyRegexpSpecial
    8              0.000042 hi def link rubyRegexpQuantifier	rubyRegexpSpecial
    8              0.000043 hi def link rubyRegexpAnchor		rubyRegexpSpecial
    8              0.000042 hi def link rubyRegexpDot		rubyRegexpCharClass
    8              0.000043 hi def link rubyRegexpCharClass		rubyRegexpSpecial
    8              0.000060 hi def link rubyRegexpSpecial		Special
    8              0.000063 hi def link rubyRegexpComment		Comment
    8              0.000070 hi def link rubyRegexp			rubyString
                            
    8              0.000061 hi def link rubyInvalidVariable		Error
    8              0.000059 hi def link rubyError			Error
    8              0.000038 hi def link rubySpaceError		rubyError
                            
    8              0.000029 let b:current_syntax = "ruby"
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet:

SCRIPT  /usr/local/Cellar/macvim/7.4-73/MacVim.app/Contents/Resources/vim/runtime/syntax/ruby.vim
Sourced 8 times
Total time:   0.000150
 Self time:   0.000150

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:		Ruby
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            " ----------------------------------------------------------------------------
                            "
                            " Previous Maintainer:	Mirko Nasato
                            " Thanks to perl.vim authors, and to Reimer Behrends. :-) (MN)
                            " ----------------------------------------------------------------------------
                            
    8              0.000044 if exists("b:current_syntax")
    8              0.000011   finish

SCRIPT  /Users/klangton/.yadr/vim/bundle/splitjoin.vim/ftplugin/yaml/splitjoin.vim
Sourced 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
                            if !exists('b:splitjoin_split_callbacks')
    1              0.000007   let b:splitjoin_split_callbacks = [
                                    \ 'sj#yaml#SplitArray',
                                    \ 'sj#yaml#SplitMap'
                                    \ ]
    1              0.000001 endif
                            
    1              0.000003 if !exists('b:splitjoin_join_callbacks')
    1              0.000005   let b:splitjoin_join_callbacks = [
                                    \ 'sj#yaml#JoinArray',
                                    \ 'sj#yaml#JoinMap'
                                    \ ]
    1              0.000004 endif

SCRIPT  /usr/local/Cellar/macvim/7.4-73/MacVim.app/Contents/Resources/vim/runtime/ftplugin/yaml.vim
Sourced 1 time
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:         YAML (YAML Ain't Markup Language)
                            " Maintainer:       Nikolai Weibull <now@bitwi.se>
                            " Latest Revision:  2008-07-09
                            
    1              0.000006 if exists("b:did_ftplugin")
                              finish
                            endif
    1              0.000003 let b:did_ftplugin = 1
                            
    1              0.000008 let s:cpo_save = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000003 let b:undo_ftplugin = "setl com< cms< et< fo<"
                            
    1              0.000006 setlocal comments=:# commentstring=#\ %s expandtab
    1              0.000004 setlocal formatoptions-=t formatoptions+=croql
                            
    1              0.000006 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save

SCRIPT  /usr/local/Cellar/macvim/7.4-73/MacVim.app/Contents/Resources/vim/runtime/indent/yaml.vim
Sourced 1 time
Total time:   0.000499
 Self time:   0.000499

count  total (s)   self (s)
                            " Vim indent file
                            " Language:         YAML
                            " Maintainer:       Nikolai Pavlov <zyx.vim@gmail.com>
                            
                            " Only load this indent file when no other was loaded.
    1              0.000006 if exists('b:did_indent')
                              finish
                            endif
                            
    1              0.000007 let s:save_cpo = &cpo
    1              0.000006 set cpo&vim
                            
    1              0.000002 let b:did_indent = 1
                            
    1              0.000003 setlocal indentexpr=GetYAMLIndent(v:lnum)
    1              0.000003 setlocal indentkeys=!^F,o,O,0#,0},0],<:>,-
    1              0.000002 setlocal nosmartindent
                            
    1              0.000003 let b:undo_indent = 'setlocal indentexpr< indentkeys< smartindent<'
                            
                            " Only define the function once.
    1              0.000003 if exists('*GetYAMLIndent')
                                finish
                            endif
                            
    1              0.000003 if exists('*shiftwidth')
    1              0.000007     let s:shiftwidth = function('shiftwidth')
    1              0.000002 else
                                function s:shiftwidth()
                                    return &shiftwidth
                                endfunction
                            endif
                            
    1              0.000003 function s:FindPrevLessIndentedLine(lnum, ...)
                                let prevlnum = prevnonblank(a:lnum-1)
                                let curindent = a:0 ? a:1 : indent(a:lnum)
                                while           prevlnum
                                            \&&  indent(prevlnum) >=  curindent
                                            \&& getline(prevlnum) !~# '^\s*#'
                                    let prevlnum = prevnonblank(prevlnum-1)
                                endwhile
                                return prevlnum
                            endfunction
                            
    1              0.000004 function s:FindPrevLEIndentedLineMatchingRegex(lnum, regex)
                                let plilnum = s:FindPrevLessIndentedLine(a:lnum, indent(a:lnum)+1)
                                while plilnum && getline(plilnum) !~# a:regex
                                    let plilnum = s:FindPrevLessIndentedLine(plilnum)
                                endwhile
                                return plilnum
                            endfunction
                            
    1              0.000006 let s:mapkeyregex='\v^\s*%(\''%([^'']|'''')*\'''.
                                            \        '|\"%([^"\\]|\\.)*\"'.
                                            \        '|%(%(\:\ )@!.)*)\:%(\ |$)'
    1              0.000002 let s:liststartregex='\v^\s*%(\-%(\ |$))'
                            
    1              0.000001 function GetYAMLIndent(lnum)
                                if a:lnum == 1 || !prevnonblank(a:lnum-1)
                                    return 0
                                endif
                            
                                let prevlnum = prevnonblank(a:lnum-1)
                                let previndent = indent(prevlnum)
                            
                                let line = getline(a:lnum)
                                if line =~# '^\s*#' && getline(a:lnum-1) =~# '^\s*#'
                                    " Comment blocks should have identical indent
                                    return previndent
                                elseif line =~# '^\s*[\]}]'
                                    " Lines containing only closing braces should have previous indent
                                    return indent(s:FindPrevLessIndentedLine(a:lnum))
                                endif
                            
                                " Ignore comment lines when calculating indent
                                while getline(prevlnum) =~# '^\s*#'
                                    let prevlnum = prevnonblank(prevlnum-1)
                                    if !prevlnum
                                        return previndent
                                    endif
                                endwhile
                            
                                let prevline = getline(prevlnum)
                                let previndent = indent(prevlnum)
                            
                                " Any examples below assume that shiftwidth=2
                                if prevline =~# '\v[{[:]$|[:-]\ [|>][+\-]?%(\s+\#.*|\s*)$'
                                    " Mapping key:
                                    "     nested mapping: ...
                                    "
                                    " - {
                                    "     key: [
                                    "         list value
                                    "     ]
                                    " }
                                    "
                                    " - |-
                                    "     Block scalar without indentation indicator
                                    return previndent+s:shiftwidth()
                                elseif prevline =~# '\v[:-]\ [|>]%(\d+[+\-]?|[+\-]?\d+)%(\#.*|\s*)$'
                                    " - |+2
                                    "   block scalar with indentation indicator
                                    "#^^ indent+2, not indent+shiftwidth
                                    return previndent + str2nr(matchstr(prevline,
                                                \'\v([:-]\ [|>])@<=[+\-]?\d+%([+\-]?%(\s+\#.*|\s*)$)@='))
                                elseif prevline =~# '\v\"%([^"\\]|\\.)*\\$'
                                    "    "Multiline string \
                                    "     with escaped end"
                                    let qidx = match(prevline, '\v\"%([^"\\]|\\.)*\\')
                                    return virtcol([prevlnum, qidx+1])
                                elseif line =~# s:liststartregex
                                    " List line should have indent equal to previous list line unless it was 
                                    " caught by one of the previous rules
                                    return indent(s:FindPrevLEIndentedLineMatchingRegex(a:lnum,
                                                \                                       s:liststartregex))
                                elseif line =~# s:mapkeyregex
                                    " Same for line containing mapping key
                                    return indent(s:FindPrevLEIndentedLineMatchingRegex(a:lnum,
                                                \                                       s:mapkeyregex))
                                elseif prevline =~# '^\s*- '
                                    " - List with
                                    "   multiline scalar
                                    return previndent+2
                                elseif prevline =~# s:mapkeyregex
                                    " Mapping with: value
                                    "     that is multiline scalar
                                    return previndent+s:shiftwidth()
                                endif
                                return previndent
                            endfunction
                            
    1              0.000029 let &cpo = s:save_cpo

SCRIPT  /usr/local/Cellar/macvim/7.4-73/MacVim.app/Contents/Resources/vim/runtime/syntax/yaml.vim
Sourced 1 time
Total time:   0.001505
 Self time:   0.001505

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:         YAML (YAML Ain't Markup Language) 1.2
                            " Maintainer:       Nikolai Pavlov <zyx.vim@gmail.com>
                            " First author:     Nikolai Weibull <now@bitwi.se>
                            " Latest Revision:  2010-10-08
                            
    1              0.000006 if exists('b:current_syntax')
                                finish
                            endif
                            
    1              0.000012 let s:cpo_save = &cpo
    1              0.000006 set cpo&vim
                            
    1              0.000003 let s:ns_char = '\%(\%([\n\r\uFEFF \t]\)\@!\p\)'
    1              0.000002 let s:ns_word_char = '\%(\w\|-\)'
    1              0.000005 let s:ns_uri_char  = '\%(%\x\x\|'.s:ns_word_char.'\|[#/;?:@&=+$,.!~*''()\[\]]\)'
    1              0.000003 let s:ns_tag_char  = '\%(%\x\x\|'.s:ns_word_char.'\|[#/;?:@&=+$.~*''()]\)'
    1              0.000002 let s:c_ns_anchor_char = '\%(\%([\n\r\uFEFF \t,\[\]{}]\)\@!\p\)'
    1              0.000003 let s:c_indicator      = '[\-?:,\[\]{}#&*!|>''"%@`]'
    1              0.000002 let s:c_flow_indicator = '[,\[\]{}]'
                            
    1              0.000003 let s:c_verbatim_tag = '!<'.s:ns_uri_char.'\+>'
    1              0.000003 let s:c_named_tag_handle     = '!'.s:ns_word_char.'\+!'
    1              0.000002 let s:c_secondary_tag_handle = '!!'
    1              0.000002 let s:c_primary_tag_handle   = '!'
    1              0.000007 let s:c_tag_handle = '\%('.s:c_named_tag_handle.
                                        \         '\|'.s:c_secondary_tag_handle.
                                        \         '\|'.s:c_primary_tag_handle.'\)'
    1              0.000004 let s:c_ns_shorthand_tag = s:c_tag_handle . s:ns_tag_char.'\+'
    1              0.000002 let s:c_non_specific_tag = '!'
    1              0.000007 let s:c_ns_tag_property = s:c_verbatim_tag.
                                        \        '\|'.s:c_ns_shorthand_tag.
                                        \        '\|'.s:c_non_specific_tag
                            
    1              0.000003 let s:c_ns_anchor_name = s:c_ns_anchor_char.'\+'
    1              0.000006 let s:c_ns_anchor_property =  '&'.s:c_ns_anchor_name
    1              0.000003 let s:c_ns_alias_node      = '\*'.s:c_ns_anchor_name
                            
    1              0.000003 let s:ns_directive_name = s:ns_char.'\+'
                            
    1              0.000003 let s:ns_local_tag_prefix  = '!'.s:ns_uri_char.'*'
    1              0.000004 let s:ns_global_tag_prefix = s:ns_tag_char.s:ns_uri_char.'*'
    1              0.000010 let s:ns_tag_prefix = s:ns_local_tag_prefix.
                                        \    '\|'.s:ns_global_tag_prefix
                            
    1              0.000003 let s:ns_plain_safe_out = s:ns_char
    1              0.000005 let s:ns_plain_safe_in  = '\%('.s:c_flow_indicator.'\@!'.s:ns_char.'\)'
                            
    1              0.000006 let s:ns_plain_first_in  = '\%('.s:c_indicator.'\@!'.s:ns_char.'\|[?:\-]\%('.s:ns_plain_safe_in.'\)\@=\)'
    1              0.000007 let s:ns_plain_first_out = '\%('.s:c_indicator.'\@!'.s:ns_char.'\|[?:\-]\%('.s:ns_plain_safe_out.'\)\@=\)'
                            
    1              0.000006 let s:ns_plain_char_in  = '\%('.s:ns_char.'#\|:'.s:ns_plain_safe_in.'\|[:#]\@!'.s:ns_plain_safe_in.'\)'
    1              0.000007 let s:ns_plain_char_out = '\%('.s:ns_char.'#\|:'.s:ns_plain_safe_out.'\|[:#]\@!'.s:ns_plain_safe_out.'\)'
                            
    1              0.000004 let s:ns_plain_out = s:ns_plain_first_out . s:ns_plain_char_out.'*'
    1              0.000004 let s:ns_plain_in  = s:ns_plain_first_in  . s:ns_plain_char_in.'*'
                            
                            
    1              0.000025 syn keyword yamlTodo            contained TODO FIXME XXX NOTE
                            
    1              0.000017 syn region  yamlComment         display oneline start='\%\(^\|\s\)#' end='$'
                                        \                   contains=yamlTodo
                            
    1              0.000045 execute 'syn region yamlDirective oneline start='.string('^\ze%'.s:ns_directive_name.'\s\+').' '.
                                        \                            'end="$" '.
                                        \                            'contains=yamlTAGDirective,'.
                                        \                                     'yamlYAMLDirective,'.
                                        \                                     'yamlReservedDirective '.
                                        \                            'keepend'
                            
    1              0.000010 syn match yamlTAGDirective '%TAG\s\+' contained nextgroup=yamlTagHandle
    1              0.000018 execute 'syn match yamlTagHandle contained nextgroup=yamlTagPrefix '.string(s:c_tag_handle.'\s\+')
    1              0.000022 execute 'syn match yamlTagPrefix contained nextgroup=yamlComment ' . string(s:ns_tag_prefix)
                            
    1              0.000016 syn match yamlYAMLDirective '%YAML\s\+'  contained nextgroup=yamlYAMLVersion
    1              0.000006 syn match yamlYAMLVersion   '\d\+\.\d\+' contained nextgroup=yamlComment
                            
    1              0.000020 execute 'syn match yamlReservedDirective contained nextgroup=yamlComment '.
                                        \string('%\%(\%(TAG\|YAML\)\s\)\@!'.s:ns_directive_name)
                            
    1              0.000050 syn region yamlFlowString matchgroup=yamlFlowStringDelimiter start='"' skip='\\"' end='"'
                                        \ contains=yamlEscape
                                        \ nextgroup=yamlKeyValueDelimiter
    1              0.000019 syn region yamlFlowString matchgroup=yamlFlowStringDelimiter start="'" skip="''"  end="'"
                                        \ contains=yamlSingleEscape
                                        \ nextgroup=yamlKeyValueDelimiter
    1              0.000015 syn match  yamlEscape contained '\\\%([\\"abefnrtv\^0_ NLP\n]\|x\x\x\|u\x\{4}\|U\x\{8}\)'
    1              0.000004 syn match  yamlSingleEscape contained "''"
                            
    1              0.000011 syn match yamlBlockScalarHeader contained '\s\+\zs[|>]\%([+-]\=[1-9]\|[1-9]\=[+-]\)\='
                            
    1              0.000052 syn cluster yamlFlow contains=yamlFlowString,yamlFlowMapping,yamlFlowCollection
    1              0.000028 syn cluster yamlFlow      add=yamlFlowMappingKey,yamlFlowMappingMerge
    1              0.000035 syn cluster yamlFlow      add=yamlConstant,yamlPlainScalar,yamlFloat
    1              0.000030 syn cluster yamlFlow      add=yamlTimestamp,yamlInteger,yamlMappingKeyStart
    1              0.000004 syn cluster yamlFlow      add=yamlComment
    1              0.000020 syn region yamlFlowMapping    matchgroup=yamlFlowIndicator start='{' end='}' contains=@yamlFlow
    1              0.000010 syn region yamlFlowCollection matchgroup=yamlFlowIndicator start='\[' end='\]' contains=@yamlFlow
                            
    1              0.000030 execute 'syn match yamlPlainScalar /'.s:ns_plain_out.'/'
    1              0.000027 execute 'syn match yamlPlainScalar contained /'.s:ns_plain_in.'/'
                            
    1              0.000004 syn match yamlMappingKeyStart '?\ze\s'
    1              0.000003 syn match yamlMappingKeyStart '?' contained
                            
    1              0.000037 execute 'syn match yamlFlowMappingKey /'.s:ns_plain_in.'\ze\s*:/ contained '.
                                        \'nextgroup=yamlKeyValueDelimiter'
    1              0.000011 syn match yamlFlowMappingMerge /<<\ze\s*:/ contained nextgroup=yamlKeyValueDelimiter
                            
    1              0.000024 syn match yamlBlockCollectionItemStart '^\s*\zs-\%(\s\+-\)*\s' nextgroup=yamlBlockMappingKey,yamlBlockMappingMerge
                            " Use the old regexp engine, the NFA engine doesn't like all the \@ items.
    1              0.000046 execute 'syn match yamlBlockMappingKey /\%#=1^\s*\zs'.s:ns_plain_out.'\ze\s*:\%(\s\|$\)/ '.
                                        \'nextgroup=yamlKeyValueDelimiter'
    1              0.000032 execute 'syn match yamlBlockMappingKey /\%#=1\s*\zs'.s:ns_plain_out.'\ze\s*:\%(\s\|$\)/ contained '.
                                        \'nextgroup=yamlKeyValueDelimiter'
    1              0.000008 syn match yamlBlockMappingMerge /^\s*\zs<<\ze:\%(\s\|$\)/ nextgroup=yamlKeyValueDelimiter
    1              0.000010 syn match yamlBlockMappingMerge /<<\ze\s*:\%(\s\|$\)/ nextgroup=yamlKeyValueDelimiter contained
                            
    1              0.000004 syn match   yamlKeyValueDelimiter /\s*:/ contained
    1              0.000004 syn match   yamlKeyValueDelimiter /\s*:/ contained
                            
    1              0.000004 syn keyword yamlConstant true True TRUE false False FALSE
    1              0.000003 syn keyword yamlConstant null Null NULL
    1              0.000003 syn match   yamlConstant '\<\~\>'
                            
    1              0.000017 syn match   yamlTimestamp /\%([\[\]{}, \t]\@!\p\)\@<!\%(\d\{4}-\d\d\=-\d\d\=\%(\%([Tt]\|\s\+\)\%(\d\d\=\):\%(\d\d\):\%(\d\d\)\%(\.\%(\d*\)\)\=\%(\s*\%(Z\|[+-]\d\d\=\%(:\d\d\)\=\)\)\=\)\=\)\%([\[\]{}, \t]\@!\p\)\@!/
                            
    1              0.000019 syn match   yamlInteger /\%([\[\]{}, \t]\@!\p\)\@<!\%([+-]\=\%(0\%(b[0-1_]\+\|[0-7_]\+\|x[0-9a-fA-F_]\+\)\=\|\%([1-9][0-9_]*\%(:[0-5]\=\d\)\+\)\)\|[1-9][0-9_]*\)\%([\[\]{}, \t]\@!\p\)\@!/
    1              0.000023 syn match   yamlFloat   /\%([\[\]{}, \t]\@!\p\)\@<!\%([+-]\=\%(\%(\d[0-9_]*\)\.[0-9_]*\%([eE][+-]\d\+\)\=\|\.[0-9_]\+\%([eE][-+][0-9]\+\)\=\|\d[0-9_]*\%(:[0-5]\=\d\)\+\.[0-9_]*\|\.\%(inf\|Inf\|INF\)\)\|\%(\.\%(nan\|NaN\|NAN\)\)\)\%([\[\]{}, \t]\@!\p\)\@!/
                            
    1              0.000034 execute 'syn match yamlNodeTag '.string(s:c_ns_tag_property)
    1              0.000022 execute 'syn match yamlAnchor  '.string(s:c_ns_anchor_property)
    1              0.000018 execute 'syn match yamlAlias   '.string(s:c_ns_alias_node)
                            
    1              0.000009 syn match yamlDocumentStart '^---\ze\%(\s\|$\)'
    1              0.000008 syn match yamlDocumentEnd   '^\.\.\.\ze\%(\s\|$\)'
                            
    1              0.000006 hi def link yamlTodo                     Todo
    1              0.000012 hi def link yamlComment                  Comment
                            
    1              0.000005 hi def link yamlDocumentStart            PreProc
    1              0.000004 hi def link yamlDocumentEnd              PreProc
                            
    1              0.000007 hi def link yamlDirectiveName            Keyword
                            
    1              0.000002 hi def link yamlTAGDirective             yamlDirectiveName
    1              0.000005 hi def link yamlTagHandle                String
    1              0.000004 hi def link yamlTagPrefix                String
                            
    1              0.000002 hi def link yamlYAMLDirective            yamlDirectiveName
    1              0.000005 hi def link yamlReservedDirective        Error
    1              0.000004 hi def link yamlYAMLVersion              Number
                            
    1              0.000008 hi def link yamlString                   String
    1              0.000001 hi def link yamlFlowString               yamlString
    1              0.000002 hi def link yamlFlowStringDelimiter      yamlString
    1              0.000004 hi def link yamlEscape                   SpecialChar
    1              0.000005 hi def link yamlSingleEscape             SpecialChar
                            
    1              0.000005 hi def link yamlBlockCollectionItemStart Label
    1              0.000005 hi def link yamlBlockMappingKey          Identifier
    1              0.000004 hi def link yamlBlockMappingMerge        Special
                            
    1              0.000005 hi def link yamlFlowMappingKey           Identifier
    1              0.000004 hi def link yamlFlowMappingMerge         Special
                            
    1              0.000004 hi def link yamlMappingKeyStart          Special
    1              0.000005 hi def link yamlFlowIndicator            Special
    1              0.000005 hi def link yamlKeyValueDelimiter        Special
                            
    1              0.000009 hi def link yamlConstant                 Constant
                            
    1              0.000010 hi def link yamlAnchor                   Type
    1              0.000005 hi def link yamlAlias                    Type
    1              0.000004 hi def link yamlNodeTag                  Type
                            
    1              0.000004 hi def link yamlInteger                  Number
    1              0.000005 hi def link yamlFloat                    Float
    1              0.000004 hi def link yamlTimestamp                Number
                            
    1              0.000003 let b:current_syntax = "yaml"
                            
    1              0.000023 unlet s:ns_word_char s:ns_uri_char s:c_verbatim_tag s:c_named_tag_handle s:c_secondary_tag_handle s:c_primary_tag_handle s:c_tag_handle s:ns_tag_char s:c_ns_shorthand_tag s:c_non_specific_tag s:c_ns_tag_property s:c_ns_anchor_char s:c_ns_anchor_name s:c_ns_anchor_property s:c_ns_alias_node s:ns_char s:ns_directive_name s:ns_local_tag_prefix s:ns_global_tag_prefix s:ns_tag_prefix s:c_indicator s:ns_plain_safe_out s:c_flow_indicator s:ns_plain_safe_in s:ns_plain_first_in s:ns_plain_first_out s:ns_plain_char_in s:ns_plain_char_out s:ns_plain_out s:ns_plain_in
                            
    1              0.000007 let &cpo = s:cpo_save
    1              0.000001 unlet s:cpo_save
                            

SCRIPT  /Users/klangton/.yadr/vim/bundle/splitjoin.vim/ftplugin/html/splitjoin.vim
Sourced 2 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
                            if !exists('b:splitjoin_split_callbacks')
    2              0.000014   let b:splitjoin_split_callbacks = [
                                    \ 'sj#html#SplitTags',
                                    \ 'sj#html#SplitAttributes'
                                    \ ]
    2              0.000002 endif
                            
    2              0.000006 if !exists('b:splitjoin_join_callbacks')
    2              0.000010   let b:splitjoin_join_callbacks = [
                                    \ 'sj#html#JoinAttributes',
                                    \ 'sj#html#JoinTags'
                                    \ ]
    2              0.000007 endif

SCRIPT  /usr/local/Cellar/macvim/7.4-73/MacVim.app/Contents/Resources/vim/runtime/ftplugin/html.vim
Sourced 2 times
Total time:   0.000576
 Self time:   0.000576

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	html
                            " Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
                            " Last Changed: 20 Jan 2009
                            " URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin
                            
    2              0.000018 if exists("b:did_ftplugin") | finish | endif
    2              0.000007 let b:did_ftplugin = 1
                            
                            " Make sure the continuation lines below do not cause problems in
                            " compatibility mode.
    2              0.000016 let s:save_cpo = &cpo
    2              0.000016 set cpo-=C
                            
    2              0.000005 setlocal matchpairs+=<:>
    2              0.000005 setlocal commentstring=<!--%s-->
    2              0.000006 setlocal comments=s:<!--,m:\ \ \ \ ,e:-->
                            
    2              0.000008 if exists("g:ft_html_autocomment") && (g:ft_html_autocomment == 1)
                                setlocal formatoptions-=t formatoptions+=croql
                            endif
                            
                            
    2              0.000006 if exists('&omnifunc')
                                " Distinguish between HTML versions
                                " To use with other HTML versions add another
                                " elseif condition to match proper DOCTYPE
    2              0.000004     setlocal omnifunc=htmlcomplete#CompleteTags
                            
    2              0.000004     if &filetype == 'xhtml'
                                        let b:html_omni_flavor = 'xhtml10s'
                                else
    2              0.000004             let b:html_omni_flavor = 'html401t'
    2              0.000001     endif
    2              0.000003     let i = 1
    2              0.000005     let line = ""
   20              0.000042     while i < 10 && i < line("$")
   18              0.000043         let line = getline(i)
   18              0.000092         if line =~ '<!DOCTYPE.*\<DTD '
                                        break
                                    endif
   18              0.000023         let i += 1
   18              0.000013     endwhile
    2              0.000008     if line =~ '<!DOCTYPE.*\<DTD '  " doctype line found above
                                    if line =~ ' HTML 3\.2'
                                        let b:html_omni_flavor = 'html32'
                                    elseif line =~ ' XHTML 1\.1'
                                        let b:html_omni_flavor = 'xhtml11'
                                    else    " two-step detection with strict/frameset/transitional
                                        if line =~ ' XHTML 1\.0'
                                            let b:html_omni_flavor = 'xhtml10'
                                        elseif line =~ ' HTML 4\.01'
                                            let b:html_omni_flavor = 'html401'
                                        elseif line =~ ' HTML 4.0\>'
                                            let b:html_omni_flavor = 'html40'
                                        endif
                                        if line =~ '\<Transitional\>'
                                            let b:html_omni_flavor .= 't'
                                        elseif line =~ '\<Frameset\>'
                                            let b:html_omni_flavor .= 'f'
                                        else
                                            let b:html_omni_flavor .= 's'
                                        endif
                                    endif
                                endif
    2              0.000002 endif
                            
                            " HTML:  thanks to Johannes Zellner and Benji Fisher.
    2              0.000006 if exists("loaded_matchit")
    2              0.000005     let b:match_ignorecase = 1
    2              0.000014     let b:match_words = '<:>,' .
                                \ '<\@<=[ou]l\>[^>]*\%(>\|$\):<\@<=li\>:<\@<=/[ou]l>,' .
                                \ '<\@<=dl\>[^>]*\%(>\|$\):<\@<=d[td]\>:<\@<=/dl>,' .
                                \ '<\@<=\([^/][^ \t>]*\)[^>]*\%(>\|$\):<\@<=/\1>'
    2              0.000001 endif
                            
                            " Change the :browse e filter to primarily show HTML-related files.
    2              0.000009 if has("gui_win32")
                                let  b:browsefilter="HTML Files (*.html,*.htm)\t*.htm;*.html\n" .
                            		\	"JavaScript Files (*.js)\t*.js\n" .
                            		\	"Cascading StyleSheets (*.css)\t*.css\n" .
                            		\	"All Files (*.*)\t*.*\n"
                            endif
                            
                            " Undo the stuff we changed.
    2              0.000011 let b:undo_ftplugin = "setlocal commentstring< matchpairs< omnifunc< comments< formatoptions<" .
                                \	" | unlet! b:match_ignorecase b:match_skip b:match_words b:browsefilter"
                            
                            " Restore the saved compatibility options.
    2              0.000012 let &cpo = s:save_cpo
    2              0.000011 unlet s:save_cpo

SCRIPT  /usr/local/Cellar/macvim/7.4-73/MacVim.app/Contents/Resources/vim/runtime/indent/html.vim
Sourced 4 times
Total time:   0.002304
 Self time:   0.001415

count  total (s)   self (s)
                            " Vim indent script for HTML
                            " General: "{{{
                            " File:		html.vim (Vimscript #2075)
                            " Author:	Andy Wokula <anwoku@yahoo.de>
                            " Last Change:	2013 Jun 12
                            " Rev Days:     13
                            " Version:	0.9
                            " Vim Version:	Vim7
                            " Description:
                            "   Improved version of the distributed html indent script, faster on a
                            "   range of lines.
                            "
                            " Credits:
                            "	indent/html.vim (2006 Jun 05) from J. Zellner
                            "	indent/css.vim (2006 Dec 20) from N. Weibull
                            "
                            " History:
                            " 2012 Oct 21	(v0.9) added support for shiftwidth()
                            " 2011 Sep 09	(v0.8) added HTML5 tags (thx to J. Zuckerman)
                            " 2008 Apr 28	(v0.6) revised customization
                            " 2008 Mar 09	(v0.5) fixed 'indk' issue (thx to C.J. Robinson)
                            " }}}
                            
                            " Init Folklore, check user settings (2nd time ++) "{{{
    4              0.000022 if exists("b:did_indent")
                                finish
                            endif
    4              0.000011 let b:did_indent = 1
                            
    4              0.000016 setlocal indentexpr=HtmlIndent()
    4              0.000011 setlocal indentkeys=o,O,<Return>,<>>,{,},!^F
                            
    4              0.000019 let b:indent = {"lnum": -1}
    4              0.000017 let b:undo_indent = "set inde< indk<| unlet b:indent"
                            
                            " Load Once:
    4              0.000014 if exists("*HtmlIndent")
    3   0.000128   0.000019     call HtmlIndent_CheckUserSettings()
    3              0.000005     finish
                            endif
                            
                            " Patch 7.3.694
    1              0.000003 if exists('*shiftwidth')
    1              0.000006     let s:ShiftWidth = function('shiftwidth')
    1              0.000001 else
                                func! s:ShiftWidth()
                            	return &shiftwidth
                                endfunc
                            endif
                            
    1              0.000006 let s:cpo_save = &cpo
    1              0.000005 set cpo-=C
                            "}}}
                            
    1              0.000002 func! HtmlIndent_CheckUserSettings() "{{{
                                if exists("g:html_indent_inctags")
                            	call s:AddITags(split(g:html_indent_inctags, ","))
                                endif
                                if exists("g:html_indent_autotags")
                            	call s:RemoveITags(split(g:html_indent_autotags, ","))
                                endif
                            
                                let indone = {"zero": 0
                            		\,"auto": "indent(prevnonblank(v:lnum-1))"
                            		\,"inc": "b:indent.blocktagind + s:ShiftWidth()"}
                                if exists("g:html_indent_script1")
                            	let s:js1indent = get(indone, g:html_indent_script1, indone.zero)
                                endif
                                if exists("g:html_indent_style1")
                            	let s:css1indent = get(indone, g:html_indent_style1, indone.zero)
                                endif
                            endfunc "}}}
                            
                            " Init Script Vars  "{{{
    1              0.000002 let s:usestate = 1
    1              0.000002 let s:css1indent = 0
    1              0.000002 let s:js1indent = 0
                            " not to be changed:
    1              0.000002 let s:endtags = [0,0,0,0,0,0,0,0]   " some places unused
    1              0.000001 let s:newstate = {}
    1              0.000002 let s:countonly = 0
                             "}}}
    1              0.000002 func! s:AddITags(taglist) "{{{
                                for itag in a:taglist
                            	let s:indent_tags[itag] = 1
                            	let s:indent_tags['/'.itag] = -1
                                endfor
                            endfunc "}}}
    1              0.000002 func! s:AddBlockTag(tag, id, ...) "{{{
                                if !(a:id >= 2 && a:id < 2+len(s:endtags))
                            	return
                                endif
                                let s:indent_tags[a:tag] = a:id
                                if a:0 == 0
                            	let s:indent_tags['/'.a:tag] = -a:id
                            	let s:endtags[a:id-2] = "</".a:tag.">"
                                else
                            	let s:indent_tags[a:1] = -a:id
                            	let s:endtags[a:id-2] = a:1
                                endif
                            endfunc "}}}
    1              0.000002 func! s:RemoveITags(taglist) "{{{
                                " remove itags (protect blocktags from being removed)
                                for itag in a:taglist
                            	if !has_key(s:indent_tags, itag) || s:indent_tags[itag] != 1
                            	    continue
                            	endif
                            	unlet s:indent_tags[itag]
                            	if itag =~ '^\w\+$'
                            	    unlet s:indent_tags["/".itag]
                            	endif
                                endfor
                            endfunc "}}}
                            " Add Indent Tags: {{{
    1              0.000003 if !exists("s:indent_tags")
    1              0.000003     let s:indent_tags = {}
    1              0.000001 endif
                            
                            " old tags:
    1   0.000435   0.000039 call s:AddITags(['a', 'abbr', 'acronym', 'address', 'b', 'bdo', 'big',
                                \ 'blockquote', 'button', 'caption', 'center', 'cite', 'code', 'colgroup',
                                \ 'del', 'dfn', 'dir', 'div', 'dl', 'em', 'fieldset', 'font', 'form',
                                \ 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'i', 'iframe', 'ins', 'kbd',
                                \ 'label', 'legend', 'map', 'menu', 'noframes', 'noscript', 'object', 'ol',
                                \ 'optgroup', 'q', 's', 'samp', 'select', 'small', 'span', 'strong', 'sub',
                                \ 'sup', 'table', 'textarea', 'title', 'tt', 'u', 'ul', 'var', 'th', 'td',
                                \ 'tr', 'tfoot', 'thead'])
                            
                            " tags added 2011 Sep 09 (especially HTML5 tags):
    1   0.000263   0.000021 call s:AddITags(['area', 'article', 'aside', 'audio', 'bdi', 'canvas',
                                \ 'command', 'datalist', 'details', 'embed', 'figure', 'footer',
                                \ 'header', 'group', 'keygen', 'mark', 'math', 'meter', 'nav', 'output',
                                \ 'progress', 'ruby', 'section', 'svg', 'texture', 'time', 'video',
                                \ 'wbr', 'text'])
                            
                            "}}}
                            " Add Block Tags: contain alien content "{{{
    1   0.000039   0.000008 call s:AddBlockTag('pre', 2)
    1   0.000031   0.000004 call s:AddBlockTag('script', 3)
    1   0.000031   0.000005 call s:AddBlockTag('style', 4)
    1   0.000030   0.000005 call s:AddBlockTag('<!--', 5, '-->')
                            "}}}
                            
    1              0.000002 func! s:CountITags(...) "{{{
                            
                                " relative indent steps for current line [unit &sw]:
                                let s:curind = 0
                                " relative indent steps for next line [unit &sw]:
                                let s:nextrel = 0
                            
                                if a:0==0
                            	let s:block = s:newstate.block
                            	let tmpline = substitute(s:curline, '<\zs\/\=\w\+\>\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
                            	if s:block == 3
                            	    let s:newstate.scripttype = s:GetScriptType(matchstr(tmpline, '\C.*<SCRIPT\>\zs[^>]*'))
                            	endif
                            	let s:newstate.block = s:block
                                else
                            	let s:block = 0		" assume starting outside of a block
                            	let s:countonly = 1	" don't change state
                            	let tmpline = substitute(s:altline, '<\zs\/\=\w\+\>\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
                            	let s:countonly = 0
                                endif
                            endfunc "}}}
    1              0.000009 func! s:CheckTag(itag) "{{{
                                " "tag" or "/tag" or "<!--" or "-->"
                                let ind = get(s:indent_tags, a:itag)
                                if ind == -1
                            	" closing tag
                            	if s:block != 0
                            	    " ignore itag within a block
                            	    return "foo"
                            	endif
                            	if s:nextrel == 0
                            	    let s:curind -= 1
                            	else
                            	    let s:nextrel -= 1
                            	endif
                            	" if s:curind >= 1
                            	"     let s:curind -= 1
                            	" else
                            	"     let s:nextrel -= 1
                            	" endif
                                elseif ind == 1
                            	" opening tag
                            	if s:block != 0
                            	    return "foo"
                            	endif
                            	let s:nextrel += 1
                                elseif ind != 0
                            	" block-tag (opening or closing)
                            	return s:Blocktag(a:itag, ind)
                                endif
                                " else ind==0 (other tag found): keep indent
                                return "foo"   " no matter
                            endfunc "}}}
    1              0.000002 func! s:Blocktag(blocktag, ind) "{{{
                                if a:ind > 0
                            	" a block starts here
                            	if s:block != 0
                            	    " already in a block (nesting) - ignore
                            	    " especially ignore comments after other blocktags
                            	    return "foo"
                            	endif
                            	let s:block = a:ind		" block type
                            	if s:countonly
                            	    return "foo"
                            	endif
                            	let s:newstate.blocklnr = v:lnum
                            	" save allover indent for the endtag
                            	let s:newstate.blocktagind = b:indent.baseindent + (s:nextrel + s:curind) * s:ShiftWidth()
                            	if a:ind == 3
                            	    return "SCRIPT"    " all except this must be lowercase
                            	    " line is to be checked again for the type attribute
                            	endif
                                else
                            	let s:block = 0
                            	" we get here if starting and closing block-tag on same line
                                endif
                                return "foo"
                            endfunc "}}}
    1              0.000003 func! s:GetScriptType(str) "{{{
                                if a:str == "" || a:str =~ "java"
                            	return "javascript"
                                else
                            	return ""
                                endif
                            endfunc "}}}
                            
    1              0.000002 func! s:FreshState(lnum) "{{{
                                " Look back in the file (lines 1 to a:lnum-1) to calc a state for line
                                " a:lnum.  A state is to know ALL relevant details about the lines
                                " 1..a:lnum-1, initial calculating (here!) can be slow, but updating is
                                " fast (incremental).
                                " State:
                                "	lnum		last indented line == prevnonblank(a:lnum - 1)
                                "	block = 0	a:lnum located within special tag: 0:none, 2:<pre>,
                                "			3:<script>, 4:<style>, 5:<!--
                                "	baseindent	use this indent for line a:lnum as a start - kind of
                                "			autoindent (if block==0)
                                "	scripttype = ''	type attribute of a script tag (if block==3)
                                "	blocktagind	indent for current opening (get) and closing (set)
                                "			blocktag (if block!=0)
                                "	blocklnr	lnum of starting blocktag (if block!=0)
                                "	inattr		line {lnum} starts with attributes of a tag
                                let state = {}
                                let state.lnum = prevnonblank(a:lnum - 1)
                                let state.scripttype = ""
                                let state.blocktagind = -1
                                let state.block = 0
                                let state.baseindent = 0
                                let state.blocklnr = 0
                                let state.inattr = 0
                            
                                if state.lnum == 0
                            	return state
                                endif
                            
                                " Heuristic:
                                " remember startline state.lnum
                                " look back for <pre, </pre, <script, </script, <style, </style tags
                                " remember stopline
                                " if opening tag found,
                                "	assume a:lnum within block
                                " else
                                "	look back in result range (stopline, startline) for comment
                                "	    \ delimiters (<!--, -->)
                                "	if comment opener found,
                                "	    assume a:lnum within comment
                                "	else
                                "	    assume usual html for a:lnum
                                "	    if a:lnum-1 has a closing comment
                                "		look back to get indent of comment opener
                                " FI
                            
                                " look back for blocktag
                                call cursor(a:lnum, 1)
                                let [stopline, stopcol] = searchpos('\c<\zs\/\=\%(pre\>\|script\>\|style\>\)', "bW")
                                " fugly ... why isn't there searchstr()
                                let tagline = tolower(getline(stopline))
                                let blocktag = matchstr(tagline, '\/\=\%(pre\>\|script\>\|style\>\)', stopcol-1)
                                if stopline > 0 && blocktag[0] != "/"
                            	" opening tag found, assume a:lnum within block
                            	let state.block = s:indent_tags[blocktag]
                            	if state.block == 3
                            	    let state.scripttype = s:GetScriptType(matchstr(tagline, '\>[^>]*', stopcol))
                            	endif
                            	let state.blocklnr = stopline
                            	" check preceding tags in the line:
                            	let s:altline = tagline[: stopcol-2]
                            	call s:CountITags(1)
                            	let state.blocktagind = indent(stopline) + (s:curind + s:nextrel) * s:ShiftWidth()
                            	return state
                                elseif stopline == state.lnum
                            	" handle special case: previous line (= state.lnum) contains a
                            	" closing blocktag which is preceded by line-noise;
                            	" blocktag == "/..."
                            	let swendtag = match(tagline, '^\s*</') >= 0
                            	if !swendtag
                            	    let [bline, bcol] = searchpos('<'.blocktag[1:].'\>', "bW")
                            	    let s:altline = tolower(getline(bline)[: bcol-2])
                            	    call s:CountITags(1)
                            	    let state.baseindent = indent(bline) + (s:nextrel+s:curline) * s:ShiftWidth()
                            	    return state
                            	endif
                                endif
                            
                                " else look back for comment
                                call cursor(a:lnum, 1)
                                let [comline, comcol, found] = searchpos('\(<!--\)\|-->', 'bpW', stopline)
                                if found == 2
                            	" comment opener found, assume a:lnum within comment
                            	let state.block = 5
                            	let state.blocklnr = comline
                            	" check preceding tags in the line:
                            	let s:altline = tolower(getline(comline)[: comcol-2])
                            	call s:CountITags(1)
                            	let state.blocktagind = indent(comline) + (s:curind + s:nextrel) * s:ShiftWidth()
                            	return state
                                endif
                            
                                " else within usual html
                                let s:altline = tolower(getline(state.lnum))
                                " check a:lnum-1 for closing comment (we need indent from the opening line)
                                let comcol = stridx(s:altline, '-->')
                                if comcol >= 0
                            	call cursor(state.lnum, comcol+1)
                            	let [comline, comcol] = searchpos('<!--', 'bW')
                            	if comline == state.lnum
                            	    let s:altline = s:altline[: comcol-2]
                            	else
                            	    let s:altline = tolower(getline(comline)[: comcol-2])
                            	endif
                            	call s:CountITags(1)
                            	let state.baseindent = indent(comline) + (s:nextrel+s:curline) * s:ShiftWidth()
                            	return state
                            	" TODO check tags that follow "-->"
                                endif
                            
                                " else no comments
                                call s:CountITags(1)
                                let state.baseindent = indent(state.lnum) + s:nextrel * s:ShiftWidth()
                                " line starts with end tag
                                let swendtag = match(s:altline, '^\s*</') >= 0
                                if !swendtag
                            	let state.baseindent += s:curind * s:ShiftWidth()
                                endif
                                return state
                            endfunc "}}}
                            
    1              0.000003 func! s:Alien2() "{{{
                                " <pre> block
                                return -1
                            endfunc "}}}
    1              0.000002 func! s:Alien3() "{{{
                                " <script> javascript
                                if prevnonblank(v:lnum-1) == b:indent.blocklnr
                            	" indent for the first line after <script>
                            	return eval(s:js1indent)
                                endif
                                if b:indent.scripttype == "javascript"
                            	return cindent(v:lnum)
                                else
                            	return -1
                                endif
                            endfunc "}}}
    1              0.000001 func! s:Alien4() "{{{
                                " <style>
                                if prevnonblank(v:lnum-1) == b:indent.blocklnr
                            	" indent for first content line
                            	return eval(s:css1indent)
                                endif
                                return s:CSSIndent()
                            endfunc
                            
    1              0.000002 func! s:CSSIndent() "{{{
                                " adopted $VIMRUNTIME/indent/css.vim
                                if getline(v:lnum) =~ '^\s*[*}]'
                            	return cindent(v:lnum)
                                endif
                                let minline = b:indent.blocklnr
                                let pnum = s:css_prevnoncomment(v:lnum - 1, minline)
                                if pnum <= minline
                            	" < is to catch errors
                            	" indent for first content line after comments
                            	return eval(s:css1indent)
                                endif
                                let ind = indent(pnum) + s:css_countbraces(pnum, 1) * s:ShiftWidth()
                                let pline = getline(pnum)
                                if pline =~ '}\s*$'
                            	let ind -= (s:css_countbraces(pnum, 0) - (pline =~ '^\s*}')) * s:ShiftWidth()
                                endif
                                return ind
                            endfunc "}}}
    1              0.000003 func! s:css_prevnoncomment(lnum, stopline) "{{{
                                " caller starts from a line a:lnum-1 that is not a comment
                                let lnum = prevnonblank(a:lnum)
                                let ccol = match(getline(lnum), '\*/')
                                if ccol < 0
                            	return lnum
                                endif
                                call cursor(lnum, ccol+1)
                                let lnum = search('/\*', 'bW', a:stopline)
                                if indent(".") == virtcol(".")-1
                            	return prevnonblank(lnum-1)
                                else
                            	return lnum
                                endif
                            endfunc "}}}
    1              0.000008 func! s:css_countbraces(lnum, count_open) "{{{
                                let brs = substitute(getline(a:lnum),'[''"].\{-}[''"]\|/\*.\{-}\*/\|/\*.*$\|[^{}]','','g')
                                let n_open = 0
                                let n_close = 0
                                for brace in split(brs, '\zs')
                            	if brace == "{"
                            	    let n_open += 1
                            	elseif brace == "}"
                            	    if n_open > 0
                            		let n_open -= 1
                            	    else
                            		let n_close += 1
                            	    endif
                            	endif
                                endfor
                                return a:count_open ? n_open : n_close
                            endfunc "}}}
                            
                            "}}}
    1              0.000004 func! s:Alien5() "{{{
                                " <!-- -->
                                return -1
                            endfunc "}}}
                            
    1              0.000003 func! HtmlIndent() "{{{
                                let s:curline = tolower(getline(v:lnum))
                                let indentunit = s:ShiftWidth()
                            
                                let s:newstate = {}
                                let s:newstate.lnum = v:lnum
                            
                                " does the line start with a closing tag?
                                let swendtag = match(s:curline, '^\s*</') >= 0
                            
                                if prevnonblank(v:lnum-1) == b:indent.lnum && s:usestate
                            	" use state (continue from previous line)
                                else
                            	" start over (know nothing)
                            	let b:indent = s:FreshState(v:lnum)
                                endif
                            
                                if b:indent.block >= 2
                            	" within block
                            	let endtag = s:endtags[b:indent.block-2]
                            	let blockend = stridx(s:curline, endtag)
                            	if blockend >= 0
                            	    " block ends here
                            	    let s:newstate.block = 0
                            	    " calc indent for REST OF LINE (may start more blocks):
                            	    let s:curline = strpart(s:curline, blockend+strlen(endtag))
                            	    call s:CountITags()
                            	    if swendtag && b:indent.block != 5
                            		let indent = b:indent.blocktagind + s:curind * indentunit
                            		let s:newstate.baseindent = indent + s:nextrel * indentunit
                            	    else
                            		let indent = s:Alien{b:indent.block}()
                            		let s:newstate.baseindent = b:indent.blocktagind + s:nextrel * indentunit
                            	    endif
                            	    call extend(b:indent, s:newstate, "force")
                            	    return indent
                            	else
                            	    " block continues
                            	    " indent this line with alien method
                            	    let indent = s:Alien{b:indent.block}()
                            	    call extend(b:indent, s:newstate, "force")
                            	    return indent
                            	endif
                                else
                            	" not within a block - within usual html
                            	" if < 2 then always 0
                            	let s:newstate.block = b:indent.block
                            	call s:CountITags()
                            	if swendtag
                            	    let indent = b:indent.baseindent + s:curind * indentunit
                            	    let s:newstate.baseindent = indent + s:nextrel * indentunit
                            	else
                            	    let indent = b:indent.baseindent
                            	    let s:newstate.baseindent = indent + (s:curind + s:nextrel) * indentunit
                            	endif
                            	call extend(b:indent, s:newstate, "force")
                            	return indent
                                endif
                            
                            endfunc "}}}
                            
                            " check user settings (first time), clear cpo, Modeline: {{{1
                            
                            " DEBUG:
    1              0.000011 com! -nargs=* IndHtmlLocal <args>
                            
    1   0.000043   0.000010 call HtmlIndent_CheckUserSettings()
                            
    1              0.000007 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
                            " vim:set fdm=marker ts=8:

SCRIPT  /Users/klangton/.yadr/vim/bundle/vim-coffee-script/after/indent/html.vim
Sourced 2 times
Total time:   0.003690
 Self time:   0.002378

count  total (s)   self (s)
                            " Language:    CoffeeScript
                            " Maintainer:  Mick Koch <mick@kochm.co>
                            " URL:         http://github.com/kchmck/vim-coffee-script
                            " License:     WTFPL
                            
                            " Load the coffee and html indent functions.
    2              0.000007 silent! unlet b:did_indent
    2              0.000816 runtime indent/coffee.vim
    2              0.000009 let s:coffeeIndentExpr = &l:indentexpr
                            
                            " Load html last so it can overwrite coffee settings.
    2              0.000007 silent! unlet b:did_indent
    2              0.001038 runtime indent/html.vim
    2              0.000007 let s:htmlIndentExpr = &l:indentexpr
                            
                            " Inject our wrapper indent function.
    2              0.000007 setlocal indentexpr=GetCoffeeHtmlIndent(v:lnum)
                            
    2              0.000006 function! GetCoffeeHtmlIndent(curlinenum)
                              " See if we're inside a coffeescript block.
                              let scriptlnum = searchpair('<script [^>]*type="text/coffeescript"[^>]*>', '',
                              \                           '</script>', 'bWn')
                              let prevlnum = prevnonblank(a:curlinenum)
                            
                              " If we're in the script block and the previous line isn't the script tag
                              " itself, use coffee indenting.
                              if scriptlnum && scriptlnum != prevlnum
                                exec 'return ' s:coffeeIndentExpr
                              endif
                            
                              " Otherwise use html indenting.
                              exec 'return ' s:htmlIndentExpr
                            endfunction

SCRIPT  /Users/klangton/.yadr/vim/bundle/vim-coffee-script/indent/coffee.vim
Sourced 3 times
Total time:   0.000964
 Self time:   0.000964

count  total (s)   self (s)
                            " Language:    CoffeeScript
                            " Maintainer:  Mick Koch <mick@kochm.co>
                            " URL:         http://github.com/kchmck/vim-coffee-script
                            " License:     WTFPL
                            
    3              0.000016 if exists('b:did_indent')
                              finish
                            endif
                            
    3              0.000008 let b:did_indent = 1
                            
    3              0.000012 setlocal autoindent
    3              0.000009 setlocal indentexpr=GetCoffeeIndent(v:lnum)
                            " Make sure GetCoffeeIndent is run when these are typed so they can be
                            " indented or outdented.
    3              0.000007 setlocal indentkeys+=0],0),0.,=else,=when,=catch,=finally
                            
                            " If no indenting or outdenting is needed, either keep the indent of the cursor
                            " (use autoindent) or match the indent of the previous line.
    3              0.000011 if exists('g:coffee_indent_keep_current')
                              let s:DEFAULT_LEVEL = '-1'
                            else
    3              0.000009   let s:DEFAULT_LEVEL = 'indent(prevnlnum)'
    3              0.000003 endif
                            
                            " Only define the function once.
    3              0.000009 if exists('*GetCoffeeIndent')
    2              0.000002   finish
                            endif
                            
                            " Keywords that begin a block
    1              0.000007 let s:BEGIN_BLOCK_KEYWORD = '\C^\%(if\|unless\|else\|for\|while\|until\|'
                            \                         . 'loop\|switch\|when\|try\|catch\|finally\|'
                            \                         . 'class\)\>\%(\s*:\)\@!'
                            
                            " An expression that uses the result of a statement
    1              0.000006 let s:COMPOUND_EXPRESSION = '\C\%([^-]-\|[^+]+\|[^/]/\|[:=*%&|^<>]\)\s*'
                            \                         . '\%(if\|unless\|for\|while\|until\|loop\|switch\|'
                            \                         . 'try\|class\)\>'
                            
                            " Combine the two above
    1              0.000004 let s:BEGIN_BLOCK = s:BEGIN_BLOCK_KEYWORD . '\|' . s:COMPOUND_EXPRESSION
                            
                            " Operators that begin a block but also count as a continuation
    1              0.000002 let s:BEGIN_BLOCK_OP = '[([{:=]$'
                            
                            " Begins a function block
    1              0.000001 let s:FUNCTION = '[-=]>$'
                            
                            " Operators that continue a line onto the next line
    1              0.000004 let s:CONTINUATION_OP = '\C\%(\<\%(is\|isnt\|and\|or\)\>\|'
                            \                     . '[^-]-\|[^+]+\|[^-=]>\|[^.]\.\|[<*/%&|^,]\)$'
                            
                            " Ancestor operators that prevent continuation indenting
    1              0.000004 let s:CONTINUATION = s:CONTINUATION_OP . '\|' . s:BEGIN_BLOCK_OP
                            
                            " A closing bracket by itself on a line followed by a continuation
    1              0.000003 let s:BRACKET_CONTINUATION = '^\s*[}\])]\s*' . s:CONTINUATION_OP
                            
                            " A continuation dot access
    1              0.000002 let s:DOT_ACCESS = '^\.'
                            
                            " Keywords that break out of a block
    1              0.000003 let s:BREAK_BLOCK_OP = '\C^\%(return\|break\|continue\|throw\)\>'
                            
                            " A condition attached to the end of a statement
    1              0.000003 let s:POSTFIX_CONDITION = '\C\S\s\+\zs\<\%(if\|unless\|when\|while\|until\)\>'
                            
                            " A then contained in brackets
    1              0.000003 let s:CONTAINED_THEN = '\C[(\[].\{-}\<then\>.\{-\}[)\]]'
                            
                            " An else with a condition attached
    1              0.000002 let s:ELSE_COND = '\C^\s*else\s\+\<\%(if\|unless\)\>'
                            
                            " A single-line else statement (without a condition attached)
    1              0.000003 let s:SINGLE_LINE_ELSE = '\C^else\s\+\%(\<\%(if\|unless\)\>\)\@!'
                            
                            " Pairs of starting and ending keywords, with an initial pattern to match
    1              0.000009 let s:KEYWORD_PAIRS = [
                            \  ['\C^else\>', '\C\<\%(if\|unless\|when\|else\s\+\%(if\|unless\)\)\>',
                            \   '\C\<else\>'],
                            \  ['\C^catch\>', '\C\<try\>', '\C\<catch\>'],
                            \  ['\C^finally\>', '\C\<try\>', '\C\<finally\>']
                            \]
                            
                            " Pairs of starting and ending brackets
    1              0.000004 let s:BRACKET_PAIRS = {']': '\[', '}': '{', ')': '('}
                            
                            " Max lines to look back for a match
    1              0.000002 let s:MAX_LOOKBACK = 50
                            
                            " Syntax names for strings
    1              0.000004 let s:SYNTAX_STRING = 'coffee\%(String\|AssignString\|Embed\|Regex\|Heregex\|'
                            \                   . 'Heredoc\)'
                            
                            " Syntax names for comments
    1              0.000003 let s:SYNTAX_COMMENT = 'coffee\%(Comment\|BlockComment\|HeregexComment\)'
                            
                            " Syntax names for strings and comments
    1              0.000004 let s:SYNTAX_STRING_COMMENT = s:SYNTAX_STRING . '\|' . s:SYNTAX_COMMENT
                            
                            " Compatibility code for shiftwidth() as recommended by the docs, but modified
                            " so there isn't as much of a penalty if shiftwidth() exists.
    1              0.000004 if exists('*shiftwidth')
    1              0.000006   let s:ShiftWidth = function('shiftwidth')
    1              0.000001 else
                              function! s:ShiftWidth()
                                return &shiftwidth
                              endfunction
                            endif
                            
                            " Get the linked syntax name of a character.
    1              0.000003 function! s:SyntaxName(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name')
                            endfunction
                            
                            " Check if a character is in a comment.
    1              0.000002 function! s:IsComment(lnum, col)
                              return s:SyntaxName(a:lnum, a:col) =~ s:SYNTAX_COMMENT
                            endfunction
                            
                            " Check if a character is in a string.
    1              0.000002 function! s:IsString(lnum, col)
                              return s:SyntaxName(a:lnum, a:col) =~ s:SYNTAX_STRING
                            endfunction
                            
                            " Check if a character is in a comment or string.
    1              0.000016 function! s:IsCommentOrString(lnum, col)
                              return s:SyntaxName(a:lnum, a:col) =~ s:SYNTAX_STRING_COMMENT
                            endfunction
                            
                            " Search a line for a regex until one is found outside a string or comment.
    1              0.000005 function! s:SearchCode(lnum, regex)
                              " Start at the first column and look for an initial match (including at the
                              " cursor.)
                              call cursor(a:lnum, 1)
                              let pos = search(a:regex, 'c', a:lnum)
                            
                              while pos
                                if !s:IsCommentOrString(a:lnum, col('.'))
                                  return 1
                                endif
                            
                                " Move to the match and continue searching (don't accept matches at the
                                " cursor.)
                                let pos = search(a:regex, '', a:lnum)
                              endwhile
                            
                              return 0
                            endfunction
                            
                            " Search for the nearest previous line that isn't a comment.
    1              0.000005 function! s:GetPrevNormalLine(startlnum)
                              let curlnum = a:startlnum
                            
                              while curlnum
                                let curlnum = prevnonblank(curlnum - 1)
                            
                                " Return the line if the first non-whitespace character isn't a comment.
                                if !s:IsComment(curlnum, indent(curlnum) + 1)
                                  return curlnum
                                endif
                              endwhile
                            
                              return 0
                            endfunction
                            
    1              0.000007 function! s:SearchPair(startlnum, lookback, skip, open, close)
                              " Go to the first column so a:close will be matched even if it's at the
                              " beginning of the line.
                              call cursor(a:startlnum, 1)
                              return searchpair(a:open, '', a:close, 'bnW', a:skip, max([1, a:lookback]))
                            endfunction
                            
                            " Skip if a match
                            "  - is in a string or comment
                            "  - is a single-line statement that isn't immediately
                            "    adjacent
                            "  - has a postfix condition and isn't an else statement or compound
                            "    expression
    1              0.000003 function! s:ShouldSkip(startlnum, lnum, col)
                              return s:IsCommentOrString(a:lnum, a:col) ||
                              \      s:SearchCode(a:lnum, '\C\<then\>') && a:startlnum - a:lnum > 1 ||
                              \      s:SearchCode(a:lnum, s:POSTFIX_CONDITION) &&
                              \      getline(a:lnum) !~ s:ELSE_COND &&
                              \     !s:SearchCode(a:lnum, s:COMPOUND_EXPRESSION)
                            endfunction
                            
                            " Search for the nearest and farthest match for a keyword pair.
    1              0.000003 function! s:SearchMatchingKeyword(startlnum, open, close)
                              let skip = 's:ShouldSkip(' . a:startlnum . ", line('.'), line('.'))"
                            
                              " Search for the nearest match.
                              let nearestlnum = s:SearchPair(a:startlnum, a:startlnum - s:MAX_LOOKBACK,
                              \                              skip, a:open, a:close)
                            
                              if !nearestlnum
                                return []
                              endif
                            
                              " Find the nearest previous line with indent less than or equal to startlnum.
                              let ind = indent(a:startlnum)
                              let lookback = s:GetPrevNormalLine(a:startlnum)
                            
                              while lookback && indent(lookback) > ind
                                let lookback = s:GetPrevNormalLine(lookback)
                              endwhile
                            
                              " Search for the farthest match. If there are no other matches, then the
                              " nearest match is also the farthest one.
                              let matchlnum = nearestlnum
                            
                              while matchlnum
                                let lnum = matchlnum
                                let matchlnum = s:SearchPair(matchlnum, lookback, skip, a:open, a:close)
                              endwhile
                            
                              return [nearestlnum, lnum]
                            endfunction
                            
                            " Strip a line of a trailing comment and surrounding whitespace.
    1              0.000002 function! s:GetTrimmedLine(lnum)
                              " Try to find a comment starting at the first column.
                              call cursor(a:lnum, 1)
                              let pos = search('#', 'c', a:lnum)
                            
                              " Keep searching until a comment is found or search returns 0.
                              while pos
                                if s:IsComment(a:lnum, col('.'))
                                  break
                                endif
                            
                                let pos = search('#', '', a:lnum)
                              endwhile
                            
                              if !pos
                                " No comment was found so use the whole line.
                                let line = getline(a:lnum)
                              else
                                " Subtract 1 to get to the column before the comment and another 1 for
                                " column indexing -> zero-based indexing.
                                let line = getline(a:lnum)[:col('.') - 2]
                              endif
                            
                              return substitute(substitute(line, '^\s\+', '', ''),
                              \                                  '\s\+$', '', '')
                            endfunction
                            
                            " Get the indent policy when no special rules are used.
    1              0.000002 function! s:GetDefaultPolicy(curlnum)
                              " Check whether equalprg is being ran on existing lines.
                              if strlen(getline(a:curlnum)) == indent(a:curlnum)
                                " If not indenting an existing line, use the default policy.
                                return s:DEFAULT_LEVEL
                              else
                                " Otherwise let autoindent determine what to do with an existing line.
                                return '-1'
                              endif
                            endfunction
                            
    1              0.000004 function! GetCoffeeIndent(curlnum)
                              " Get the previous non-blank line (may be a comment.)
                              let prevlnum = prevnonblank(a:curlnum - 1)
                            
                              " Bail if there's no code before.
                              if !prevlnum
                                return -1
                              endif
                            
                              " Bail if inside a multiline string.
                              if s:IsString(a:curlnum, 1)
                                let prevnlnum = prevlnum
                                exec 'return' s:GetDefaultPolicy(a:curlnum)
                              endif
                            
                              " Get the code part of the current line.
                              let curline = s:GetTrimmedLine(a:curlnum)
                              " Get the previous non-comment line.
                              let prevnlnum = s:GetPrevNormalLine(a:curlnum)
                            
                              " Check if the current line is the closing bracket in a bracket pair.
                              if has_key(s:BRACKET_PAIRS, curline[0])
                                " Search for a matching opening bracket.
                                let matchlnum = s:SearchPair(a:curlnum, a:curlnum - s:MAX_LOOKBACK,
                                \                            "s:IsCommentOrString(line('.'), col('.'))",
                                \                            s:BRACKET_PAIRS[curline[0]], curline[0])
                            
                                if matchlnum
                                  " Match the indent of the opening bracket.
                                  return indent(matchlnum)
                                else
                                  " No opening bracket found (bad syntax), so bail.
                                  exec 'return' s:GetDefaultPolicy(a:curlnum)
                                endif
                              endif
                            
                              " Check if the current line is the closing keyword in a keyword pair.
                              for pair in s:KEYWORD_PAIRS
                                if curline =~ pair[0]
                                  " Find the nearest and farthest matches within the same indent level.
                                  let matches = s:SearchMatchingKeyword(a:curlnum, pair[1], pair[2])
                            
                                  if len(matches)
                                    " Don't force indenting/outdenting as long as line is already lined up
                                    " with a valid match
                                    return max([min([indent(a:curlnum), indent(matches[0])]),
                                    \           indent(matches[1])])
                                  else
                                    " No starting keyword found (bad syntax), so bail.
                                    exec 'return' s:GetDefaultPolicy(a:curlnum)
                                  endif
                                endif
                              endfor
                            
                              " Check if the current line is a `when` and not the first in a switch block.
                              if curline =~ '\C^when\>' && !s:SearchCode(prevnlnum, '\C\<switch\>')
                                " Look back for a `when`.
                                while prevnlnum
                                  if getline(prevnlnum) =~ '\C^\s*when\>'
                                    " Indent to match the found `when`, but don't force indenting (for when
                                    " indenting nested switch blocks.)
                                    return min([indent(a:curlnum), indent(prevnlnum)])
                                  endif
                            
                                  let prevnlnum = s:GetPrevNormalLine(prevnlnum)
                                endwhile
                            
                                " No matching `when` found (bad syntax), so bail.
                                exec 'return' s:GetDefaultPolicy(a:curlnum)
                              endif
                            
                              " If the previous line is a comment, use its indentation, but don't force
                              " indenting.
                              if prevlnum != prevnlnum
                                return min([indent(a:curlnum), indent(prevlnum)])
                              endif
                            
                              let prevline = s:GetTrimmedLine(prevnlnum)
                            
                              " Always indent after these operators.
                              if prevline =~ s:BEGIN_BLOCK_OP
                                return indent(prevnlnum) + s:ShiftWidth()
                              endif
                            
                              " Indent if the previous line starts a function block, but don't force
                              " indenting if the line is non-blank (for empty function bodies.)
                              if prevline =~ s:FUNCTION
                                if strlen(getline(a:curlnum)) > indent(a:curlnum)
                                  return min([indent(prevnlnum) + s:ShiftWidth(), indent(a:curlnum)])
                                else
                                  return indent(prevnlnum) + s:ShiftWidth()
                                endif
                              endif
                            
                              " Check if continuation indenting is needed. If the line ends in a slash, make
                              " sure it isn't a regex.
                              if prevline =~ s:CONTINUATION_OP &&
                              \  !(prevline =~ '/$' && s:IsString(prevnlnum, col([prevnlnum, '$']) - 1))
                                " Don't indent if the continuation follows a closing bracket.
                                if prevline =~ s:BRACKET_CONTINUATION
                                  exec 'return' s:GetDefaultPolicy(a:curlnum)
                                endif
                            
                                let prevprevnlnum = s:GetPrevNormalLine(prevnlnum)
                            
                                " Don't indent if not the first continuation.
                                if prevprevnlnum && s:GetTrimmedLine(prevprevnlnum) =~ s:CONTINUATION
                                  exec 'return' s:GetDefaultPolicy(a:curlnum)
                                endif
                            
                                " Continuation indenting seems to vary between programmers, so if the line
                                " is non-blank, don't override the indentation
                                if strlen(getline(a:curlnum)) > indent(a:curlnum)
                                  exec 'return' s:GetDefaultPolicy(a:curlnum)
                                endif
                            
                                " Otherwise indent a level.
                                return indent(prevnlnum) + s:ShiftWidth()
                              endif
                            
                              " Check if the previous line starts with a keyword that begins a block.
                              if prevline =~ s:BEGIN_BLOCK
                                " Indent if the current line doesn't start with `then` and the previous line
                                " isn't a single-line statement.
                                if curline !~ '\C^\<then\>' && !s:SearchCode(prevnlnum, '\C\<then\>') &&
                                \  prevline !~ s:SINGLE_LINE_ELSE
                                  return indent(prevnlnum) + s:ShiftWidth()
                                else
                                  exec 'return' s:GetDefaultPolicy(a:curlnum)
                                endif
                              endif
                            
                              " Indent a dot access if it's the first.
                              if curline =~ s:DOT_ACCESS
                                if prevline !~ s:DOT_ACCESS
                                  return indent(prevnlnum) + s:ShiftWidth()
                                else
                                  exec 'return' s:GetDefaultPolicy(a:curlnum)
                                endif
                              endif
                            
                              " Outdent if a keyword breaks out of a block as long as it doesn't have a
                              " postfix condition (and the postfix condition isn't a single-line statement.)
                              if prevline =~ s:BREAK_BLOCK_OP
                                if !s:SearchCode(prevnlnum, s:POSTFIX_CONDITION) ||
                                \   s:SearchCode(prevnlnum, '\C\<then\>') &&
                                \  !s:SearchCode(prevnlnum, s:CONTAINED_THEN)
                                  " Don't force indenting.
                                  return min([indent(a:curlnum), indent(prevnlnum) - s:ShiftWidth()])
                                else
                                  exec 'return' s:GetDefaultPolicy(a:curlnum)
                                endif
                              endif
                            
                              " Check if inside brackets.
                              let matchlnum = s:SearchPair(a:curlnum, a:curlnum - s:MAX_LOOKBACK,
                              \                            "s:IsCommentOrString(line('.'), col('.'))",
                              \                            '\[\|(\|{', '\]\|)\|}')
                            
                              " If inside brackets, indent relative to the brackets, but don't outdent an
                              " already indented line.
                              if matchlnum
                                return max([indent(a:curlnum), indent(matchlnum) + s:ShiftWidth()])
                              endif
                            
                              " No special rules applied, so use the default policy.
                              exec 'return' s:GetDefaultPolicy(a:curlnum)
                            endfunction

SCRIPT  /usr/local/Cellar/macvim/7.4-73/MacVim.app/Contents/Resources/vim/runtime/syntax/html.vim
Sourced 3 times
Total time:  10.001068
 Self time:   0.045694

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	HTML
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " URL:		http://www.fleiner.com/vim/syntax/html.vim
                            " Last Change:	2012 Oct 05
                            
                            " Please check :help html.vim for some comments and a description of the options
                            
                            " For version 5.x: Clear all syntax items
                            " For version 6.x: Quit when a syntax file was already loaded
    3              0.000017 if !exists("main_syntax")
    2              0.000004   if version < 600
                                syntax clear
                              elseif exists("b:current_syntax")
                                finish
                              endif
    2              0.000006   let main_syntax = 'html'
    2              0.000002 endif
                            
    3              0.000019 let s:cpo_save = &cpo
    3              0.000018 set cpo&vim
                            
                            " don't use standard HiLink, it will not work with included syntax files
    3              0.000005 if version < 508
                              command! -nargs=+ HtmlHiLink hi link <args>
                            else
    3              0.000033   command! -nargs=+ HtmlHiLink hi def link <args>
    3              0.000003 endif
                            
    3              0.000006 syntax spell toplevel
                            
    3              0.000014 syn case ignore
                            
                            " mark illegal characters
    3              0.000063 syn match htmlError "[<>&]"
                            
                            
                            " tags
    3              0.000079 syn region  htmlString   contained start=+"+ end=+"+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    3              0.000047 syn region  htmlString   contained start=+'+ end=+'+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    3              0.000043 syn match   htmlValue    contained "=[\t ]*[^'" \t>][^ \t>]*"hs=s+1   contains=javaScriptExpression,@htmlPreproc
    3              0.000090 syn region  htmlEndTag             start=+</+      end=+>+ contains=htmlTagN,htmlTagError
    3              0.000148 syn region  htmlTag                start=+<[^/]+   end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent,htmlCssDefinition,@htmlPreproc,@htmlArgCluster
    3              0.000095 syn match   htmlTagN     contained +<\s*[-a-zA-Z0-9]\++hs=s+1 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    3              0.000085 syn match   htmlTagN     contained +</\s*[-a-zA-Z0-9]\++hs=s+2 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    3              0.000018 syn match   htmlTagError contained "[^>]<"ms=s+1
                            
                            
                            " tag names
    3              0.000027 syn keyword htmlTagName contained address applet area a base basefont
    3              0.000028 syn keyword htmlTagName contained big blockquote br caption center
    3              0.000029 syn keyword htmlTagName contained cite code dd dfn dir div dl dt font
    3              0.000022 syn keyword htmlTagName contained form hr html img
    3              0.000024 syn keyword htmlTagName contained input isindex kbd li link map menu
    3              0.000025 syn keyword htmlTagName contained meta ol option param pre p samp span
    3              0.000030 syn keyword htmlTagName contained select small strike sub sup
    3              0.000044 syn keyword htmlTagName contained table td textarea th tr tt ul var xmp
    3              0.000053 syn match htmlTagName contained "\<\(b\|i\|u\|h[1-6]\|em\|strong\|head\|body\|title\)\>"
                            
                            " new html 4.0 tags
    3              0.000027 syn keyword htmlTagName contained abbr acronym bdo button col label
    3              0.000023 syn keyword htmlTagName contained colgroup del fieldset iframe ins legend
    3              0.000030 syn keyword htmlTagName contained object optgroup q s tbody tfoot thead
                            
                            " legal arg names
    3              0.000028 syn keyword htmlArg contained action
    3              0.000027 syn keyword htmlArg contained align alink alt archive background bgcolor
    3              0.000020 syn keyword htmlArg contained border bordercolor cellpadding
    3              0.000027 syn keyword htmlArg contained cellspacing checked class clear code codebase color
    3              0.000022 syn keyword htmlArg contained cols colspan content coords enctype face
    3              0.000025 syn keyword htmlArg contained gutter height hspace id
    3              0.000020 syn keyword htmlArg contained link lowsrc marginheight
    3              0.000028 syn keyword htmlArg contained marginwidth maxlength method name prompt
    3              0.000025 syn keyword htmlArg contained rel rev rows rowspan scrolling selected shape
    3              0.000023 syn keyword htmlArg contained size src start target text type url
    3              0.000025 syn keyword htmlArg contained usemap ismap valign value vlink vspace width wrap
    3              0.000041 syn match   htmlArg contained "\<\(http-equiv\|href\|title\)="me=e-1
                            
                            " Netscape extensions
    3              0.000026 syn keyword htmlTagName contained frame noframes frameset nobr blink
    3              0.000023 syn keyword htmlTagName contained layer ilayer nolayer spacer
    3              0.000023 syn keyword htmlArg     contained frameborder noresize pagex pagey above below
    3              0.000022 syn keyword htmlArg     contained left top visibility clip id noshade
    3              0.000026 syn match   htmlArg     contained "\<z-index\>"
                            
                            " Microsoft extensions
    3              0.000019 syn keyword htmlTagName contained marquee
                            
                            " html 4.0 arg names
    3              0.000031 syn match   htmlArg contained "\<\(accept-charset\|label\)\>"
    3              0.000026 syn keyword htmlArg contained abbr accept accesskey axis char charoff charset
    3              0.000351 syn keyword htmlArg contained cite classid codetype compact data datetime
    3              0.000047 syn keyword htmlArg contained declare defer dir disabled for frame
    3              0.000030 syn keyword htmlArg contained headers hreflang lang language longdesc
    3              0.000074 syn keyword htmlArg contained multiple nohref nowrap object profile readonly
    3              0.000113 syn keyword htmlArg contained rules scheme scope span standby style
    3              0.000075 syn keyword htmlArg contained summary tabindex valuetype version
                            
                            " special characters
    3              0.000037 syn match htmlSpecialChar "&#\=[0-9A-Za-z]\{1,8};"
                            
                            " Comments (the real ones or the old netscape ones)
    3              0.000021 if exists("html_wrong_comments")
                              syn region htmlComment                start=+<!--+    end=+--\s*>+ contains=@Spell
                            else
    3              0.000064   syn region htmlComment                start=+<!+      end=+>+   contains=htmlCommentPart,htmlCommentError,@Spell
    3              0.000020   syn match  htmlCommentError contained "[^><!]"
    3              0.000030   syn region htmlCommentPart  contained start=+--+      end=+--\s*+  contains=@htmlPreProc,@Spell
    3              0.000005 endif
    3              0.000031 syn region htmlComment                  start=+<!DOCTYPE+ keepend end=+>+
                            
                            " server-parsed commands
    3              0.000071 syn region htmlPreProc start=+<!--#+ end=+-->+ contains=htmlPreStmt,htmlPreError,htmlPreAttr
    3              0.000033 syn match htmlPreStmt contained "<!--#\(config\|echo\|exec\|fsize\|flastmod\|include\|printenv\|set\|if\|elif\|else\|endif\|geoguide\)\>"
    3              0.000020 syn match htmlPreError contained "<!--#\S*"ms=s+4
    3              0.000052 syn match htmlPreAttr contained "\w\+=[^"]\S\+" contains=htmlPreProcAttrError,htmlPreProcAttrName
    3              0.000045 syn region htmlPreAttr contained start=+\w\+="+ skip=+\\\\\|\\"+ end=+"+ contains=htmlPreProcAttrName keepend
    3              0.000020 syn match htmlPreProcAttrError contained "\w\+="he=e-1
    3              0.000027 syn match htmlPreProcAttrName contained "\(expr\|errmsg\|sizefmt\|timefmt\|var\|cgi\|cmd\|file\|virtual\|value\)="he=e-1
                            
    3              0.000011 if !exists("html_no_rendering")
                              " rendering
    3              0.000138   syn cluster htmlTop contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,javaScript,@htmlPreproc
                            
    3              0.000064   syn region htmlBold start="<b\>" end="</b>"me=e-4 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    3              0.000060   syn region htmlBold start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    3              0.000045   syn region htmlBoldUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlBoldUnderlineItalic
    3              0.000054   syn region htmlBoldItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop,htmlBoldItalicUnderline
    3              0.000044   syn region htmlBoldItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop,htmlBoldItalicUnderline
    3              0.000027   syn region htmlBoldUnderlineItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop
    3              0.000032   syn region htmlBoldUnderlineItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop
    3              0.000039   syn region htmlBoldItalicUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlBoldUnderlineItalic
                            
    3              0.000058   syn region htmlUnderline start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlUnderlineBold,htmlUnderlineItalic
    3              0.000049   syn region htmlUnderlineBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop,htmlUnderlineBoldItalic
    3              0.000045   syn region htmlUnderlineBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop,htmlUnderlineBoldItalic
    3              0.000049   syn region htmlUnderlineItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop,htmlUnderlineItalicBold
    3              0.000040   syn region htmlUnderlineItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop,htmlUnderlineItalicBold
    3              0.000025   syn region htmlUnderlineItalicBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop
    3              0.000029   syn region htmlUnderlineItalicBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop
    3              0.000025   syn region htmlUnderlineBoldItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop
    3              0.000031   syn region htmlUnderlineBoldItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop
                            
    3              0.000078   syn region htmlItalic start="<i\>" end="</i>"me=e-4 contains=@htmlTop,htmlItalicBold,htmlItalicUnderline
    3              0.000027   syn region htmlItalic start="<em\>" end="</em>"me=e-5 contains=@htmlTop
    3              0.000049   syn region htmlItalicBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop,htmlItalicBoldUnderline
    3              0.000080   syn region htmlItalicBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop,htmlItalicBoldUnderline
    3              0.000031   syn region htmlItalicBoldUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop
    3              0.000045   syn region htmlItalicUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlItalicUnderlineBold
    3              0.000026   syn region htmlItalicUnderlineBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop
    3              0.000033   syn region htmlItalicUnderlineBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop
                            
    3              0.000021   syn match htmlLeadingSpace "^\s\+" contained
    3              0.000165   syn region htmlLink start="<a\>\_[^>]*\<href\>" end="</a>"me=e-4 contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLeadingSpace,javaScript,@htmlPreproc
    3              0.000034   syn region htmlH1 start="<h1\>" end="</h1>"me=e-5 contains=@htmlTop
    3              0.000035   syn region htmlH2 start="<h2\>" end="</h2>"me=e-5 contains=@htmlTop
    3              0.000033   syn region htmlH3 start="<h3\>" end="</h3>"me=e-5 contains=@htmlTop
    3              0.000030   syn region htmlH4 start="<h4\>" end="</h4>"me=e-5 contains=@htmlTop
    3              0.000051   syn region htmlH5 start="<h5\>" end="</h5>"me=e-5 contains=@htmlTop
    3              0.000051   syn region htmlH6 start="<h6\>" end="</h6>"me=e-5 contains=@htmlTop
    3              0.000204   syn region htmlHead start="<head\>" end="</head>"me=e-7 end="<body\>"me=e-5 end="<h[1-6]\>"me=e-3 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,htmlTitle,javaScript,cssStyle,@htmlPreproc
    3              0.000172   syn region htmlTitle start="<title\>" end="</title>"me=e-8 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,javaScript,@htmlPreproc
    3              0.000005 endif
                            
    3              0.000039 syn keyword htmlTagName         contained noscript
    3              0.000037 syn keyword htmlSpecialTagName  contained script style
    3              0.000021 if main_syntax != 'java' || exists("java_javascript")
                              " JAVA SCRIPT
    3              0.001844   syn include @htmlJavaScript syntax/javascript.vim
    3              0.000011   unlet b:current_syntax
    3              0.000108   syn region  javaScript start=+<script\_[^>]*>+ keepend end=+</script>+me=s-1 contains=@htmlJavaScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    3              0.000127   syn region  htmlScriptTag     contained start=+<script+ end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent
    3              0.000033   HtmlHiLink htmlScriptTag htmlTag
                            
                              " html events (i.e. arguments that include javascript commands)
    3              0.000013   if exists("html_extended_events")
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ contains=htmlEventSQ
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ contains=htmlEventDQ
                              else
    3              0.000036     syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ keepend contains=htmlEventSQ
    3              0.000035     syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ keepend contains=htmlEventDQ
    3              0.000004   endif
    3              0.000024   syn region htmlEventSQ        contained start=+'+ms=s+1 end=+'+me=s-1 contains=@htmlJavaScript
    3              0.000024   syn region htmlEventDQ        contained start=+"+ms=s+1 end=+"+me=s-1 contains=@htmlJavaScript
    3              0.000019   HtmlHiLink htmlEventSQ htmlEvent
    3              0.000016   HtmlHiLink htmlEventDQ htmlEvent
                            
                              " a javascript expression is used as an arg value
    3              0.000035   syn region  javaScriptExpression contained start=+&{+ keepend end=+};+ contains=@htmlJavaScript,@htmlPreproc
    3              0.000003 endif
                            
    3              0.000012 if main_syntax != 'java' || exists("java_vb")
                              " VB SCRIPT
    3              0.001564   syn include @htmlVbScript syntax/vb.vim
    3              0.000012   unlet b:current_syntax
    3              0.000098   syn region  javaScript start=+<script \_[^>]*language *=\_[^>]*vbscript\_[^>]*>+ keepend end=+</script>+me=s-1 contains=@htmlVbScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    3              0.000007 endif
                            
    3              0.000015 syn cluster htmlJavaScript      add=@htmlPreproc
                            
    3              0.000012 if main_syntax != 'java' || exists("java_css")
                              " embedded style sheets
    3              0.000028   syn keyword htmlArg           contained media
    3              0.000333   syn include @htmlCss syntax/css.vim
    3              0.000014   unlet b:current_syntax
    3              0.000165   syn region cssStyle start=+<style+ keepend end=+</style>+ contains=@htmlCss,htmlTag,htmlEndTag,htmlCssStyleComment,@htmlPreproc
    3              0.000023   syn match htmlCssStyleComment contained "\(<!--\|-->\)"
    3              0.006417   syn region htmlCssDefinition matchgroup=htmlArg start='style="' keepend matchgroup=htmlString end='"' contains=css.*Attr,css.*Prop,cssComment,cssLength,cssColor,cssURL,cssImportant,cssError,cssString,@htmlPreproc
    3              0.000048   HtmlHiLink htmlStyleArg htmlString
    3              0.000004 endif
                            
    3              0.000012 if main_syntax == "html"
                              " synchronizing (does not always work if a comment includes legal
                              " html tags, but doing it right would mean to always start
                              " at the first line, which is too slow)
    2              0.000024   syn sync match htmlHighlight groupthere NONE "<[/a-zA-Z]"
    2              0.000024   syn sync match htmlHighlight groupthere javaScript "<script"
    2              0.000018   syn sync match htmlHighlightSkip "^.*['\"].*$"
    2              0.000005   syn sync minlines=10
    2              0.000002 endif
                            
                            " The default highlighting.
    3              0.000010 if version >= 508 || !exists("did_html_syn_inits")
    3              0.000003   if version < 508
                                let did_html_syn_inits = 1
                              endif
    3              0.000049   HtmlHiLink htmlTag                     Function
    3              0.000039   HtmlHiLink htmlEndTag                  Identifier
    3              0.000038   HtmlHiLink htmlArg                     Type
    3              0.000029   HtmlHiLink htmlTagName                 htmlStatement
    3              0.000037   HtmlHiLink htmlSpecialTagName          Exception
    3              0.000029   HtmlHiLink htmlValue                     String
    3              0.000032   HtmlHiLink htmlSpecialChar             Special
                              
    3              0.000012   if !exists("html_no_rendering")
    3              0.000042     HtmlHiLink htmlH1                      Title
    3              0.000019     HtmlHiLink htmlH2                      htmlH1
    3              0.000023     HtmlHiLink htmlH3                      htmlH2
    3              0.000018     HtmlHiLink htmlH4                      htmlH3
    3              0.000021     HtmlHiLink htmlH5                      htmlH4
    3              0.000031     HtmlHiLink htmlH6                      htmlH5
    3              0.000033     HtmlHiLink htmlHead                    PreProc
    3              0.000033     HtmlHiLink htmlTitle                   Title
    3              0.000022     HtmlHiLink htmlBoldItalicUnderline     htmlBoldUnderlineItalic
    3              0.000018     HtmlHiLink htmlUnderlineBold           htmlBoldUnderline
    3              0.000019     HtmlHiLink htmlUnderlineItalicBold     htmlBoldUnderlineItalic
    3              0.000019     HtmlHiLink htmlUnderlineBoldItalic     htmlBoldUnderlineItalic
    3              0.000021     HtmlHiLink htmlItalicUnderline         htmlUnderlineItalic
    3              0.000018     HtmlHiLink htmlItalicBold              htmlBoldItalic
    3              0.000020     HtmlHiLink htmlItalicBoldUnderline     htmlBoldUnderlineItalic
    3              0.000019     HtmlHiLink htmlItalicUnderlineBold     htmlBoldUnderlineItalic
    3              0.000030     HtmlHiLink htmlLink                    Underlined
    3              0.000026     HtmlHiLink htmlLeadingSpace            None
    3              0.000012     if !exists("html_my_rendering")
    3              0.000013       hi def htmlBold                term=bold cterm=bold gui=bold
    3              0.000014       hi def htmlBoldUnderline       term=bold,underline cterm=bold,underline gui=bold,underline
    3              0.000015       hi def htmlBoldItalic          term=bold,italic cterm=bold,italic gui=bold,italic
    3              0.000013       hi def htmlBoldUnderlineItalic term=bold,italic,underline cterm=bold,italic,underline gui=bold,italic,underline
    3              0.000011       hi def htmlUnderline           term=underline cterm=underline gui=underline
    3              0.000010       hi def htmlUnderlineItalic     term=italic,underline cterm=italic,underline gui=italic,underline
    3              0.000010       hi def htmlItalic              term=italic cterm=italic gui=italic
    3              0.000003     endif
    3              0.000002   endif
                              
    3              0.000031   HtmlHiLink htmlPreStmt            PreProc
    3              0.000029   HtmlHiLink htmlPreError           Error
    3              0.000030   HtmlHiLink htmlPreProc            PreProc
    3              0.000037   HtmlHiLink htmlPreAttr            String
    3              0.000030   HtmlHiLink htmlPreProcAttrName    PreProc
    3              0.000029   HtmlHiLink htmlPreProcAttrError   Error
    3              0.000037   HtmlHiLink htmlSpecial            Special
    3              0.000032   HtmlHiLink htmlSpecialChar        Special
    3              0.000044   HtmlHiLink htmlString             String
    3              0.000026   HtmlHiLink htmlStatement          Statement
    3              0.000029   HtmlHiLink htmlComment            Comment
    3              0.000030   HtmlHiLink htmlCommentPart        Comment
    3              0.000030   HtmlHiLink htmlValue              String
    3              0.000019   HtmlHiLink htmlCommentError       htmlError
    3              0.000019   HtmlHiLink htmlTagError           htmlError
    3              0.000029   HtmlHiLink htmlEvent              javaScript
    3              0.000031   HtmlHiLink htmlError              Error
                              
    3              0.000036   HtmlHiLink javaScript             Special
    3              0.000029   HtmlHiLink javaScriptExpression   javaScript
    3              0.000026   HtmlHiLink htmlCssStyleComment    Comment
    3              0.000029   HtmlHiLink htmlCssDefinition      Special
    3              0.000003 endif
                            
    3              0.000006 delcommand HtmlHiLink
                            
    3              0.000010 let b:current_syntax = "html"
                            
    3              0.000009 if main_syntax == 'html'
    2              0.000004   unlet main_syntax
    2              0.000002 endif
                            
    3              0.000038 let &cpo = s:cpo_save
    3              0.000006 unlet s:cpo_save
                            " vim: ts=8

SCRIPT  /usr/local/Cellar/macvim/7.4-73/MacVim.app/Contents/Resources/vim/runtime/syntax/javascript.vim
Sourced 8 times
Total time:   0.005411
 Self time:   0.005411

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	JavaScript
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " Updaters:	Scott Shattuck (ss) <ss@technicalpursuit.com>
                            " URL:		http://www.fleiner.com/vim/syntax/javascript.vim
                            " Changes:	(ss) added keywords, reserved words, and other identifiers
                            "		(ss) repaired several quoting and grouping glitches
                            "		(ss) fixed regex parsing issue with multiple qualifiers [gi]
                            "		(ss) additional factoring of keywords, globals, and members
                            " Last Change:	2012 Oct 05
                            " 		2013 Jun 12: adjusted javaScriptRegexpString (Kevin Locke)
                            
                            " For version 5.x: Clear all syntax items
                            " For version 6.x: Quit when a syntax file was already loaded
                            " tuning parameters:
                            " unlet javaScript_fold
                            
    8              0.000043 if !exists("main_syntax")
    4              0.000007   if version < 600
                                syntax clear
                              elseif exists("b:current_syntax")
    2              0.000002     finish
                              endif
    2              0.000006   let main_syntax = 'javascript'
    2              0.000004 elseif exists("b:current_syntax") && b:current_syntax == "javascript"
                              finish
                            endif
                            
    6              0.000036 let s:cpo_save = &cpo
    6              0.000034 set cpo&vim
                            
                            " Drop fold if it set but vim doesn't support it.
    6              0.000025 if version < 600 && exists("javaScript_fold")
                              unlet javaScript_fold
                            endif
                            
                            
    6              0.000123 syn keyword javaScriptCommentTodo      TODO FIXME XXX TBD contained
    6              0.000097 syn match   javaScriptLineComment      "\/\/.*" contains=@Spell,javaScriptCommentTodo
    6              0.000063 syn match   javaScriptCommentSkip      "^[ \t]*\*\($\|[ \t]\+\)"
    6              0.000099 syn region  javaScriptComment	       start="/\*"  end="\*/" contains=@Spell,javaScriptCommentTodo
    6              0.000061 syn match   javaScriptSpecial	       "\\\d\d\d\|\\."
    6              0.000118 syn region  javaScriptStringD	       start=+"+  skip=+\\\\\|\\"+  end=+"\|$+	contains=javaScriptSpecial,@htmlPreproc
    6              0.000106 syn region  javaScriptStringS	       start=+'+  skip=+\\\\\|\\'+  end=+'\|$+	contains=javaScriptSpecial,@htmlPreproc
                            
    6              0.000036 syn match   javaScriptSpecialCharacter "'\\.'"
    6              0.000060 syn match   javaScriptNumber	       "-\=\<\d\+L\=\>\|0[xX][0-9a-fA-F]\+\>"
    6              0.000122 syn region  javaScriptRegexpString     start=+/[^/*]+me=e-1 skip=+\\\\\|\\/+ end=+/[gim]\{0,2\}\s*$+ end=+/[gim]\{0,2\}\s*[;.,)\]}]+me=e-1 contains=@htmlPreproc oneline
                            
    6              0.000072 syn keyword javaScriptConditional	if else switch
    6              0.000072 syn keyword javaScriptRepeat		while for do in
    6              0.000061 syn keyword javaScriptBranch		break continue
    6              0.000086 syn keyword javaScriptOperator		new delete instanceof typeof
    6              0.000094 syn keyword javaScriptType		Array Boolean Date Function Number Object String RegExp
    6              0.000034 syn keyword javaScriptStatement		return with
    6              0.000030 syn keyword javaScriptBoolean		true false
    6              0.000033 syn keyword javaScriptNull		null undefined
    6              0.000034 syn keyword javaScriptIdentifier	arguments this var let
    6              0.000030 syn keyword javaScriptLabel		case default
    6              0.000033 syn keyword javaScriptException		try catch finally throw
    6              0.000039 syn keyword javaScriptMessage		alert confirm prompt status
    6              0.000040 syn keyword javaScriptGlobal		self window top parent
    6              0.000036 syn keyword javaScriptMember		document event location 
    6              0.000045 syn keyword javaScriptDeprecated	escape unescape
    6              0.000115 syn keyword javaScriptReserved		abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile 
                            
    6              0.000025 if exists("javaScript_fold")
                                syn match	javaScriptFunction	"\<function\>"
                                syn region	javaScriptFunctionFold	start="\<function\>.*[^};]$" end="^\z1}.*$" transparent fold keepend
                            
                                syn sync match javaScriptSync	grouphere javaScriptFunctionFold "\<function\>"
                                syn sync match javaScriptSync	grouphere NONE "^}"
                            
                                setlocal foldmethod=syntax
                                setlocal foldtext=getline(v:foldstart)
                            else
    6              0.000046     syn keyword javaScriptFunction	function
    6              0.000055     syn match	javaScriptBraces	   "[{}\[\]]"
    6              0.000040     syn match	javaScriptParens	   "[()]"
    6              0.000009 endif
                            
    6              0.000010 syn sync fromstart
    6              0.000011 syn sync maxlines=100
                            
    6              0.000020 if main_syntax == "javascript"
    2              0.000008   syn sync ccomment javaScriptComment
    2              0.000002 endif
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    6              0.000015 if version >= 508 || !exists("did_javascript_syn_inits")
    6              0.000008   if version < 508
                                let did_javascript_syn_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
    6              0.000065     command -nargs=+ HiLink hi def link <args>
    6              0.000322   endif
    6              0.000114   HiLink javaScriptComment		Comment
    6              0.000097   HiLink javaScriptLineComment		Comment
    6              0.000068   HiLink javaScriptCommentTodo		Todo
    6              0.000069   HiLink javaScriptSpecial		Special
    6              0.000070   HiLink javaScriptStringS		String
    6              0.000069   HiLink javaScriptStringD		String
    6              0.000076   HiLink javaScriptCharacter		Character
    6              0.000056   HiLink javaScriptSpecialCharacter	javaScriptSpecial
    6              0.000044   HiLink javaScriptNumber		javaScriptValue
    6              0.000061   HiLink javaScriptConditional		Conditional
    6              0.000061   HiLink javaScriptRepeat		Repeat
    6              0.000061   HiLink javaScriptBranch		Conditional
    6              0.000055   HiLink javaScriptOperator		Operator
    6              0.000054   HiLink javaScriptType			Type
    6              0.000056   HiLink javaScriptStatement		Statement
    6              0.000054   HiLink javaScriptFunction		Function
    6              0.000053   HiLink javaScriptBraces		Function
    6              0.000063   HiLink javaScriptError		Error
    6              0.000044   HiLink javaScrParenError		javaScriptError
    6              0.000058   HiLink javaScriptNull			Keyword
    6              0.000061   HiLink javaScriptBoolean		Boolean
    6              0.000064   HiLink javaScriptRegexpString		String
                            
    6              0.000062   HiLink javaScriptIdentifier		Identifier
    6              0.000061   HiLink javaScriptLabel		Label
    6              0.000065   HiLink javaScriptException		Exception
    6              0.000060   HiLink javaScriptMessage		Keyword
    6              0.000055   HiLink javaScriptGlobal		Keyword
    6              0.000053   HiLink javaScriptMember		Keyword
    6              0.000064   HiLink javaScriptDeprecated		Exception 
    6              0.000071   HiLink javaScriptReserved		Keyword
    6              0.000060   HiLink javaScriptDebug		Debug
    6              0.000058   HiLink javaScriptConstant		Label
                            
    6              0.000015   delcommand HiLink
    6              0.000010 endif
                            
    6              0.000022 let b:current_syntax = "javascript"
    6              0.000018 if main_syntax == 'javascript'
    2              0.000004   unlet main_syntax
    2              0.000002 endif
    6              0.000046 let &cpo = s:cpo_save
    6              0.000010 unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  /usr/local/Cellar/macvim/7.4-73/MacVim.app/Contents/Resources/vim/runtime/syntax/vb.vim
Sourced 3 times
Total time:   0.012516
 Self time:   0.012516

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Visual Basic
                            " Maintainer:	Tim Chase <vb.vim@tim.thechases.com>
                            " Former Maintainer:	Robert M. Cortopassi <cortopar@mindspring.com>
                            "	(tried multiple times to contact, but email bounced)
                            " Last Change:
                            "   2005 May 25  Synched with work by Thomas Barthel
                            "   2004 May 30  Added a few keywords
                            
                            " This was thrown together after seeing numerous requests on the
                            " VIM and VIM-DEV mailing lists.  It is by no means complete.
                            " Send comments, suggestions and requests to the maintainer.
                            
                            " For version 5.x: Clear all syntax items
                            " For version 6.x: Quit when a syntax file was already loaded
    3              0.000010 if version < 600
                            	syntax clear
                            elseif exists("b:current_syntax")
                            	finish
                            endif
                            
                            " VB is case insensitive
    3              0.000005 syn case ignore
                            
    3              0.000030 syn keyword vbConditional If Then ElseIf Else Select Case
                            
    3              0.000024 syn keyword vbOperator AddressOf And ByRef ByVal Eqv Imp In
    3              0.000016 syn keyword vbOperator Is Like Mod Not Or To Xor
                            
    3              0.000022 syn match vbOperator "[()+.,\-/*=&]"
    3              0.000028 syn match vbOperator "[<>]=\="
    3              0.000014 syn match vbOperator "<>"
    3              0.000017 syn match vbOperator "\s\+_$"
                            
    3              0.000019 syn keyword vbBoolean  True False
    3              0.000016 syn keyword vbConst Null Nothing
                            
    3              0.000019 syn keyword vbRepeat Do For ForEach Loop Next
    3              0.000019 syn keyword vbRepeat Step To Until Wend While
                            
    3              0.000023 syn keyword vbEvents AccessKeyPress Activate ActiveRowChanged
    3              0.000025 syn keyword vbEvents AfterAddFile AfterChangeFileName AfterCloseFile
    3              0.000014 syn keyword vbEvents AfterColEdit AfterColUpdate AfterDelete
    3              0.000014 syn keyword vbEvents AfterInsert AfterLabelEdit AfterRemoveFile
    3              0.000014 syn keyword vbEvents AfterUpdate AfterWriteFile AmbientChanged
    3              0.000016 syn keyword vbEvents ApplyChanges Associate AsyncProgress
    3              0.000015 syn keyword vbEvents AsyncReadComplete AsyncReadProgress AxisActivated
    3              0.000011 syn keyword vbEvents AxisLabelActivated AxisLabelSelected
    3              0.000013 syn keyword vbEvents AxisLabelUpdated AxisSelected AxisTitleActivated
    3              0.000014 syn keyword vbEvents AxisTitleSelected AxisTitleUpdated AxisUpdated
    3              0.000013 syn keyword vbEvents BeforeClick BeforeColEdit BeforeColUpdate
    3              0.000014 syn keyword vbEvents BeforeConnect BeforeDelete BeforeInsert
    3              0.000017 syn keyword vbEvents BeforeLabelEdit BeforeLoadFile BeforeUpdate
    3              0.000014 syn keyword vbEvents BeginRequest BeginTrans ButtonClick
    3              0.000013 syn keyword vbEvents ButtonCompleted ButtonDropDown ButtonGotFocus
    3              0.000016 syn keyword vbEvents ButtonLostFocus CallbackKeyDown Change Changed
    3              0.000015 syn keyword vbEvents ChartActivated ChartSelected ChartUpdated Click
    3              0.000019 syn keyword vbEvents Close CloseQuery CloseUp ColEdit ColResize
    3              0.000015 syn keyword vbEvents Collapse ColumnClick CommitTrans Compare
    3              0.000017 syn keyword vbEvents ConfigChageCancelled ConfigChanged
    3              0.000015 syn keyword vbEvents ConfigChangedCancelled Connect ConnectionRequest
    3              0.000013 syn keyword vbEvents CurrentRecordChanged DECommandAdded
    3              0.000019 syn keyword vbEvents DECommandPropertyChanged DECommandRemoved
    3              0.000013 syn keyword vbEvents DEConnectionAdded DEConnectionPropertyChanged
    3              0.000014 syn keyword vbEvents DEConnectionRemoved DataArrival DataChanged
    3              0.000016 syn keyword vbEvents DataUpdated DateClicked DblClick Deactivate
    3              0.000014 syn keyword vbEvents DevModeChange DeviceArrival DeviceOtherEvent
    3              0.000013 syn keyword vbEvents DeviceQueryRemove DeviceQueryRemoveFailed
    3              0.000013 syn keyword vbEvents DeviceRemoveComplete DeviceRemovePending
    3              0.000014 syn keyword vbEvents Disconnect DisplayChanged Dissociate
    3              0.000016 syn keyword vbEvents DoGetNewFileName Done DonePainting DownClick
    3              0.000019 syn keyword vbEvents DragDrop DragOver DropDown EditProperty EditQuery
    3              0.000015 syn keyword vbEvents EndRequest EnterCell EnterFocus ExitFocus Expand
    3              0.000021 syn keyword vbEvents FontChanged FootnoteActivated FootnoteSelected
    3              0.000014 syn keyword vbEvents FootnoteUpdated Format FormatSize GotFocus
    3              0.000016 syn keyword vbEvents HeadClick HeightChanged Hide InfoMessage
    3              0.000014 syn keyword vbEvents IniProperties InitProperties Initialize
    3              0.000016 syn keyword vbEvents ItemActivated ItemAdded ItemCheck ItemClick
    3              0.000018 syn keyword vbEvents ItemReloaded ItemRemoved ItemRenamed
    3              0.000015 syn keyword vbEvents ItemSeletected KeyDown KeyPress KeyUp LeaveCell
    3              0.000015 syn keyword vbEvents LegendActivated LegendSelected LegendUpdated
    3              0.000014 syn keyword vbEvents LinkClose LinkError LinkExecute LinkNotify
    3              0.000014 syn keyword vbEvents LinkOpen Load LostFocus MouseDown MouseMove
    3              0.000020 syn keyword vbEvents MouseUp NodeCheck NodeClick OLECompleteDrag
    3              0.000345 syn keyword vbEvents OLEDragDrop OLEDragOver OLEGiveFeedback OLESetData
    3              0.000030 syn keyword vbEvents OLEStartDrag ObjectEvent ObjectMove OnAddNew
    3              0.000023 syn keyword vbEvents OnComm Paint PanelClick PanelDblClick PathChange
    3              0.000014 syn keyword vbEvents PatternChange PlotActivated PlotSelected
    3              0.000019 syn keyword vbEvents PlotUpdated PointActivated PointLabelActivated
    3              0.000014 syn keyword vbEvents PointLabelSelected PointLabelUpdated PointSelected
    3              0.000014 syn keyword vbEvents PointUpdated PowerQuerySuspend PowerResume
    3              0.000014 syn keyword vbEvents PowerStatusChanged PowerSuspend ProcessTag
    3              0.000015 syn keyword vbEvents ProcessingTimeout QueryChangeConfig QueryClose
    3              0.000014 syn keyword vbEvents QueryComplete QueryCompleted QueryTimeout
    3              0.000024 syn keyword vbEvents QueryUnload ReadProperties RepeatedControlLoaded
    3              0.000012 syn keyword vbEvents RepeatedControlUnloaded Reposition
    3              0.000017 syn keyword vbEvents RequestChangeFileName RequestWriteFile Resize
    3              0.000016 syn keyword vbEvents ResultsChanged RetainedProject RollbackTrans
    3              0.000014 syn keyword vbEvents RowColChange RowCurrencyChange RowResize
    3              0.000015 syn keyword vbEvents RowStatusChanged Scroll SelChange SelectionChanged
    3              0.000016 syn keyword vbEvents SendComplete SendProgress SeriesActivated
    3              0.000015 syn keyword vbEvents SeriesSelected SeriesUpdated SettingChanged Show
    3              0.000016 syn keyword vbEvents SplitChange Start StateChanged StatusUpdate
    3              0.000015 syn keyword vbEvents SysColorsChanged Terminate TimeChanged Timer
    3              0.000014 syn keyword vbEvents TitleActivated TitleSelected TitleUpdated
    3              0.000022 syn keyword vbEvents UnboundAddData UnboundDeleteRow
    3              0.000013 syn keyword vbEvents UnboundGetRelativeBookmark UnboundReadData
    3              0.000018 syn keyword vbEvents UnboundWriteData Unformat Unload UpClick Updated
    3              0.000014 syn keyword vbEvents UserEvent Validate ValidationError
    3              0.000015 syn keyword vbEvents VisibleRecordChanged WillAssociate WillChangeData
    3              0.000014 syn keyword vbEvents WillDissociate WillExecute WillUpdateRows
    3              0.000010 syn keyword vbEvents WriteProperties
                            
                            
    3              0.000030 syn keyword vbFunction Abs Array Asc AscB AscW Atn Avg BOF CBool CByte
    3              0.000026 syn keyword vbFunction CCur CDate CDbl CInt CLng CSng CStr CVDate CVErr
    3              0.000020 syn keyword vbFunction CVar CallByName Cdec Choose Chr ChrB ChrW Command
    3              0.000018 syn keyword vbFunction Cos Count CreateObject CurDir DDB Date DateAdd
    3              0.000017 syn keyword vbFunction DateDiff DatePart DateSerial DateValue Day Dir
    3              0.000018 syn keyword vbFunction DoEvents EOF Environ Error Exp FV FileAttr
    3              0.000016 syn keyword vbFunction FileDateTime FileLen FilterFix Fix Format
    3              0.000018 syn keyword vbFunction FormatCurrency FormatDateTime FormatNumber
    3              0.000016 syn keyword vbFunction FormatPercent FreeFile GetAllStrings GetAttr
    3              0.000016 syn keyword vbFunction GetAutoServerSettings GetObject GetSetting Hex
    3              0.000016 syn keyword vbFunction Hour IIf IMEStatus IPmt InStr Input InputB
    3              0.000020 syn keyword vbFunction InputBox InstrB Int IsArray IsDate IsEmpty IsError
    3              0.000024 syn keyword vbFunction IsMissing IsNull IsNumeric IsObject Join LBound
    3              0.000017 syn keyword vbFunction LCase LOF LTrim Left LeftB Len LenB LoadPicture
    3              0.000016 syn keyword vbFunction LoadResData LoadResPicture LoadResString Loc Log
    3              0.000018 syn keyword vbFunction MIRR Max Mid MidB Min Minute Month MonthName
    3              0.000018 syn keyword vbFunction MsgBox NPV NPer Now Oct PPmt PV Partition Pmt
    3              0.000021 syn keyword vbFunction QBColor RGB RTrim Rate Replace Right RightB Rnd
    3              0.000021 syn keyword vbFunction Round SLN SYD Second Seek Sgn Shell Sin Space Spc
    3              0.000019 syn keyword vbFunction Split Sqr StDev StDevP Str StrComp StrConv
    3              0.000018 syn keyword vbFunction StrReverse String Sum Switch Tab Tan Time
    3              0.000018 syn keyword vbFunction TimeSerial TimeValue Timer Trim TypeName UBound
    3              0.000017 syn keyword vbFunction UCase Val Var VarP VarType Weekday WeekdayName
    3              0.000017 syn keyword vbFunction Year
                            
    3              0.000022 syn keyword vbMethods AboutBox Accept Activate Add AddCustom AddFile
    3              0.000014 syn keyword vbMethods AddFromFile AddFromGuid AddFromString
    3              0.000016 syn keyword vbMethods AddFromTemplate AddItem AddNew AddToAddInToolbar
    3              0.000013 syn keyword vbMethods AddToolboxProgID Append AppendAppendChunk
    3              0.000074 syn keyword vbMethods AppendChunk Arrange Assert AsyncRead BatchUpdate
    3              0.000192 syn keyword vbMethods BeginQueryEdit BeginTrans Bind BuildPath
    3              0.000142 syn keyword vbMethods CanPropertyChange Cancel CancelAsyncRead
    3              0.000180 syn keyword vbMethods CancelBatch CancelUpdate CaptureImage CellText
    3              0.000180 syn keyword vbMethods CellValue Circle Clear ClearFields ClearSel
    3              0.000185 syn keyword vbMethods ClearSelCols ClearStructure Clone Close Cls
    3              0.000188 syn keyword vbMethods ColContaining CollapseAll ColumnSize CommitTrans
    3              0.000187 syn keyword vbMethods CompactDatabase Compose Connect Copy CopyFile
    3              0.000146 syn keyword vbMethods CopyFolder CopyQueryDef Count CreateDatabase
    3              0.000144 syn keyword vbMethods CreateDragImage CreateEmbed CreateField
    3              0.000187 syn keyword vbMethods CreateFolder CreateGroup CreateIndex CreateLink
    3              0.000143 syn keyword vbMethods CreatePreparedStatement CreatePropery CreateQuery
    3              0.000146 syn keyword vbMethods CreateQueryDef CreateRelation CreateTableDef
    3              0.000144 syn keyword vbMethods CreateTextFile CreateToolWindow CreateUser
    3              0.000144 syn keyword vbMethods CreateWorkspace Customize Cut Delete
    3              0.000157 syn keyword vbMethods DeleteColumnLabels DeleteColumns DeleteFile
    3              0.000147 syn keyword vbMethods DeleteFolder DeleteLines DeleteRowLabels
    3              0.000239 syn keyword vbMethods DeleteRows DeselectAll DesignerWindow DoVerb Drag
    3              0.000277 syn keyword vbMethods Draw DriveExists Edit EditCopy EditPaste EndDoc
    3              0.000190 syn keyword vbMethods EnsureVisible EstablishConnection Execute Exists
    3              0.000148 syn keyword vbMethods Expand Export ExportReport ExtractIcon Fetch
    3              0.000242 syn keyword vbMethods FetchVerbs FileExists Files FillCache Find
    3              0.000243 syn keyword vbMethods FindFirst FindItem FindLast FindNext FindPrevious
    3              0.000151 syn keyword vbMethods FolderExists Forward GetAbsolutePathName
    3              0.000195 syn keyword vbMethods GetBaseName GetBookmark GetChunk GetClipString
    3              0.000242 syn keyword vbMethods GetData GetDrive GetDriveName GetFile GetFileName
    3              0.000211 syn keyword vbMethods GetFirstVisible GetFolder GetFormat GetHeader
    3              0.000152 syn keyword vbMethods GetLineFromChar GetNumTicks GetParentFolderName
    3              0.000155 syn keyword vbMethods GetRows GetSelectedPart GetSelection
    3              0.000154 syn keyword vbMethods GetSpecialFolder GetTempName GetText
    3              0.000201 syn keyword vbMethods GetVisibleCount GoBack GoForward Hide HitTest
    3              0.000200 syn keyword vbMethods HoldFields Idle Import InitializeLabels Insert
    3              0.000159 syn keyword vbMethods InsertColumnLabels InsertColumns InsertFile
    3              0.000155 syn keyword vbMethods InsertLines InsertObjDlg InsertRowLabels
    3              0.000345 syn keyword vbMethods InsertRows Item Keys KillDoc Layout Line Lines
    3              0.000202 syn keyword vbMethods LinkExecute LinkPoke LinkRequest LinkSend Listen
    3              0.000071 syn keyword vbMethods LoadFile LoadResData LoadResPicture LoadResString
    3              0.000155 syn keyword vbMethods LogEvent MakeCompileFile MakeCompiledFile
    3              0.000067 syn keyword vbMethods MakeReplica MoreResults Move MoveData MoveFile
    3              0.000017 syn keyword vbMethods MoveFirst MoveFolder MoveLast MoveNext
    3              0.000015 syn keyword vbMethods MovePrevious NavigateTo NewPage NewPassword
    3              0.000016 syn keyword vbMethods NextRecordset OLEDrag OnAddinsUpdate OnConnection
    3              0.000015 syn keyword vbMethods OnDisconnection OnStartupComplete Open
    3              0.000013 syn keyword vbMethods OpenAsTextStream OpenConnection OpenDatabase
    3              0.000016 syn keyword vbMethods OpenQueryDef OpenRecordset OpenResultset OpenURL
    3              0.000015 syn keyword vbMethods Overlay PSet PaintPicture PastSpecialDlg Paste
    3              0.000015 syn keyword vbMethods PeekData Play Point PopulatePartial PopupMenu
    3              0.000024 syn keyword vbMethods Print PrintForm PrintReport PropertyChanged Quit
    3              0.000014 syn keyword vbMethods Raise RandomDataFill RandomFillColumns
    3              0.000016 syn keyword vbMethods RandomFillRows ReFill Read ReadAll ReadFromFile
    3              0.000014 syn keyword vbMethods ReadLine ReadProperty Rebind Refresh RefreshLink
    3              0.000016 syn keyword vbMethods RegisterDatabase ReleaseInstance Reload Remove
    3              0.000017 syn keyword vbMethods RemoveAddInFromToolbar RemoveAll RemoveItem Render
    3              0.000019 syn keyword vbMethods RepairDatabase ReplaceLine Reply ReplyAll Requery
    3              0.000014 syn keyword vbMethods ResetCustom ResetCustomLabel ResolveName
    3              0.000015 syn keyword vbMethods RestoreToolbar Resync Rollback RollbackTrans
    3              0.000014 syn keyword vbMethods RowBookmark RowContaining RowTop Save SaveAs
    3              0.000016 syn keyword vbMethods SaveFile SaveToFile SaveToOle1File SaveToolbar
    3              0.000027 syn keyword vbMethods Scale ScaleX ScaleY Scroll SelPrint SelectAll
    3              0.000016 syn keyword vbMethods SelectPart Send SendData Set SetAutoServerSettings
    3              0.000016 syn keyword vbMethods SetData SetFocus SetOption SetSelection SetSize
    3              0.000018 syn keyword vbMethods SetText SetViewport Show ShowColor ShowFont
    3              0.000015 syn keyword vbMethods ShowHelp ShowOpen ShowPrinter ShowSave
    3              0.000017 syn keyword vbMethods ShowWhatsThis SignOff SignOn Size Skip SkipLine
    3              0.000019 syn keyword vbMethods Span Split SplitContaining StartLabelEdit
    3              0.000019 syn keyword vbMethods StartLogging Stop Synchronize Tag TextHeight
    3              0.000047 syn keyword vbMethods TextWidth ToDefaults Trace TwipsToChartPart
    3              0.000019 syn keyword vbMethods TypeByChartType URLFor Update UpdateControls
    3              0.000015 syn keyword vbMethods UpdateRecord UpdateRow Upto ValidateControls Value
    3              0.000016 syn keyword vbMethods WhatsThisMode Write WriteBlankLines WriteLine
    3              0.000013 syn keyword vbMethods WriteProperty WriteTemplate ZOrder
    3              0.000014 syn keyword vbMethods rdoCreateEnvironment rdoRegisterDataSource
                            
    3              0.000077 syn keyword vbStatement Alias AppActivate As Base Beep Begin Call ChDir
    3              0.000020 syn keyword vbStatement ChDrive Close Const Date Declare DefBool DefByte
    3              0.000022 syn keyword vbStatement DefCur DefDate DefDbl DefDec DefInt DefLng DefObj
    3              0.000018 syn keyword vbStatement DefSng DefStr DefVar Deftype DeleteSetting Dim Do
    3              0.000022 syn keyword vbStatement Each ElseIf End Enum Erase Error Event Exit
    3              0.000022 syn keyword vbStatement Explicit FileCopy For ForEach Function Get GoSub
    3              0.000028 syn keyword vbStatement GoTo Gosub Implements Kill LSet Let Lib LineInput
    3              0.000020 syn keyword vbStatement Load Lock Loop Mid MkDir Name Next On OnError Open
    3              0.000017 syn keyword vbStatement Option Preserve Private Property Public Put RSet
    3              0.000017 syn keyword vbStatement RaiseEvent Randomize ReDim Redim Rem Reset Resume
    3              0.000017 syn keyword vbStatement Return RmDir SavePicture SaveSetting Seek SendKeys
    3              0.000021 syn keyword vbStatement Sendkeys Set SetAttr Static Step Stop Sub Time
    3              0.000017 syn keyword vbStatement Type Unload Unlock Until Wend While Width With
    3              0.000011 syn keyword vbStatement Write
                            
    3              0.000028 syn keyword vbKeyword As Binary ByRef ByVal Date Empty Error Friend Get
    3              0.000023 syn keyword vbKeyword Input Is Len Lock Me Mid New Nothing Null On
    3              0.000029 syn keyword vbKeyword Option Optional ParamArray Print Private Property
    3              0.000017 syn keyword vbKeyword Public PublicNotCreateable OnNewProcessSingleUse
    3              0.000014 syn keyword vbKeyword InSameProcessMultiUse GlobalMultiUse Resume Seek
    3              0.000017 syn keyword vbKeyword Set Static Step String Time WithEvents
                            
    3              0.000014 syn keyword vbTodo contained	TODO
                            
                            "Datatypes
    3              0.000022 syn keyword vbTypes Boolean Byte Currency Date Decimal Double Empty
    3              0.000017 syn keyword vbTypes Integer Long Object Single String Variant
                            
                            "VB defined values
    3              0.000020 syn keyword vbDefine dbBigInt dbBinary dbBoolean dbByte dbChar
    3              0.000016 syn keyword vbDefine dbCurrency dbDate dbDecimal dbDouble dbFloat
    3              0.000017 syn keyword vbDefine dbGUID dbInteger dbLong dbLongBinary dbMemo
    3              0.000018 syn keyword vbDefine dbNumeric dbSingle dbText dbTime dbTimeStamp
    3              0.000011 syn keyword vbDefine dbVarBinary
                            
                            "VB defined values
    3              0.000018 syn keyword vbDefine vb3DDKShadow vb3DFace vb3DHighlight vb3DLight
    3              0.000015 syn keyword vbDefine vb3DShadow vbAbort vbAbortRetryIgnore
    3              0.000019 syn keyword vbDefine vbActiveBorder vbActiveTitleBar vbAlias
    3              0.000013 syn keyword vbDefine vbApplicationModal vbApplicationWorkspace
    3              0.000016 syn keyword vbDefine vbAppTaskManager vbAppWindows vbArchive vbArray
    3              0.000017 syn keyword vbDefine vbBack vbBinaryCompare vbBlack vbBlue vbBoolean
    3              0.000015 syn keyword vbDefine vbButtonFace vbButtonShadow vbButtonText vbByte
    3              0.000016 syn keyword vbDefine vbCalGreg vbCalHijri vbCancel vbCr vbCritical
    3              0.000014 syn keyword vbDefine vbCrLf vbCurrency vbCyan vbDatabaseCompare
    3              0.000018 syn keyword vbDefine vbDataObject vbDate vbDecimal vbDefaultButton1
    3              0.000014 syn keyword vbDefine vbDefaultButton2 vbDefaultButton3 vbDefaultButton4
    3              0.000015 syn keyword vbDefine vbDesktop vbDirectory vbDouble vbEmpty vbError
    3              0.000014 syn keyword vbDefine vbExclamation vbFirstFourDays vbFirstFullWeek
    3              0.000021 syn keyword vbDefine vbFirstJan1 vbFormCode vbFormControlMenu
    3              0.000015 syn keyword vbDefine vbFormFeed vbFormMDIForm vbFriday vbFromUnicode
    3              0.000018 syn keyword vbDefine vbGrayText vbGreen vbHidden vbHide vbHighlight
    3              0.000019 syn keyword vbDefine vbHighlightText vbHiragana vbIgnore vbIMEAlphaDbl
    3              0.000013 syn keyword vbDefine vbIMEAlphaSng vbIMEDisable vbIMEHiragana
    3              0.000015 syn keyword vbDefine vbIMEKatakanaDbl vbIMEKatakanaSng vbIMEModeAlpha
    3              0.000013 syn keyword vbDefine vbIMEModeAlphaFull vbIMEModeDisable
    3              0.000013 syn keyword vbDefine vbIMEModeHangul vbIMEModeHangulFull
    3              0.000013 syn keyword vbDefine vbIMEModeHiragana vbIMEModeKatakana
    3              0.000012 syn keyword vbDefine vbIMEModeKatakanaHalf vbIMEModeNoControl
    3              0.000015 syn keyword vbDefine vbIMEModeOff vbIMEModeOn vbIMENoOp vbIMEOff
    3              0.000014 syn keyword vbDefine vbIMEOn vbInactiveBorder vbInactiveCaptionText
    3              0.000015 syn keyword vbDefine vbInactiveTitleBar vbInfoBackground vbInformation
    3              0.000014 syn keyword vbDefine vbInfoText vbInteger vbKatakana vbKey0 vbKey1
    3              0.000019 syn keyword vbDefine vbKey2 vbKey3 vbKey4 vbKey5 vbKey6 vbKey7 vbKey8
    3              0.000031 syn keyword vbDefine vbKey9 vbKeyA vbKeyAdd vbKeyB vbKeyBack vbKeyC
    3              0.000016 syn keyword vbDefine vbKeyCancel vbKeyCapital vbKeyClear vbKeyControl
    3              0.000014 syn keyword vbDefine vbKeyD vbKeyDecimal vbKeyDelete vbKeyDivide
    3              0.000018 syn keyword vbDefine vbKeyDown vbKeyE vbKeyEnd vbKeyEscape vbKeyExecute
    3              0.000019 syn keyword vbDefine vbKeyF vbKeyF1 vbKeyF10 vbKeyF11 vbKeyF12 vbKeyF13
    3              0.000016 syn keyword vbDefine vbKeyF14 vbKeyF15 vbKeyF16 vbKeyF2 vbKeyF3 vbKeyF4
    3              0.000019 syn keyword vbDefine vbKeyF5 vbKeyF6 vbKeyF7 vbKeyF8 vbKeyF9 vbKeyG
    3              0.000016 syn keyword vbDefine vbKeyH vbKeyHelp vbKeyHome vbKeyI vbKeyInsert
    3              0.000014 syn keyword vbDefine vbKeyJ vbKeyK vbKeyL vbKeyLButton vbKeyLeft vbKeyM
    3              0.000015 syn keyword vbDefine vbKeyMButton vbKeyMenu vbKeyMultiply vbKeyN
    3              0.000013 syn keyword vbDefine vbKeyNumlock vbKeyNumpad0 vbKeyNumpad1
    3              0.000013 syn keyword vbDefine vbKeyNumpad2 vbKeyNumpad3 vbKeyNumpad4
    3              0.000016 syn keyword vbDefine vbKeyNumpad5 vbKeyNumpad6 vbKeyNumpad7
    3              0.000014 syn keyword vbDefine vbKeyNumpad8 vbKeyNumpad9 vbKeyO vbKeyP
    3              0.000015 syn keyword vbDefine vbKeyPageDown vbKeyPageUp vbKeyPause vbKeyPrint
    3              0.000016 syn keyword vbDefine vbKeyQ vbKeyR vbKeyRButton vbKeyReturn vbKeyRight
    3              0.000015 syn keyword vbDefine vbKeyS vbKeySelect vbKeySeparator vbKeyShift
    3              0.000022 syn keyword vbDefine vbKeySnapshot vbKeySpace vbKeySubtract vbKeyT
    3              0.000018 syn keyword vbDefine vbKeyTab vbKeyU vbKeyUp vbKeyV vbKeyW vbKeyX
    3              0.000020 syn keyword vbDefine vbKeyY vbKeyZ vbLf vbLong vbLowerCase vbMagenta
    3              0.000014 syn keyword vbDefine vbMaximizedFocus vbMenuBar vbMenuText
    3              0.000014 syn keyword vbDefine vbMinimizedFocus vbMinimizedNoFocus vbMonday
    3              0.000014 syn keyword vbDefine vbMsgBox vbMsgBoxHelpButton vbMsgBoxRight
    3              0.000013 syn keyword vbDefine vbMsgBoxRtlReading vbMsgBoxSetForeground
    3              0.000015 syn keyword vbDefine vbMsgBoxText vbNarrow vbNewLine vbNo vbNormal
    3              0.000014 syn keyword vbDefine vbNormalFocus vbNormalNoFocus vbNull vbNullChar
    3              0.000014 syn keyword vbDefine vbNullString vbObject vbObjectError vbOK
    3              0.000015 syn keyword vbDefine vbOKCancel vbOKOnly vbProperCase vbQuestion
    3              0.000017 syn keyword vbDefine vbReadOnly vbRed vbRetry vbRetryCancel vbSaturday
    3              0.000014 syn keyword vbDefine vbScrollBars vbSingle vbString vbSunday vbSystem
    3              0.000014 syn keyword vbDefine vbSystemModal vbTab vbTextCompare vbThursday
    3              0.000015 syn keyword vbDefine vbTitleBarText vbTuesday vbUnicode vbUpperCase
    3              0.000014 syn keyword vbDefine vbUseSystem vbUseSystemDayOfWeek vbVariant
    3              0.000018 syn keyword vbDefine vbVerticalTab vbVolume vbWednesday vbWhite vbWide
    3              0.000014 syn keyword vbDefine vbWindowBackground vbWindowFrame vbWindowText
    3              0.000016 syn keyword vbDefine vbYellow vbYes vbYesNo vbYesNoCancel
                            
                            "Numbers
                            "integer number, or floating point number without a dot.
    3              0.000029 syn match vbNumber "\<\d\+\>"
                            "floating point number, with dot
    3              0.000016 syn match vbNumber "\<\d\+\.\d*\>"
                            "floating point number, starting with a dot
    3              0.000015 syn match vbNumber "\.\d\+\>"
                            "syn match  vbNumber		"{[[:xdigit:]-]\+}\|&[hH][[:xdigit:]]\+&"
                            "syn match  vbNumber		":[[:xdigit:]]\+"
                            "syn match  vbNumber		"[-+]\=\<\d\+\>"
    3              0.000026 syn match  vbFloat		"[-+]\=\<\d\+[eE][\-+]\=\d\+"
    3              0.000030 syn match  vbFloat		"[-+]\=\<\d\+\.\d*\([eE][\-+]\=\d\+\)\="
    3              0.000033 syn match  vbFloat		"[-+]\=\<\.\d\+\([eE][\-+]\=\d\+\)\="
                            
                            " String and Character contstants
    3              0.000069 syn region  vbString		start=+"+  end=+"\|$+
    3              0.000043 syn region  vbComment		start="\(^\|\s\)REM\s" end="$" contains=vbTodo
    3              0.000039 syn region  vbComment		start="\(^\|\s\)\'"   end="$" contains=vbTodo
    3              0.000024 syn match   vbLineNumber	"^\d\+\(\s\|$\)"
    3              0.000037 syn match   vbTypeSpecifier  "[a-zA-Z0-9][\$%&!#]"ms=s+1
    3              0.000022 syn match   vbTypeSpecifier  "#[a-zA-Z0-9]"me=e-1
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    3              0.000011 if version >= 508 || !exists("did_vb_syntax_inits")
    3              0.000005 	if version < 508
                            		let did_vb_syntax_inits = 1
                            		command -nargs=+ HiLink hi link <args>
                            	else
    3              0.000022 		command -nargs=+ HiLink hi def link <args>
    3              0.000001 	endif
                            
    3              0.000045 	HiLink vbBoolean		Boolean
    3              0.000030 	HiLink vbLineNumber		Comment
    3              0.000025 	HiLink vbComment		Comment
    3              0.000027 	HiLink vbConditional	Conditional
    3              0.000026 	HiLink vbConst			Constant
    3              0.000025 	HiLink vbDefine			Constant
    3              0.000030 	HiLink vbError			Error
    3              0.000026 	HiLink vbFunction		Identifier
    3              0.000030 	HiLink vbIdentifier		Identifier
    3              0.000026 	HiLink vbNumber			Number
    3              0.000024 	HiLink vbFloat			Float
    3              0.000042 	HiLink vbMethods		PreProc
    3              0.000028 	HiLink vbOperator		Operator
    3              0.000025 	HiLink vbRepeat			Repeat
    3              0.000027 	HiLink vbString			String
    3              0.000025 	HiLink vbStatement		Statement
    3              0.000025 	HiLink vbKeyword		Statement
    3              0.000045 	HiLink vbEvents			Special
    3              0.000028 	HiLink vbTodo			Todo
    3              0.000025 	HiLink vbTypes			Type
    3              0.000026 	HiLink vbTypeSpecifier	Type
                            
    3              0.000006 	delcommand HiLink
    3              0.000003 endif
                            
    3              0.000011 let b:current_syntax = "vb"
                            
                            " vim: ts=8

SCRIPT  /Users/klangton/.yadr/vim/bundle/Better-CSS-Syntax-for-Vim/syntax/css.vim
Sourced 4 times
Total time:   0.008021
 Self time:   0.008021

count  total (s)   self (s)
                            " Better CSS Syntax for Vim
                            " Language: Cascading Style Sheets
                            " Maintainer:   Chris Yip <chrisyipw@gmail.com>, twitter: @chrisyipw
                            " URL:  http://www.vim.org/scripts/script.php?script_id=3220
                            " GIT:  http://github.com/ChrisYis/Better-CSS-Syntax-for-Vim
                            " Last Update:  2012/5/29
                            " Full CSS2, most of HTML5 & CSS3 properties (include prefix like -moz-) supported
                            
                            " Quit when a syntax file was already loaded
    4              0.000021 if exists("b:current_syntax")
                              finish
                            endif
                            
    4              0.000007 syn case ignore
    4              0.000207 set iskeyword+=-
                            
    4              0.000135 syn region cssAtkeyword start=/@\(media\|font-face\|page\|keyframes\)/ end=/\ze{/ contains=cssAtType, cssAtkey, cssPseudo, cssValFn, cssValBlock
    4              0.000101 syn region cssAtkeyword start=/@\(import\|charset\|namespace\)/ end=/\ze;/ contains=cssAtType, cssAtkey, cssPseudo, cssValFn, cssValBlock
                            
    4              0.000032 syn keyword cssAtType media import charset font-face page keyframes namespace contained
    4              0.000028 syn keyword cssAtkey all braille embossed handheld print projection screen speech tty tv contained
                            
    4              0.000042 syn region cssValBlock start=/(/ end=/)/ contained contains=cssAtProps
                            
    4              0.000068 syn match cssAtProps /[^()]*/ contained contains=cssMediaProp,cssAtValBlock
    4              0.000022 syn keyword cssMediaProp grid monochrome orientation scan contained
    4              0.000029 syn match cssMediaProp /color\(-index\)\=\ze\s*[:)]/ contained
    4              0.000029 syn match cssMediaProp /\(\(device\)-\)\=aspect-ratio\ze\s*[:)]/ contained
    4              0.000030 syn match cssMediaProp /\(\(max\|min\)-\)\=device-\(height\|width\)\ze\s*[:)]/ contained
    4              0.000026 syn match cssMediaProp /\(\(max\|min\)-\)\=\(height\|width\)\ze\s*[:)]/ contained
                            
    4              0.000142 syn region cssAtValBlock start=/:\zs/ end=/\ze[)]/ contained contains=cssAttr,cssColor,cssImportant,cssNumber,cssUnits,cssQuote,cssFunction
                            
    4              0.000053 syn region cssValFn start=/\<url\s*(/ end=/)\ze/ contained contains=cssPathFn
                            
    4              0.000041 syn match cssTagName /\*/
    4              0.000191 syn keyword cssTagName a abbr acronym address applet area article aside audio b base basefont bdo big blockquote body br button canvas caption center cite code col colgroup command datalist dd del details dfn dir div dl dt em embed fieldset font form figcaption figure footer frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html img i iframe img input ins isindex kbd keygen label legend li link map mark menu meta meter nav noframes noscript object ol optgroup option output p param pre progress q rp rt ruby s samp script section select small span strike strong style sub summary sup table tbody td textarea tfoot th thead time title tr tt ul u var variant video xmp
                            
    4              0.000037 syn match cssClass "\.[A-Za-z][A-Za-z0-9_-]\{0,\}"
                            
    4              0.000032 syn match cssIdentifier "#[A-Za-z_@][A-Za-z0-9_@-]*"
                            
    4              0.000042 syn match cssPrefix /\(-\(webkit\|moz\|o\|ms\)-\)\|filter/
                            
    4              0.000028 syn match cssNumber /\(-\)\=\(\.\d\+\|\d\+\(\.\d\+\)\{0,\}\)/ contained
                            
    4              0.000060 syn match cssPseudo /\:\(child\|link\|visited\|active\|hover\|focus\|left\|right\|root\|empty\|target\|enabled\|disabled\|checked\|indeterminate\|valid\|invalid\|required\|optional\|default\)\>/
    4              0.000023 syn match cssPseudo /\:first\-\(child\)\>/
    4              0.000024 syn match cssPseudo /\:\{1,2\}first\-\(letter\|line\)\>/
    4              0.000024 syn match cssPseudo /\:\(last\|only\)-child\>/
    4              0.000025 syn match cssPseudo /\:\(first\|last\|only\)-of-type\>/
    4              0.000029 syn match cssPseudo /\:nth\(-last\)\{0,1\}-child([0-9]*[n]*)/
    4              0.000028 syn match cssPseudo /\:nth\(-last\)\{0,1\}-of-type([0-9]*[n]*)/
    4              0.000027 syn match cssPseudo /\:not([#\.]\{0,\}\S\+)/
    4              0.000037 syn match cssPseudo /\:lang([a-zA-Z]\{2\}\(-[a-zA-Z]\{2\}\)\{0,1\})\>/
    4              0.000037 syn match cssPseudo /\:read\-\(only\|write\)\>/
    4              0.000026 syn match cssPseudo /\:\{1,2\}\(after\|before\)\>/
    4              0.000028 syn match cssPseudo /\:\{2\}selection\>/
    4              0.000022 syn match cssPseudo /\:\{2\}value\>/
    4              0.000024 syn match cssPseudo /\:\{2\}progress-bar\>/
                            
    4              0.000053 syn region cssFuncRegion start=/{/ end=/}/ contains=cssPropRegion
                            
    4              0.000084 syn match cssPropRegion /[^{}]*/ contained contains=cssProp,cssAttrBlock,cssPrefix,cssComment transparent
                            
    4              0.000121 syn region cssAttrBlock start=/:\zs/ end=/\ze[;}]\{1\}/ contained contains=cssAttr,cssColor,cssImportant,cssNumber,cssUnits,cssQuote,cssFunction
                            
    4              0.000321 syn keyword cssAttr above absolute accent adjacent after alias all alphabetic alternate always auto avoid balance baseline back before behind below blink block bold bolder border both bottom capitalize caption cell center central circle clear clone code collapse compact copy crop cross crosshair current dashed default digits disc discard dot dotted double embed end fast faster fill first fixed forward front hanging help here hidden hide high higher horizontal icon ideographic inherit inhibit initial invert italic justify kashida landscape last left level lighter linear loud low lower ltr mathematical manual medium meet menu middle modal move multiple moderate narrower new none normal nowrap oblique overline parent perceptual pointer portrait progress reduced relative reverse ridge right root rtl same saturation scroll separate show silent single slice slide slow slower solid soft square start static stretch strong sub super suppress tab text thick thin tibetan top underline unrestricted vertical visible wait                             
    4              0.000033 syn match cssAttr /\<transparent\>/ contained
                            
    4              0.000027 syn match cssAttr /\<\(absolute\|relative\)-colorimetric\>/ contained
    4              0.000025 syn match cssAttr /<\(pause\|rest\)-\(after\|before\)\>/ contained
    4              0.000026 syn match cssAttr /\<\(x-\)\=\(weak\|strong\|low\|high\)\>/ contained
    4              0.000028 syn match cssAttr /\(in\|out\)\(set\|side\)/ contained
    4              0.000028 syn match cssAttr /\<\(block\|inline\)-axis\>/ contained
    4              0.000021 syn match cssAttr /\<\(border\|content\)-box\>/ contained
    4              0.000026 syn match cssAttr /\<x-\(loud\|soft\|slow\|fast\|low\|high\)\>/ contained
    4              0.000124 syn match cssAttr /\<context-menu\|not-allowed\|vertical-text\|all-scroll\|from-image\|spell-out\|line-through\|bidi-override\|keep-all\>/ contained
    4              0.000036 syn match cssAttr /\<inline\(-\(block\|table\)\)\{0,1\}\>/ contained
    4              0.000036 syn match cssAttr /\<table\(-\(caption\|cell\|column\|row\)\)\{0,1\}\>/ contained
    4              0.000029 syn match cssAttr /\<table\(-\(column\|footer\|header\|row\)-group\)\>/ contained
    4              0.000032 syn match cssAttr /\<ruby\(-\(base\|text\)\(-group\)\{0,1\}\)\{0,1\}\>/ contained
    4              0.000023 syn match cssAttr /\<\(exclude\|include\)-ruby\>/ contained
    4              0.000024 syn match cssAttr /\<\(consider\|disregard\)-shifts\>/ contained
    4              0.000022 syn match cssAttr /\<list-item\|run-in\>/ contained
    4              0.000032 syn match cssAttr /\<\(\(\(block\|inline\)-line\)\|max\|grid\)-height\>/ contained
    4              0.000023 syn match cssAttr /\<\(far\|left\|right\)-side\>/ contained
    4              0.000085 syn match cssAttr /\<\(left\|right\)wards\>/ contained
    4              0.000030 syn match cssAttr /\<\(center\|far\)-\(left\|right\)\>/ contained
    4              0.000041 syn match cssAttr /\<\(\(text-\)\=\(before\|after\)-\(edge\|central\|ideographic\|alphabetic\|hanging\|mathematical\|use-script\)\)\>/ contained
    4              0.000037 syn match cssAttr /\<\([nwse]\{1,4\}\|col\|row\)-resize\>/ contained
    4              0.000036 syn match cssAttr /\<use-scriot\|reset-size\|caps-height\|status-bar\|message-box\>/ contained
    4              0.000022 syn match cssAttr /\<small-\(caps\|caption\)\>/ contained
    4              0.000031 syn match cssAttr /\<\(\(ultra\|extra\|semi\)-\)\=\(condensed\|expanded\)\>/ contained
    4              0.000042 syn match cssAttr /\<no-\(change\|content\|display\|drop\|limit\|repeat\)\>/ contained
    4              0.000021 syn match cssAttr /\<repeat\(-\(x\|y\)\)\=\>/ contained
    4              0.000037 syn match cssAttr /\<\(end\|line\)-edge\>/ contained
    4              0.000071 syn match cssAttr /\<break-\(all\|word\|strict\)\>/ contained
    4              0.000028 syn match cssAttr /\<\(upper\|lower\)case\>/ contained
    4              0.000027 syn match cssAttr /\<distribute\(-\(letter\|space\)\)\=\>/ contained
    4              0.000030 syn match cssAttr /\<\(literal\|no\)-punctuation\>/ contained
    4              0.000025 syn match cssAttr /\<inter-\(word\|ideograph\|cluster\)\>/ contained
    4              0.000022 syn match cssAttr /\<\(font\|text\|max\)-size\>/ contained
    4              0.000024 syn match cssAttr /\<ease\(-\(in\|out\|in-out\)\)\=\>/ contained
    4              0.000022 syn match cssAttr /\<text-\(top\|bottom\)\>/ contained
    4              0.000031 syn match cssAttr /\<pre\(-\(wrap\|line\)\)\=\>/ contained
    4              0.000023 syn match cssAttr /\<preserve\(-\(breaks\)\)\=\>/ contained
                            
    4              0.000255 syn match cssProp /\(appearance\|backface-visibility\|binding\|bottom\|clear\|clip\|color\|columns\|content\|crop\|cursor\|direction\|elevation\|empty-cells\|hanging-punctuation\|height\|hyphens\|icon\|inline-box-align\|left\|letter-spacing\|move-to\|nbsp-mode\|opacity\|orphans\|phonemes\|position\|play-during\|presentation-level\|punctuation-trim\|quotes\|rendering-intent\|resize\|richness\|right\|size\|speech-rate\|src\|stress\|string-set\|tab-size\|table-layout\|top\|unicode-bidi\|vertical-align\|visibility\|volume\|widows\|width\|z-index\|zimuth\)\ze\s*:/ contained
                            
    4              0.000040 syn match cssProp /\(\<\|\)alignment-\(adjust\|baseline\)\>\ze\s*:/ contained
    4              0.000055 syn match cssProp /\(\<\|\)animation\(-\(delay\|direction\|duration\|iteration-count\|name\|play-state\|timing-function\)\)\{0,1\}\>\ze\s*:/ contained
    4              0.000053 syn match cssProp /\(\<\|\)background\(-\(attachment\|break\|clip\|color\|image\|origin\|position\|repeat\|size\)\)\{0,1\}\>\ze\s*:/ contained
    4              0.000035 syn match cssProp /\(\<\|\)baseline-shift\|caption-side\|color-profile\>\ze\s*:/ contained
    4              0.000028 syn match cssProp /\(\<\|\)bookmark-\(label\|level\|target\)\>\ze\s*:/ contained
    4              0.000058 syn match cssProp /\(\<\|\)border\(-\(bottom\|collapse\|color\|image\|left\|length\|radius\|right\|spacing\|style\|top\|width\)\)\{0,1\}\>\ze\s*:/ contained
    4              0.000051 syn match cssProp /\(\<\|\)border\(-\(bottom\|left\|right\|top\)\(-\(color\|style\|wdith\)\)\{0,1\}\)\{0,1\}\>\ze\s*:/ contained
    4              0.000035 syn match cssProp /\(\<\|\)border-\(bottom\|top\)-\(left\|right\)-radius\>\ze\s*:/ contained
    4              0.000049 syn match cssProp /\(\<\|\)box-\(align\|decoration-break\|direction\|flex\|\(flex\|ordinal\)-group\|lines\|orient\|pack\|shadow\|sizing\)\>\ze\s*:/ contained
    4              0.000068 syn match cssProp /\(\<\|\)column\(-\(\break-\(after\|before\)\|count\|fill\|gap\|rule\(-\(color\|style\|width\)\)\{0,1\}\)\|span\|width\)\>\ze\s*:/ contained
    4              0.000030 syn match cssProp /\(\<\|\)counter-\(increment\|reset\)\>\ze\s*:/ contained
    4              0.000030 syn match cssProp /\(\<\|\)cue\(-\(after\|before\)\)\{0,1\}\>\ze\s*:/ contained
    4              0.000029 syn match cssProp /\(\<\|\)display\(-\(model\|role\)\)\{0,1\}\>\ze\s*:/ contained
    4              0.000025 syn match cssProp /\(\<\|\)dominant-baseline\>\ze\s*:/ contained
    4              0.000037 syn match cssProp /\(\<\|\)drop-initial-\(\(\(after\|before\)-\(adjust\|align\)\)\|size\|value\)\>\ze\s*:/ contained
    4              0.000026 syn match cssProp /\(\<\|\)fit\(-position\)\{0,1\}\>\ze\s*:/ contained
    4              0.000037 syn match cssProp /\(\<\|\)float\>\(-offset\)\{0,1\}\ze\s*:/ contained
    4              0.000042 syn match cssProp /\(\<\|\)font\(-\(family\|size\(-adjust\)\=\|stretch\|style\|variant\|weight\)\)\=\>\ze\s*:/ contained
    4              0.000032 syn match cssProp /\(\<\|\)grid-\(columns\|rows\)\>\ze\s*:/ contained
    4              0.000038 syn match cssProp /\(\<\|\)hyphenate-\(after\|before\|character\|lines\|resource\)\>\ze\s*:/ contained
    4              0.000036 syn match cssProp /\(\<\|\)image-\(orientation\|resolution\)\>\ze\s*:/ contained
    4              0.000039 syn match cssProp /\(\<\|\)line-\(height\|stacking\(-\(ruby\|shift\|strategy\)\)\=\)\>\ze\s*:/ contained
    4              0.000036 syn match cssProp /\(\<\|\)list-style\(-\(image\|position\|type\)\)\=\>\ze\s*:/ contained
    4              0.000033 syn match cssProp /\(\<\|\)\(margin\|padding\)\(-\(bottom\|left\|right\|start\|top\)\)\=\>\ze\s*:/ contained
    4              0.000029 syn match cssProp /\(\<\|\)mark\(s\|-\(after\|before\)\)\=\>\ze\s*:/ contained
    4              0.000027 syn match cssProp /\(\<\|\)\(max\|min\)-\(height\|width\)\>\ze\s*:/ contained
    4              0.000029 syn match cssProp /\(\<\|\)nav-\(down\|index\|left\|right\|up\)\>\ze\s*:/ contained
    4              0.000030 syn match cssProp /\(\<\|\)outline\(-\(color\|offset\|style\|width\)\)\=\>\ze\s*:/ contained
    4              0.000026 syn match cssProp /\(\<\|\)overflow\(-\(style\|x\|y\)\)\=\>\ze\s*:/ contained
    4              0.000038 syn match cssProp /\(\<\|\)page\(-\(break-\(after\|before\|inside\)\|policy\)\)\=\>\ze\s*:/ contained
    4              0.000027 syn match cssProp /\(\<\|\)pause\(-\(after\|before\)\)\=\>\ze\s*:/ contained
    4              0.000024 syn match cssProp /\(\<\|\)pitch\(-range\)\=\>\ze\s*:/ contained
    4              0.000027 syn match cssProp /\(\<\|\)rest\(-\(after\|before\)\)\=\>\ze\s*:/ contained
    4              0.000024 syn match cssProp /\(\<\|\)rotation\(-point\)\=\>\ze\s*:/ contained
    4              0.000030 syn match cssProp /\(\<\|\)ruby-\(align\|overhang\|position\|span\)\>\ze\s*:/ contained
    4              0.000038 syn match cssProp /\(\<\|\)speak\(-\(header\|numeral\|punctuation\)\)\=\>\ze\s*:/ contained
    4              0.000030 syn match cssProp /\(\<\|\)target\(-\(name\|new\|position\)\)\=\>\ze\s*:/ contained
    4              0.000051 syn match cssProp /\(\<\|\)text-\(align\(-last\)\=\|decoration\|emphasis\|height\|indent\|justify\|outline\|replace\|shadow\|transform\|wrap\|overflow\)\>\ze\s*:/ contained
    4              0.000035 syn match cssProp /\(\<\|\)transition\(-\(delay\|duration\|property\|timing-function\)\)\=\>\ze\s*:/ contained
    4              0.000041 syn match cssProp /\(\<\|\)voice-\(balance\|duration\|family\|pitch\(-range\)\=\|rate\|stress\|volume\)\>\ze\s*:/ contained
    4              0.000025 syn match cssProp /\(\<\|\)white-space\(-collapse\)\=\>\ze\s*:/ contained
    4              0.000051 syn match cssProp /\(\<\|\)word-\(break\|spacing\|wrap\)\>\ze\s*:/ contained
    4              0.000027 syn match cssProp /\(\<\|\)user-\(drag\|modify\|select\)\>\ze\s*:/ contained
    4              0.000039 syn match cssProp /\(\<\|\)marquee\(-\(direction\|play-count\|loop\|increment\|repetition\|speed\|style\)\)\>\ze\s*:/ contained
    4              0.000050 syn match cssProp /\(\<\|\)mask\(-\(attachment\|box-image\|clip\|composite\|image\|position\|position-x\|position-y\|size\|repeat\|origin\)\)\>\ze\s*:/ contained
    4              0.000036 syn match cssProp /\(\<\|\)transform\(-\(origin\|origin-x\|origin-y\|origin-z\|style\)\)\>\ze\s*:/ contained
                            
    4              0.000055 syn match cssSelector /\[[#\.]\{0,1\}\c[-a-z0-9]\+\([*^$]\{0,1\}=\c[-a-z0-9_'"]\+\)*\]/
                            
    4              0.000042 syn match cssUnits /\d\@<=\(%\|cm\|deg\|dpi\|dpcm\|em\|ex\|\in\|mm\|pc\|pt\|px\|s\)\ze\s*[,;)}]\=/ contained
                            
    4              0.000027 syn match cssColor /#\(\x\{6\}\|\x\{3\}\)/ contained
                            
    4              0.000051 syn match cssImportant /!important\>/ contained
                            
    4              0.000043 syn region cssComment start=/\/\*/ end=/\*\// contains=@Spell
                            
    4              0.000084 syn region cssFunction start=/\c[-a-z0-9@]*(/ end=/)/ contained contains=cssPathFn,cssAttValFn
                            
    4              0.000044 syn region cssPathFn start=/\<\(url\|format\)\s*(\zs/ end=/\ze)/ contained
                            
    4              0.000062 syn region cssAttValFn start=/\<\(rotate\|rgba\|rgb\|hsl\|hsla\)\s*(\zs/ end=/\ze)/ contained contains=cssNumber,cssUnits
                            
    4              0.000026 syn match cssBraket /[{}]/ contained
                            
    4              0.000049 syn match cssQuote /\('.*'\|".*"\)/ contained
                            
                            " Define the default highlighting.
    4              0.000034 command -nargs=+ HLink hi def link <args>
                            
    4              0.000058 HLink cssAtkeyword Constant
    4              0.000041 HLink cssAtType Identifier
    4              0.000039 HLink cssAtkey Special
    4              0.000035 HLink cssMediaProp Type
    4              0.000034 HLink cssAtProps Function
                            
    4              0.000035 HLink cssAttr SpecialKey
                            
    4              0.000036 HLink cssAttValFn Function
                            
    4              0.000050 HLink cssValBlock Function
    4              0.000036 HLink cssValFn Function
                            
    4              0.000038 HLink cssAttrBlock Normal
                            
    4              0.000033 HLink cssBraket Function
                            
    4              0.000036 HLink cssClass Function
                            
    4              0.000036 HLink cssColor Constant
                            
    4              0.000035 HLink cssComment Comment
                            
    4              0.000040 HLink cssError ErrorMsg
                            
    4              0.000037 HLink cssPathFn Directory
                            
    4              0.000035 HLink cssFunction Function
    4              0.000038 HLink cssFnValBlock Function
                            
    4              0.000034 HLink cssFuncRegion Function
                            
    4              0.000034 HLink cssIdentifier Identifier
                            
    4              0.000035 HLink cssImportant PreProc
                            
    4              0.000037 HLink cssUnits Special
                            
    4              0.000035 HLink cssNumber Number
                            
    4              0.000033 HLink cssPrefix Special
                            
    4              0.000045 HLink cssProp Type
                            
    4              0.000042 HLink cssPropRegion Normal
                            
    4              0.000036 HLink cssPseudo Structure
                            
    4              0.000041 HLink cssQuote String
                            
    4              0.000034 HLink cssSelector Structure
                            
    4              0.000038 HLink cssString String
                            
    4              0.000034 HLink cssTagName Statement
                            
    4              0.000038 HLink cssURL String
                            
    4              0.000008 delcommand HLink
                            
    4              0.000015 let b:current_syntax = "css"
    4              0.000022 syn sync minlines=10

SCRIPT  /usr/local/Cellar/macvim/7.4-73/MacVim.app/Contents/Resources/vim/runtime/syntax/css.vim
Sourced 4 times
Total time:   0.000119
 Self time:   0.000119

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Cascading Style Sheets
                            " Previous Contributor List:
                            "               Claudio Fleiner <claudio@fleiner.com> (Maintainer)
                            "               Yeti            (Add full CSS2, HTML4 support)
                            "               Nikolai Weibull (Add CSS2 support)
                            " Maintainer:   Jules Wang      <w.jq0722@gmail.com>
                            " URL:          https://github.com/JulesWang/css.vim
                            " Last Change:  2013 Nov.27
                            
                            " For version 5.x: Clear all syntax items
                            " For version 6.x: Quit when a syntax file was already loaded
    4              0.000023 if !exists("main_syntax")
                              if version < 600
                                syntax clear
                              elseif exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'css'
                            elseif exists("b:current_syntax") && b:current_syntax == "css"
    4              0.000004   finish

SCRIPT  /Users/klangton/.yadr/vim/bundle/vim-css-color/after/syntax/css.vim
Sourced 4 times
Total time:  13.098989
 Self time:   0.015928

count  total (s)   self (s)
                            " Language:     Colored CSS Color Preview
                            " Author:       Max Vasiliev <vim@skammer.name>
                            " Last Change:  2010 Jul 3
                            " Licence:      No Warranties. WTFPL. But please tell me!
                            " Version:      0.7.1
                            
    4              0.000021 function! s:StrLen(str)
                              return strlen(substitute(a:str, '.', 'x', 'g'))
                            endfunction
                            
    4              0.000008 function! s:FGforBG(bg)
                              " takes a 6hex color code and returns a matching color that is visible
                              let pure = substitute(a:bg,'^#','','')
                              let r = eval('0x'.pure[0].pure[1])
                              let g = eval('0x'.pure[2].pure[3])
                              let b = eval('0x'.pure[4].pure[5])
                              if r*30 + g*59 + b*11 > 12000
                                return '#000000'
                              else
                                return '#ffffff'
                              end
                            endfunction
                            
    4              0.000008 function! s:SetMatcher(clr,pat)
                              let group = 'cssColor'.substitute(a:clr,'^#','','')
                              redir => s:currentmatch
                              silent! exe 'syn list '.group
                              redir END
                              if s:currentmatch !~ a:pat.'\/'
                                exe 'syn match '.group.' /'.a:pat.'/ contained'
                                exe 'syn cluster cssColors add='.group
                                if has('gui_running')
                                  exe 'hi '.group.' guifg='.s:FGforBG(a:clr)
                                  exe 'hi '.group.' guibg='.a:clr
                                elseif &t_Co == 256
                                  exe 'hi '.group.' ctermfg='.s:Rgb2xterm(s:FGforBG(a:clr))
                                  exe 'hi '.group.' ctermbg='.s:Rgb2xterm(a:clr)
                                endif
                                return 1
                              else
                                return 0
                              endif
                            endfunction
                            
                            "" the 6 value iterations in the xterm color cube
    4              0.000021 let s:valuerange = [ 0x00, 0x5F, 0x87, 0xAF, 0xD7, 0xFF ]
                            "
                            "" 16 basic colors
    4              0.000091 let s:basic16 = [ [ 0x00, 0x00, 0x00 ], [ 0xCD, 0x00, 0x00 ], [ 0x00, 0xCD, 0x00 ], [ 0xCD, 0xCD, 0x00 ], [ 0x00, 0x00, 0xEE ], [ 0xCD, 0x00, 0xCD ], [ 0x00, 0xCD, 0xCD ], [ 0xE5, 0xE5, 0xE5 ], [ 0x7F, 0x7F, 0x7F ], [ 0xFF, 0x00, 0x00 ], [ 0x00, 0xFF, 0x00 ], [ 0xFF, 0xFF, 0x00 ], [ 0x5C, 0x5C, 0xFF ], [ 0xFF, 0x00, 0xFF ], [ 0x00, 0xFF, 0xFF ], [ 0xFF, 0xFF, 0xFF ] ]
                            :
    4              0.000010 function! s:Xterm2rgb(color)
                              " 16 basic colors
                              let r=0
                              let g=0
                              let b=0
                              if a:color<16
                                let r = s:basic16[a:color][0]
                                let g = s:basic16[a:color][1]
                                let b = s:basic16[a:color][2]
                              endif
                            
                              " color cube color
                              if a:color>=16 && a:color<=232
                                let color=a:color-16
                                let r = s:valuerange[(color/36)%6]
                                let g = s:valuerange[(color/6)%6]
                                let b = s:valuerange[color%6]
                              endif
                            
                              " gray tone
                              if a:color>=233 && a:color<=253
                                let r=8+(a:color-232)*0x0a
                                let g=r
                                let b=r
                              endif
                              let rgb=[r,g,b]
                              return rgb
                            endfunction
                            
    4              0.000010 function! s:pow(x, n)
                              let x = a:x
                              for i in range(a:n-1)
                                let x = x*a:x
                              return x
                            endfunction
                            
    4              0.000367 let s:colortable=[]
 1024              0.000899 for c in range(0, 254)
 1020   0.032937   0.003844   let color = s:Xterm2rgb(c)
 1020              0.002191   call add(s:colortable, color)
 1020              0.000840 endfor
                            
                            " selects the nearest xterm color for a rgb value like #FF0000
    4              0.000008 function! s:Rgb2xterm(color)
                              let best_match=0
                              let smallest_distance = 10000000000
                              let r = eval('0x'.a:color[1].a:color[2])
                              let g = eval('0x'.a:color[3].a:color[4])
                              let b = eval('0x'.a:color[5].a:color[6])
                              for c in range(0,254)
                                let d = s:pow(s:colortable[c][0]-r,2) + s:pow(s:colortable[c][1]-g,2) + s:pow(s:colortable[c][2]-b,2)
                                if d<smallest_distance
                                  let smallest_distance = d
                                  let best_match = c
                                endif
                              endfor
                              return best_match
                            endfunction
                            
    4              0.000011 function! s:SetNamedColor(clr,name)
                              let group = 'cssColor'.substitute(a:clr,'^#','','')
                              exe 'syn keyword '.group.' '.a:name.' contained'
                              exe 'syn cluster cssColors add='.group
                              if has('gui_running')
                                exe 'hi '.group.' guifg='.s:FGforBG(a:clr)
                                exe 'hi '.group.' guibg='.a:clr
                              elseif &t_Co == 256
                                exe 'hi '.group.' ctermfg='.s:Rgb2xterm(s:FGforBG(a:clr))
                                exe 'hi '.group.' ctermbg='.s:Rgb2xterm(a:clr)
                              endif
                              return 23
                            endfunction
                            
                            " shamelessly stolen from ConvertBase.vim
                            " http://www.vim.org/scripts/script.php?script_id=54
    4              0.000008 function! s:ConvertToBase(int, base)
                              if (a:base < 2 || a:base > 36)
                                echohl ErrorMsg
                                echo "Bad base - must be between 2 and 36."
                                echohl None
                                return ''
                              endif
                            
                              if (a:int == 0)
                                return 0
                              endif
                            
                              let out=''
                            
                              let isnegative = 0
                              let int=a:int
                              if (int < 0)
                                let isnegative = 1
                                let int = - int
                              endif
                            
                              while (int != 0)
                                let out = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[(int % a:base)] . out
                                let int = int / a:base
                              endwhile
                            
                              if isnegative
                                let out = '-' . out
                              endif
                            
                              return out
                            endfunction
                            
                            " Convert 80% -> 204, 100% -> 255, etc.
                            " This piece of code was ported from lisp.
                            " http://julien.danjou.info/rainbow-mode.html
    4              0.000020 fun! s:RGBRelativeToAbsolute(value)
                              let string_length = s:StrLen(a:value)-1
                              if strpart(a:value, string_length, 1) == '%'
                                let hex_value = s:ConvertToBase(  255*strpart(a:value, 0, string_length)/100, 16 )
                                if len(hex_value) == 1
                                  return "0".hex_value
                                endif
                                return hex_value
                              else
                                let hex_value = s:ConvertToBase( a:value, 16 )
                                if len( hex_value ) == 1
                                  return "0".hex_value
                                else
                                  return hex_value
                                endif
                              endif
                            endf
                            
    4              0.000011 function! s:PreviewCSSColorInLine(where)
                              " TODO use cssColor matchdata
                              let n = 1
                              let foundcolor = matchstr( getline(a:where), '#[0-9A-Fa-f]\{3,6\}\>' )
                              while foundcolor != ''
                                if foundcolor =~ '#\x\{6}$'
                                  let color = foundcolor
                                elseif foundcolor =~ '#\x\{3}$'
                                  let color = substitute(foundcolor, '\(\x\)\(\x\)\(\x\)', '\1\1\2\2\3\3', '')
                                else
                                  let color = ''
                                endif
                            
                                if color != ''
                                  call s:SetMatcher(color,foundcolor)
                                endif
                            
                                let n+=1
                                let foundcolor = matchstr( getline(a:where), '#[0-9A-Fa-f]\{3,6}', 0, n )
                              endwhile
                            
                            
                              let n = 1
                              let foundcolorlist = matchlist( getline(a:where), 'rgb[a]\=(\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\).\{-})', 0, n )
                              while len(foundcolorlist) != 0
                                  let foundcolorlist[1] = s:RGBRelativeToAbsolute( foundcolorlist[1] )
                                  let foundcolorlist[2] = s:RGBRelativeToAbsolute( foundcolorlist[2] )
                                  let foundcolorlist[3] = s:RGBRelativeToAbsolute( foundcolorlist[3] )
                            
                                  let color = "#".join( foundcolorlist[1:3], "" )
                            
                                  call s:SetMatcher( color, foundcolorlist[0] )
                            
                                  let n+=1
                                  let foundcolorlist = matchlist( getline(a:where), 'rgb[a]\=(\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\).\{-})', 0, n )
                              endw
                              return 0
                            endfunction
                            
    4              0.000026 if has("gui_running") || &t_Co==256
                              " HACK modify cssDefinition to add @cssColors to its contains
    4              0.000013   redir => s:olddef
    4              0.000074   silent!  syn list cssDefinition
    4              0.000016   redir END
    4              0.000017   if s:olddef != ''
    4              0.000035     let s:b = strridx(s:olddef,'matchgroup')
    4              0.000008     if s:b != -1
                                  exe 'syn region cssDefinition '.strpart(s:olddef,s:b).',@cssColors'
                                endif
    4              0.000004   endif
                            
                              " w3c Colors
    4   0.085071   0.000041   let i = s:SetNamedColor('#800000', 'maroon')
    4   0.084902   0.000028   let i = s:SetNamedColor('#ff0000', 'red')
    4   0.084725   0.000028   let i = s:SetNamedColor('#ffA500', 'orange')
    4   0.084843   0.000032   let i = s:SetNamedColor('#ffff00', 'yellow')
    4   0.085014   0.000027   let i = s:SetNamedColor('#808000', 'olive')
    4   0.084523   0.000025   let i = s:SetNamedColor('#800080', 'purple')
    4   0.084588   0.000026   let i = s:SetNamedColor('#ff00ff', 'fuchsia')
    4   0.084825   0.000033   let i = s:SetNamedColor('#ffffff', 'white')
    4   0.085173   0.000027   let i = s:SetNamedColor('#00ff00', 'lime')
    4   0.085579   0.000029   let i = s:SetNamedColor('#008000', 'green')
    4   0.087614   0.000027   let i = s:SetNamedColor('#000080', 'navy')
    4   0.085721   0.000039   let i = s:SetNamedColor('#0000ff', 'blue')
    4   0.085608   0.000044   let i = s:SetNamedColor('#00ffff', 'aqua')
    4   0.085644   0.000031   let i = s:SetNamedColor('#008080', 'teal')
    4   0.084857   0.000028   let i = s:SetNamedColor('#000000', 'black')
    4   0.084621   0.000026   let i = s:SetNamedColor('#c0c0c0', 'silver')
    4   0.084549   0.000028   let i = s:SetNamedColor('#808080', 'gray')
                            
                              " extra colors
    4   0.084807   0.000024   let i = s:SetNamedColor('#F0F8FF','AliceBlue')
    4   0.088497   0.000030   let i = s:SetNamedColor('#FAEBD7','AntiqueWhite')
    4   0.090825   0.000032   let i = s:SetNamedColor('#7FFFD4','Aquamarine')
    4   0.085771   0.000031   let i = s:SetNamedColor('#F0FFFF','Azure')
    4   0.086159   0.000030   let i = s:SetNamedColor('#F5F5DC','Beige')
    4   0.085426   0.000029   let i = s:SetNamedColor('#FFE4C4','Bisque')
    4   0.085085   0.000028   let i = s:SetNamedColor('#FFEBCD','BlanchedAlmond')
    4   0.084493   0.000026   let i = s:SetNamedColor('#8A2BE2','BlueViolet')
    4   0.084322   0.000027   let i = s:SetNamedColor('#A52A2A','Brown')
    4   0.084688   0.000025   let i = s:SetNamedColor('#DEB887','BurlyWood')
    4   0.084945   0.000023   let i = s:SetNamedColor('#5F9EA0','CadetBlue')
    4   0.085299   0.000029   let i = s:SetNamedColor('#7FFF00','Chartreuse')
    4   0.085390   0.000026   let i = s:SetNamedColor('#D2691E','Chocolate')
    4   0.085077   0.000026   let i = s:SetNamedColor('#FF7F50','Coral')
    4   0.085282   0.000028   let i = s:SetNamedColor('#6495ED','CornflowerBlue')
    4   0.085092   0.000026   let i = s:SetNamedColor('#FFF8DC','Cornsilk')
    4   0.085048   0.000028   let i = s:SetNamedColor('#DC143C','Crimson')
    4   0.084689   0.000025   let i = s:SetNamedColor('#00FFFF','Cyan')
    4   0.084994   0.000023   let i = s:SetNamedColor('#00008B','DarkBlue')
    4   0.084982   0.000107   let i = s:SetNamedColor('#008B8B','DarkCyan')
    4   0.085608   0.000027   let i = s:SetNamedColor('#B8860B','DarkGoldenRod')
    4   0.084941   0.000028   let i = s:SetNamedColor('#A9A9A9','DarkGray')
    4   0.084720   0.000026   let i = s:SetNamedColor('#A9A9A9','DarkGrey')
    4   0.085255   0.000025   let i = s:SetNamedColor('#006400','DarkGreen')
    4   0.088785   0.000026   let i = s:SetNamedColor('#BDB76B','DarkKhaki')
    4   0.085492   0.000029   let i = s:SetNamedColor('#8B008B','DarkMagenta')
    4   0.085382   0.000042   let i = s:SetNamedColor('#556B2F','DarkOliveGreen')
    4   0.085122   0.000041   let i = s:SetNamedColor('#FF8C00','Darkorange')
    4   0.085311   0.000027   let i = s:SetNamedColor('#9932CC','DarkOrchid')
    4   0.085148   0.000026   let i = s:SetNamedColor('#8B0000','DarkRed')
    4   0.084955   0.000027   let i = s:SetNamedColor('#E9967A','DarkSalmon')
    4   0.084765   0.000027   let i = s:SetNamedColor('#8FBC8F','DarkSeaGreen')
    4   0.084762   0.000026   let i = s:SetNamedColor('#483D8B','DarkSlateBlue')
    4   0.084868   0.000026   let i = s:SetNamedColor('#2F4F4F','DarkSlateGray')
    4   0.084768   0.000026   let i = s:SetNamedColor('#2F4F4F','DarkSlateGrey')
    4   0.086429   0.000029   let i = s:SetNamedColor('#00CED1','DarkTurquoise')
    4   0.094654   0.000031   let i = s:SetNamedColor('#9400D3','DarkViolet')
    4   0.086230   0.000031   let i = s:SetNamedColor('#FF1493','DeepPink')
    4   0.084902   0.000030   let i = s:SetNamedColor('#00BFFF','DeepSkyBlue')
    4   0.085346   0.000028   let i = s:SetNamedColor('#696969','DimGray')
    4   0.088709   0.000025   let i = s:SetNamedColor('#696969','DimGrey')
    4   0.085077   0.000026   let i = s:SetNamedColor('#1E90FF','DodgerBlue')
    4   0.085460   0.000028   let i = s:SetNamedColor('#B22222','FireBrick')
    4   0.084710   0.000027   let i = s:SetNamedColor('#FFFAF0','FloralWhite')
    4   0.084604   0.000026   let i = s:SetNamedColor('#228B22','ForestGreen')
    4   0.085668   0.000028   let i = s:SetNamedColor('#DCDCDC','Gainsboro')
    4   0.085266   0.000025   let i = s:SetNamedColor('#F8F8FF','GhostWhite')
    4   0.084687   0.000025   let i = s:SetNamedColor('#FFD700','Gold')
    4   0.090887   0.000028   let i = s:SetNamedColor('#DAA520','GoldenRod')
    4   0.086987   0.000029   let i = s:SetNamedColor('#808080','Grey')
    4   0.084790   0.000030   let i = s:SetNamedColor('#ADFF2F','GreenYellow')
    4   0.085162   0.000027   let i = s:SetNamedColor('#F0FFF0','HoneyDew')
    4   0.085000   0.000027   let i = s:SetNamedColor('#FF69B4','HotPink')
    4   0.085261   0.000026   let i = s:SetNamedColor('#CD5C5C','IndianRed')
    4   0.084752   0.000025   let i = s:SetNamedColor('#4B0082','Indigo')
    4   0.084521   0.000024   let i = s:SetNamedColor('#FFFFF0','Ivory')
    4   0.084702   0.000039   let i = s:SetNamedColor('#F0E68C','Khaki')
    4   0.084621   0.000040   let i = s:SetNamedColor('#E6E6FA','Lavender')
    4   0.085092   0.000028   let i = s:SetNamedColor('#FFF0F5','LavenderBlush')
    4   0.084453   0.000026   let i = s:SetNamedColor('#7CFC00','LawnGreen')
    4   0.084847   0.000026   let i = s:SetNamedColor('#FFFACD','LemonChiffon')
    4   0.085041   0.000026   let i = s:SetNamedColor('#ADD8E6','LightBlue')
    4   0.085391   0.000025   let i = s:SetNamedColor('#F08080','LightCoral')
    4   0.085625   0.000024   let i = s:SetNamedColor('#E0FFFF','LightCyan')
    4   0.084892   0.000027   let i = s:SetNamedColor('#FAFAD2','LightGoldenRodYellow')
    4   0.084717   0.000028   let i = s:SetNamedColor('#D3D3D3','LightGray')
    4   0.085050   0.000026   let i = s:SetNamedColor('#D3D3D3','LightGrey')
    4   0.084897   0.000025   let i = s:SetNamedColor('#90EE90','LightGreen')
    4   0.084791   0.000025   let i = s:SetNamedColor('#FFB6C1','LightPink')
    4   0.084848   0.000027   let i = s:SetNamedColor('#FFA07A','LightSalmon')
    4   0.085022   0.000027   let i = s:SetNamedColor('#20B2AA','LightSeaGreen')
    4   0.088570   0.000028   let i = s:SetNamedColor('#87CEFA','LightSkyBlue')
    4   0.085172   0.000027   let i = s:SetNamedColor('#778899','LightSlateGray')
    4   0.085065   0.000028   let i = s:SetNamedColor('#778899','LightSlateGrey')
    4   0.084842   0.000027   let i = s:SetNamedColor('#B0C4DE','LightSteelBlue')
    4   0.084864   0.000024   let i = s:SetNamedColor('#FFFFE0','LightYellow')
    4   0.084846   0.000022   let i = s:SetNamedColor('#32CD32','LimeGreen')
    4   0.084885   0.000025   let i = s:SetNamedColor('#FAF0E6','Linen')
    4   0.084731   0.000026   let i = s:SetNamedColor('#FF00FF','Magenta')
    4   0.084432   0.000025   let i = s:SetNamedColor('#66CDAA','MediumAquaMarine')
    4   0.084806   0.000024   let i = s:SetNamedColor('#0000CD','MediumBlue')
    4   0.086527   0.000028   let i = s:SetNamedColor('#BA55D3','MediumOrchid')
    4   0.085078   0.000028   let i = s:SetNamedColor('#9370D8','MediumPurple')
    4   0.086021   0.000027   let i = s:SetNamedColor('#3CB371','MediumSeaGreen')
    4   0.085122   0.000030   let i = s:SetNamedColor('#7B68EE','MediumSlateBlue')
    4   0.085072   0.000028   let i = s:SetNamedColor('#00FA9A','MediumSpringGreen')
    4   0.085906   0.000039   let i = s:SetNamedColor('#48D1CC','MediumTurquoise')
    4   0.087624   0.000043   let i = s:SetNamedColor('#C71585','MediumVioletRed')
    4   0.085022   0.000031   let i = s:SetNamedColor('#191970','MidnightBlue')
    4   0.085100   0.000025   let i = s:SetNamedColor('#F5FFFA','MintCream')
    4   0.084643   0.000025   let i = s:SetNamedColor('#FFE4E1','MistyRose')
    4   0.085764   0.000027   let i = s:SetNamedColor('#FFE4B5','Moccasin')
    4   0.085374   0.000027   let i = s:SetNamedColor('#FFDEAD','NavajoWhite')
    4   0.088151   0.000030   let i = s:SetNamedColor('#FDF5E6','OldLace')
    4   0.093839   0.000034   let i = s:SetNamedColor('#6B8E23','OliveDrab')
    4   0.091900   0.000032   let i = s:SetNamedColor('#FF4500','OrangeRed')
    4   0.085009   0.000031   let i = s:SetNamedColor('#DA70D6','Orchid')
    4   0.084789   0.000026   let i = s:SetNamedColor('#EEE8AA','PaleGoldenRod')
    4   0.085198   0.000026   let i = s:SetNamedColor('#98FB98','PaleGreen')
    4   0.084879   0.000027   let i = s:SetNamedColor('#AFEEEE','PaleTurquoise')
    4   0.084931   0.000028   let i = s:SetNamedColor('#D87093','PaleVioletRed')
    4   0.084797   0.000064   let i = s:SetNamedColor('#FFEFD5','PapayaWhip')
    4   0.095581   0.000027   let i = s:SetNamedColor('#FFDAB9','PeachPuff')
    4   0.086054   0.000029   let i = s:SetNamedColor('#CD853F','Peru')
    4   0.085352   0.000030   let i = s:SetNamedColor('#FFC0CB','Pink')
    4   0.084547   0.000024   let i = s:SetNamedColor('#DDA0DD','Plum')
    4   0.084922   0.000024   let i = s:SetNamedColor('#B0E0E6','PowderBlue')
    4   0.084764   0.000029   let i = s:SetNamedColor('#BC8F8F','RosyBrown')
    4   0.085175   0.000027   let i = s:SetNamedColor('#4169E1','RoyalBlue')
    4   0.084552   0.000028   let i = s:SetNamedColor('#8B4513','SaddleBrown')
    4   0.084634   0.000027   let i = s:SetNamedColor('#FA8072','Salmon')
    4   0.084943   0.000026   let i = s:SetNamedColor('#F4A460','SandyBrown')
    4   0.084727   0.000024   let i = s:SetNamedColor('#2E8B57','SeaGreen')
    4   0.085247   0.000027   let i = s:SetNamedColor('#FFF5EE','SeaShell')
    4   0.084622   0.000025   let i = s:SetNamedColor('#A0522D','Sienna')
    4   0.085473   0.000026   let i = s:SetNamedColor('#87CEEB','SkyBlue')
    4   0.085145   0.000042   let i = s:SetNamedColor('#6A5ACD','SlateBlue')
    4   0.084761   0.000041   let i = s:SetNamedColor('#708090','SlateGray')
    4   0.088485   0.000030   let i = s:SetNamedColor('#708090','SlateGrey')
    4   0.084793   0.000028   let i = s:SetNamedColor('#FFFAFA','Snow')
    4   0.085455   0.000030   let i = s:SetNamedColor('#00FF7F','SpringGreen')
    4   0.085912   0.000029   let i = s:SetNamedColor('#4682B4','SteelBlue')
    4   0.085061   0.000025   let i = s:SetNamedColor('#D2B48C','Tan')
    4   0.084606   0.000025   let i = s:SetNamedColor('#D8BFD8','Thistle')
    4   0.084442   0.000024   let i = s:SetNamedColor('#FF6347','Tomato')
    4   0.084921   0.000026   let i = s:SetNamedColor('#40E0D0','Turquoise')
    4   0.084433   0.000023   let i = s:SetNamedColor('#EE82EE','Violet')
    4   0.084535   0.000028   let i = s:SetNamedColor('#F5DEB3','Wheat')
    4   0.084586   0.000026   let i = s:SetNamedColor('#F5F5F5','WhiteSmoke')
    4   0.084645   0.000026   let i = s:SetNamedColor('#9ACD32','YellowGreen')
                            
                            
                            
    4              0.000008   let i = 1
  139              0.000273   while i <= line("$")
  135   0.481840   0.000652     call s:PreviewCSSColorInLine(i)
  135              0.000276     let i = i+1
  135              0.000119   endwhile
    4              0.000016   unlet i
                            
    4              0.000035   autocmd CursorMoved * silent call s:PreviewCSSColorInLine('.')
    4              0.000021   autocmd CursorMovedI * silent call s:PreviewCSSColorInLine('.')
    4              0.000021   if !exists('g:cssColorVimDoNotMessMyUpdatetime')
    4              0.000042     set ut=100
    4              0.000005   endif
                            
    4              0.000020 endif

SCRIPT  /Users/klangton/.yadr/vim/bundle/vim-coffee-script/after/syntax/html.vim
Sourced 3 times
Total time:   0.011228
 Self time:   0.003610

count  total (s)   self (s)
                            " Language:    CoffeeScript
                            " Maintainer:  Mick Koch <mick@kochm.co>
                            " URL:         http://github.com/kchmck/vim-coffee-script
                            " License:     WTFPL
                            
                            " Syntax highlighting for text/coffeescript script tags
    3              0.001221 syn include @htmlCoffeeScript syntax/coffee.vim
    3              0.000107 syn region coffeeScript start=#<script [^>]*type="text/coffeescript"[^>]*>#

SCRIPT  /Users/klangton/.yadr/vim/bundle/vim-coffee-script/syntax/coffee.vim
Sourced 4 times
Total time:   0.010209
 Self time:   0.008613

count  total (s)   self (s)
                            " Language:    CoffeeScript
                            " Maintainer:  Mick Koch <mick@kochm.co>
                            " URL:         http://github.com/kchmck/vim-coffee-script
                            " License:     WTFPL
                            
                            " Bail if our syntax is already loaded.
    4              0.000027 if exists('b:current_syntax') && b:current_syntax == 'coffee'
                              finish
                            endif
                            
                            " Include JavaScript for coffeeEmbed.
    4              0.002178 syn include @coffeeJS syntax/javascript.vim
    4              0.000016 silent! unlet b:current_syntax
                            
                            " Highlight long strings.
    4              0.000011 syntax sync fromstart
                            
                            " These are `matches` instead of `keywords` because vim's highlighting
                            " priority for keywords is higher than matches. This causes keywords to be
                            " highlighted inside matches, even if a match says it shouldn't contain them --
                            " like with coffeeAssign and coffeeDot.
    4              0.000060 syn match coffeeStatement /\<\%(return\|break\|continue\|throw\)\>/ display
    4              0.000053 hi def link coffeeStatement Statement
                            
    4              0.000035 syn match coffeeRepeat /\<\%(for\|while\|until\|loop\)\>/ display
    4              0.000032 hi def link coffeeRepeat Repeat
                            
    4              0.000038 syn match coffeeConditional /\<\%(if\|else\|unless\|switch\|when\|then\)\>/
                            \                           display
    4              0.000032 hi def link coffeeConditional Conditional
                            
    4              0.000033 syn match coffeeException /\<\%(try\|catch\|finally\)\>/ display
    4              0.000035 hi def link coffeeException Exception
                            
    4              0.000046 syn match coffeeKeyword /\<\%(new\|in\|of\|by\|and\|or\|not\|is\|isnt\|class\|extends\|super\|do\|yield\)\>/
                            \                       display
                            " The `own` keyword is only a keyword after `for`.
    4              0.000032 syn match coffeeKeyword /\<for\s\+own\>/ contained containedin=coffeeRepeat
                            \                       display
    4              0.000033 hi def link coffeeKeyword Keyword
                            
    4              0.000033 syn match coffeeOperator /\<\%(instanceof\|typeof\|delete\)\>/ display
    4              0.000031 hi def link coffeeOperator Operator
                            
                            " The first case matches symbol operators only if they have an operand before.
    4              0.000063 syn match coffeeExtendedOp /\%(\S\s*\)\@<=[+\-*/%&|\^=!<>?.]\{-1,}\|[-=]>\|--\|++\|:/
                            \                          display
    4              0.000024 syn match coffeeExtendedOp /\<\%(and\|or\)=/ display
    4              0.000010 hi def link coffeeExtendedOp coffeeOperator
                            
                            " This is separate from `coffeeExtendedOp` to help differentiate commas from
                            " dots.
    4              0.000026 syn match coffeeSpecialOp /[,;]/ display
    4              0.000041 hi def link coffeeSpecialOp SpecialChar
                            
    4              0.000048 syn match coffeeBoolean /\<\%(true\|on\|yes\|false\|off\|no\)\>/ display
    4              0.000035 hi def link coffeeBoolean Boolean
                            
    4              0.000038 syn match coffeeGlobal /\<\%(null\|undefined\)\>/ display
    4              0.000032 hi def link coffeeGlobal Type
                            
                            " A special variable
    4              0.000045 syn match coffeeSpecialVar /\<\%(this\|prototype\|arguments\)\>/ display
    4              0.000036 hi def link coffeeSpecialVar Special
                            
                            " An @-variable
    4              0.000030 syn match coffeeSpecialIdent /@\%(\%(\I\|\$\)\%(\i\|\$\)*\)\?/ display
    4              0.000033 hi def link coffeeSpecialIdent Identifier
                            
                            " A class-like name that starts with a capital letter
    4              0.000026 syn match coffeeObject /\<\u\w*\>/ display
    4              0.000031 hi def link coffeeObject Structure
                            
                            " A constant-like name in SCREAMING_CAPS
    4              0.000038 syn match coffeeConstant /\<\u[A-Z0-9_]\+\>/ display
    4              0.000033 hi def link coffeeConstant Constant
                            
                            " A variable name
    4              0.000041 syn cluster coffeeIdentifier contains=coffeeSpecialVar,coffeeSpecialIdent,
                            \                                     coffeeObject,coffeeConstant
                            
                            " A non-interpolated string
    4              0.000025 syn cluster coffeeBasicString contains=@Spell,coffeeEscape
                            " An interpolated string
    4              0.000025 syn cluster coffeeInterpString contains=@coffeeBasicString,coffeeInterp
                            
                            " Regular strings
    4              0.000063 syn region coffeeString start=/"/ skip=/\\\\\|\\"/ end=/"/
                            \                       contains=@coffeeInterpString
    4              0.000047 syn region coffeeString start=/'/ skip=/\\\\\|\\'/ end=/'/
                            \                       contains=@coffeeBasicString
    4              0.000036 hi def link coffeeString String
                            
                            " A integer, including a leading plus or minus
    4              0.000053 syn match coffeeNumber /\%(\i\|\$\)\@<![-+]\?\d\+\%(e[+-]\?\d\+\)\?/ display
                            " A hex, binary, or octal number
    4              0.000028 syn match coffeeNumber /\<0[xX]\x\+\>/ display
    4              0.000020 syn match coffeeNumber /\<0[bB][01]\+\>/ display
    4              0.000022 syn match coffeeNumber /\<0[oO][0-7]\+\>/ display
    4              0.000024 syn match coffeeNumber /\<\%(Infinity\|NaN\)\>/ display
    4              0.000038 hi def link coffeeNumber Number
                            
                            " A floating-point number, including a leading plus or minus
    4              0.000050 syn match coffeeFloat /\%(\i\|\$\)\@<![-+]\?\d*\.\@<!\.\d\+\%([eE][+-]\?\d\+\)\?/
                            \                     display
    4              0.000036 hi def link coffeeFloat Float
                            
                            " An error for reserved keywords, taken from the RESERVED array:
                            " http://coffeescript.org/documentation/docs/lexer.html#section-67
    4              0.000136 syn match coffeeReservedError /\<\%(case\|default\|function\|var\|void\|with\|const\|let\|enum\|export\|import\|native\|__hasProp\|__extends\|__slice\|__bind\|__indexOf\|implements\|interface\|package\|private\|protected\|public\|static\)\>/
                            \                             display
    4              0.000053 hi def link coffeeReservedError Error
                            
                            " A normal object assignment
    4              0.000065 syn match coffeeObjAssign /@\?\%(\I\|\$\)\%(\i\|\$\)*\s*\ze::\@!/ contains=@coffeeIdentifier display
    4              0.000037 hi def link coffeeObjAssign Identifier
                            
    4              0.000032 syn keyword coffeeTodo TODO FIXME XXX contained
    4              0.000037 hi def link coffeeTodo Todo
                            
    4              0.000039 syn match coffeeComment /#.*/ contains=@Spell,coffeeTodo
    4              0.000033 hi def link coffeeComment Comment
                            
    4              0.000052 syn region coffeeBlockComment start=/####\@!/ end=/###/
                            \                             contains=@Spell,coffeeTodo
    4              0.000011 hi def link coffeeBlockComment coffeeComment
                            
                            " A comment in a heregex
    4              0.000051 syn region coffeeHeregexComment start=/#/ end=/\ze\/\/\/\|$/ contained
                            \                               contains=@Spell,coffeeTodo
    4              0.000010 hi def link coffeeHeregexComment coffeeComment
                            
                            " Embedded JavaScript
    4              0.000086 syn region coffeeEmbed matchgroup=coffeeEmbedDelim
                            \                      start=/`/ skip=/\\\\\|\\`/ end=/`/ keepend
                            \                      contains=@coffeeJS
    4              0.000038 hi def link coffeeEmbedDelim Delimiter
                            
    4              0.000053 syn region coffeeInterp matchgroup=coffeeInterpDelim start=/#{/ end=/}/ contained
                            \                       contains=@coffeeAll
    4              0.000039 hi def link coffeeInterpDelim PreProc
                            
                            " A string escape sequence
    4              0.000041 syn match coffeeEscape /\\\d\d\d\|\\x\x\{2\}\|\\u\x\{4\}\|\\./ contained display
    4              0.000033 hi def link coffeeEscape SpecialChar
                            
                            " A regex -- must not follow a parenthesis, number, or identifier, and must not
                            " be followed by a number
    4              0.000102 syn region coffeeRegex start=#\%(\%()\|\%(\i\|\$\)\@<!\d\)\s*\|\i\)\@<!/=\@!\s\@!#
                            \                      end=#/[gimy]\{,4}\d\@!#
                            \                      oneline contains=@coffeeBasicString,coffeeRegexCharSet
    4              0.000036 syn region coffeeRegexCharSet start=/\[/ end=/]/ contained
                            \                             contains=@coffeeBasicString
    4              0.000036 hi def link coffeeRegex String
    4              0.000009 hi def link coffeeRegexCharSet coffeeRegex
                            
                            " A heregex
    4              0.000094 syn region coffeeHeregex start=#///# end=#///[gimy]\{,4}#
                            \                        contains=@coffeeInterpString,coffeeHeregexComment,
                            \                                  coffeeHeregexCharSet
                            \                        fold
    4              0.000037 syn region coffeeHeregexCharSet start=/\[/ end=/]/ contained
                            \                               contains=@coffeeInterpString
    4              0.000008 hi def link coffeeHeregex coffeeRegex
    4              0.000007 hi def link coffeeHeregexCharSet coffeeHeregex
                            
                            " Heredoc strings
    4              0.000045 syn region coffeeHeredoc start=/"""/ end=/"""/ contains=@coffeeInterpString
                            \                        fold
    4              0.000036 syn region coffeeHeredoc start=/'''/ end=/'''/ contains=@coffeeBasicString
                            \                        fold
    4              0.000037 hi def link coffeeHeredoc String
                            
                            " An error for trailing whitespace, as long as the line isn't just whitespace
    4              0.000032 syn match coffeeSpaceError /\S\@<=\s\+$/ display
    4              0.000034 hi def link coffeeSpaceError Error
                            
                            " An error for trailing semicolons, for help transitioning from JavaScript
    4              0.000026 syn match coffeeSemicolonError /;$/ display
    4              0.000031 hi def link coffeeSemicolonError Error
                            
                            " Ignore reserved words in dot accesses.
    4              0.000058 syn match coffeeDotAccess /\.\@<!\.\s*\%(\I\|\$\)\%(\i\|\$\)*/he=s+1 contains=@coffeeIdentifier
    4              0.000011 hi def link coffeeDotAccess coffeeExtendedOp
                            
                            " Ignore reserved words in prototype accesses.
    4              0.000036 syn match coffeeProtoAccess /::\s*\%(\I\|\$\)\%(\i\|\$\)*/he=s+2 contains=@coffeeIdentifier
    4              0.000010 hi def link coffeeProtoAccess coffeeExtendedOp
                            
                            " This is required for interpolations to work.
    4              0.000064 syn region coffeeCurlies matchgroup=coffeeCurly start=/{/ end=/}/
                            \                        contains=@coffeeAll
    4              0.000049 syn region coffeeBrackets matchgroup=coffeeBracket start=/\[/ end=/\]/
                            \                         contains=@coffeeAll
    4              0.000050 syn region coffeeParens matchgroup=coffeeParen start=/(/ end=/)/
                            \                       contains=@coffeeAll
                            
                            " These are highlighted the same as commas since they tend to go together.
    4              0.000014 hi def link coffeeBlock coffeeSpecialOp
    4              0.000008 hi def link coffeeBracket coffeeBlock
    4              0.000024 hi def link coffeeCurly coffeeBlock
    4              0.000005 hi def link coffeeParen coffeeBlock
                            
                            " This is used instead of TOP to keep things coffee-specific for good
                            " embedding. `contained` groups aren't included.
    4              0.000228 syn cluster coffeeAll contains=coffeeStatement,coffeeRepeat,coffeeConditional,
                            \                              coffeeException,coffeeKeyword,coffeeOperator,
                            \                              coffeeExtendedOp,coffeeSpecialOp,coffeeBoolean,
                            \                              coffeeGlobal,coffeeSpecialVar,coffeeSpecialIdent,
                            \                              coffeeObject,coffeeConstant,coffeeString,
                            \                              coffeeNumber,coffeeFloat,coffeeReservedError,
                            \                              coffeeObjAssign,coffeeComment,coffeeBlockComment,
                            \                              coffeeEmbed,coffeeRegex,coffeeHeregex,
                            \                              coffeeHeredoc,coffeeSpaceError,
                            \                              coffeeSemicolonError,coffeeDotAccess,
                            \                              coffeeProtoAccess,coffeeCurlies,coffeeBrackets,
                            \                              coffeeParens
                            
    4              0.000019 if !exists('b:current_syntax')
    4              0.000013   let b:current_syntax = 'coffee'
    4              0.000011 endif

SCRIPT  /Users/klangton/.yadr/vim/bundle/rspec.vim/syntax/rspec.vim
Sourced 1 time
Total time:   0.000230
 Self time:   0.000230

count  total (s)   self (s)
                            "
                            " An rspec syntax file
                            " Originally from http://www.vim.org/scripts/script.php?script_id=2286
                            "
                            "
                            
    1              0.000005 let b:old_syntax = b:current_syntax
    1              0.000002 unlet! b:current_syntax
                            
    1              0.000004 setlocal commentstring=#\ %s
                            
    1              0.000031 syntax keyword rspecGroupMethods context describe example it its let let\! it_should_behave_like shared_examples shared_examples_for subject it_behaves_like pending skip specify When Then Given Invariant feature scenario given given\!
    1              0.000010 highlight link rspecGroupMethods Statement
                            
    1              0.000011 syntax keyword rspecBeforeAndAfter after after_suite_parts append_after append_before before before_suite_parts prepend_after prepend_before around
    1              0.000007 highlight link rspecBeforeAndAfter Identifier
                            
    1              0.000009 syntax keyword rspecMocks double instance_double mock stub stub_chain spy instance_spy
    1              0.000007 highlight link rspecMocks Constant
                            
    1              0.000010 syntax keyword rspecMockMethods and_raise and_return and_throw and_yield build_child called_max_times expected_args invoke matches
    1              0.000007 highlight link rspecMockMethods Function
                            
    1              0.000009 syntax keyword rspecKeywords should should_not should_not_receive should_receive
    1              0.000007 highlight link rspecKeywords Constant
                            
    1              0.000018 syntax keyword rspecMatchers assigns described_class is_expected be change eq eql equal errors_on exist expect expect_any_instance_of allow allow_any_instance_of receive have have_at_least have_at_most have_exactly include match matcher raise_error raise_exception respond_to satisfy throw_symbol to to_not not_to when wrap_expectation all match_array
                            
                            " rspec-mongoid exclusive matchers
    1              0.000005 syntax keyword rspecMatchers embed_one embed_many belong_to validate_format_of validate_associated validate_exclusion_of validate_inclusion_of validate_length_of custom_validate accept_nested_attributes_for
                            
                            " shoulda matchers
    1              0.000007 syntax keyword rspecMatchers allow_mass_assignment_of allow_value ensure_exclusion_of ensure_length_of have_secure_password validate_absence_of validate_acceptance_of validate_confirmation_of validate_numericality_of validate_presence_of validate_uniqueness_of
    1              0.000008 syntax match rspecMatchers /\<\(be\|have\)_\w\+\>/
    1              0.000010 highlight link rspecMatchers Function
                            
    1              0.000020 syntax keyword rspecMessageExpectation advise any_args any_number_of_times anything at_least at_most exactly expected_messages_received generate_error hash_including hash_not_including ignoring_args instance_of matches_at_least_count matches_at_most_count matches_exact_count matches_name_but_not_args negative_expectation_for never no_args once ordered similar_messages times twice verify_messages_received with
    1              0.000008 highlight link rspecMessageExpectation Function
                            
    1              0.000005 let b:current_syntax = b:old_syntax . '.rspec'
    1              0.000005 unlet b:old_syntax

SCRIPT  /Users/klangton/.yadr/vim/bundle/splitjoin.vim/ftplugin/coffee/splitjoin.vim
Sourced 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                            if !exists('b:splitjoin_split_callbacks')
    1              0.000011   let b:splitjoin_split_callbacks = [
                                    \ 'sj#coffee#SplitTernaryClause',
                                    \ 'sj#coffee#SplitTripleString',
                                    \ 'sj#coffee#SplitString',
                                    \ 'sj#coffee#SplitFunction',
                                    \ 'sj#coffee#SplitIfClause',
                                    \ 'sj#coffee#SplitObjectLiteral',
                                    \ ]
    1              0.000001 endif
                            
    1              0.000003 if !exists('b:splitjoin_join_callbacks')
    1              0.000007   let b:splitjoin_join_callbacks = [
                                    \ 'sj#coffee#JoinString',
                                    \ 'sj#coffee#JoinFunction',
                                    \ 'sj#coffee#JoinIfElseClause',
                                    \ 'sj#coffee#JoinIfClause',
                                    \ 'sj#coffee#JoinObjectLiteral',
                                    \ ]
    1              0.000003 endif

SCRIPT  /Users/klangton/.yadr/vim/bundle/vim-coffee-script/ftplugin/coffee.vim
Sourced 1 time
Total time:   0.005522
 Self time:   0.004667

count  total (s)   self (s)
    1   0.001242   0.000693 " Language:    CoffeeScript
                            " Maintainer:  Mick Koch <mick@kochm.co>
                            " URL:         http://github.com/kchmck/vim-coffee-script
                            " License:     WTFPL
                            
    1              0.000006 if exists('b:did_ftplugin')
                              finish
                            endif
                            
    1              0.000003 let b:did_ftplugin = 1
    1              0.000541 call coffee#CoffeeSetUpVariables()
                            
    1              0.000005 setlocal formatoptions-=t formatoptions+=croql
    1              0.000005 setlocal comments=:# commentstring=#\ %s
    1              0.000002 setlocal omnifunc=javascriptcomplete#CompleteJS
    1              0.000002 setlocal suffixesadd+=coffee
                            
                            " Create custom augroups.
    1              0.000010 augroup CoffeeBufUpdate | augroup END
    1              0.000002 augroup CoffeeBufNew | augroup END
                            
                            " Enable coffee compiler if a compiler isn't set already.
    1              0.000003 if !len(&l:makeprg)
    1              0.000479   compiler coffee
    1              0.000002 endif
                            
                            " Switch to the window for buf.
    1              0.000004 function! s:SwitchWindow(buf)
                              exec bufwinnr(a:buf) 'wincmd w'
                            endfunction
                            
                            " Create a new scratch buffer and return the bufnr of it. After the function
                            " returns, vim remains in the scratch buffer so more set up can be done.
    1              0.000003 function! s:ScratchBufBuild(src, vert, size)
                              if a:size <= 0
                                if a:vert
                                  let size = winwidth(bufwinnr(a:src)) / 2
                                else
                                  let size = winheight(bufwinnr(a:src)) / 2
                                endif
                              endif
                            
                              if a:vert
                                vertical belowright new
                                exec 'vertical resize' size
                              else
                                belowright new
                                exec 'resize' size
                              endif
                            
                              setlocal bufhidden=wipe buftype=nofile nobuflisted noswapfile nomodifiable
                              nnoremap <buffer> <silent> q :hide<CR>
                            
                              return bufnr('%')
                            endfunction
                            
                            " Replace buffer contents with text and delete the last empty line.
    1              0.000002 function! s:ScratchBufUpdate(buf, text)
                              " Move to the scratch buffer.
                              call s:SwitchWindow(a:buf)
                            
                              " Double check we're in the scratch buffer before overwriting.
                              if bufnr('%') != a:buf
                                throw 'unable to change to scratch buffer'
                              endif
                            
                              setlocal modifiable
                                silent exec '% delete _'
                                silent put! =a:text
                                silent exec '$ delete _'
                              setlocal nomodifiable
                            endfunction
                            
                            " Parse the output of coffee into a qflist entry for src buffer.
    1              0.000002 function! s:ParseCoffeeError(output, src, startline)
                              " Coffee error is always on first line?
                              let match = matchlist(a:output,
                              \                     '^\(\f\+\|\[stdin\]\):\(\d\):\(\d\): error: \(.\{-}\)' . "\n")
                            
                              if !len(match)
                                return
                              endif
                            
                              " Consider the line number from coffee as relative and add it to the beginning
                              " line number of the range the command was called on, then subtract one for
                              " zero-based relativity.
                              call setqflist([{'bufnr': a:src, 'lnum': a:startline + str2nr(match[2]) - 1,
                              \                'type': 'E', 'col': str2nr(match[3]), 'text': match[4]}], 'r')
                            endfunction
                            
                            " Reset source buffer variables.
    1              0.000001 function! s:CoffeeCompileResetVars()
                              " Variables defined in source buffer:
                              "   b:coffee_compile_buf: bufnr of output buffer
                              " Variables defined in output buffer:
                              "   b:coffee_src_buf: bufnr of source buffer
                              "   b:coffee_compile_pos: previous cursor position in output buffer
                            
                              let b:coffee_compile_buf = -1
                            endfunction
                            
    1              0.000002 function! s:CoffeeWatchResetVars()
                              " Variables defined in source buffer:
                              "   b:coffee_watch_buf: bufnr of output buffer
                              " Variables defined in output buffer:
                              "   b:coffee_src_buf: bufnr of source buffer
                              "   b:coffee_watch_pos: previous cursor position in output buffer
                            
                              let b:coffee_watch_buf = -1
                            endfunction
                            
    1              0.000002 function! s:CoffeeRunResetVars()
                              " Variables defined in CoffeeRun source buffer:
                              "   b:coffee_run_buf: bufnr of output buffer
                              " Variables defined in CoffeeRun output buffer:
                              "   b:coffee_src_buf: bufnr of source buffer
                              "   b:coffee_run_pos: previous cursor position in output buffer
                            
                              let b:coffee_run_buf = -1
                            endfunction
                            
                            " Clean things up in the source buffers.
    1              0.000001 function! s:CoffeeCompileClose()
                              " Switch to the source buffer if not already in it.
                              silent! call s:SwitchWindow(b:coffee_src_buf)
                              call s:CoffeeCompileResetVars()
                            endfunction
                            
    1              0.000002 function! s:CoffeeWatchClose()
                              silent! call s:SwitchWindow(b:coffee_src_buf)
                              silent! autocmd! CoffeeAuWatch * <buffer>
                              call s:CoffeeWatchResetVars()
                            endfunction
                            
    1              0.000001 function! s:CoffeeRunClose()
                              silent! call s:SwitchWindow(b:coffee_src_buf)
                              call s:CoffeeRunResetVars()
                            endfunction
                            
                            " Compile the lines between startline and endline and put the result into buf.
    1              0.000013 function! s:CoffeeCompileToBuf(buf, startline, endline)
                              let src = bufnr('%')
                              let input = join(getline(a:startline, a:endline), "\n")
                            
                              " Coffee doesn't like empty input.
                              if !len(input)
                                " Function should still return within output buffer.
                                call s:SwitchWindow(a:buf)
                                return
                              endif
                            
                              " Pipe lines into coffee.
                              let output = system(g:coffee_compiler .
                              \                   ' -scb' .
                              \                   ' ' . b:coffee_litcoffee .
                              \                   ' 2>&1', input)
                            
                              " Paste output into output buffer.
                              call s:ScratchBufUpdate(a:buf, output)
                            
                              " Highlight as JavaScript if there were no compile errors.
                              if v:shell_error
                                call s:ParseCoffeeError(output, src, a:startline)
                                setlocal filetype=
                              else
                                " Clear the quickfix list.
                                call setqflist([], 'r')
                                setlocal filetype=javascript
                              endif
                            endfunction
                            
                            " Peek at compiled CoffeeScript in a scratch buffer. We handle ranges like this
                            " to prevent the cursor from being moved (and its position saved) before the
                            " function is called.
    1              0.000004 function! s:CoffeeCompile(startline, endline, args)
                              if a:args =~ '\<watch\>'
                                echoerr 'CoffeeCompile watch is deprecated! Please use CoffeeWatch instead'
                                sleep 5
                                call s:CoffeeWatch(a:args)
                                return
                              endif
                            
                              " Switch to the source buffer if not already in it.
                              silent! call s:SwitchWindow(b:coffee_src_buf)
                            
                              " Bail if not in source buffer.
                              if !exists('b:coffee_compile_buf')
                                return
                              endif
                            
                              " Build the output buffer if it doesn't exist.
                              if bufwinnr(b:coffee_compile_buf) == -1
                                let src = bufnr('%')
                            
                                let vert = exists('g:coffee_compile_vert') || a:args =~ '\<vert\%[ical]\>'
                                let size = str2nr(matchstr(a:args, '\<\d\+\>'))
                            
                                " Build the output buffer and save the source bufnr.
                                let buf = s:ScratchBufBuild(src, vert, size)
                                let b:coffee_src_buf = src
                            
                                " Set the buffer name.
                                exec 'silent! file [CoffeeCompile ' . src . ']'
                            
                                " Clean up the source buffer when the output buffer is closed.
                                autocmd BufWipeout <buffer> call s:CoffeeCompileClose()
                                " Save the cursor when leaving the output buffer.
                                autocmd BufLeave <buffer> let b:coffee_compile_pos = getpos('.')
                            
                                " Run user-defined commands on new buffer.
                                silent doautocmd CoffeeBufNew User CoffeeCompile
                            
                                " Switch back to the source buffer and save the output bufnr. This also
                                " triggers BufLeave above.
                                call s:SwitchWindow(src)
                                let b:coffee_compile_buf = buf
                              endif
                            
                              " Fill the scratch buffer.
                              call s:CoffeeCompileToBuf(b:coffee_compile_buf, a:startline, a:endline)
                              " Reset cursor to previous position.
                              call setpos('.', b:coffee_compile_pos)
                            
                              " Run any user-defined commands on the scratch buffer.
                              silent doautocmd CoffeeBufUpdate User CoffeeCompile
                            endfunction
                            
                            " Update the scratch buffer and switch back to the source buffer.
    1              0.000002 function! s:CoffeeWatchUpdate()
                              call s:CoffeeCompileToBuf(b:coffee_watch_buf, 1, '$')
                              call setpos('.', b:coffee_watch_pos)
                              silent doautocmd CoffeeBufUpdate User CoffeeWatch
                              call s:SwitchWindow(b:coffee_src_buf)
                            endfunction
                            
                            " Continually compile a source buffer.
    1              0.000002 function! s:CoffeeWatch(args)
                              silent! call s:SwitchWindow(b:coffee_src_buf)
                            
                              if !exists('b:coffee_watch_buf')
                                return
                              endif
                            
                              if bufwinnr(b:coffee_watch_buf) == -1
                                let src = bufnr('%')
                            
                                let vert = exists('g:coffee_watch_vert') || a:args =~ '\<vert\%[ical]\>'
                                let size = str2nr(matchstr(a:args, '\<\d\+\>'))
                            
                                let buf = s:ScratchBufBuild(src, vert, size)
                                let b:coffee_src_buf = src
                            
                                exec 'silent! file [CoffeeWatch ' . src . ']'
                            
                                autocmd BufWipeout <buffer> call s:CoffeeWatchClose()
                                autocmd BufLeave <buffer> let b:coffee_watch_pos = getpos('.')
                            
                                silent doautocmd CoffeeBufNew User CoffeeWatch
                            
                                call s:SwitchWindow(src)
                                let b:coffee_watch_buf = buf
                              endif
                            
                              " Make sure only one watch autocmd is defined on this buffer.
                              silent! autocmd! CoffeeAuWatch * <buffer>
                            
                              augroup CoffeeAuWatch
                                autocmd InsertLeave <buffer> call s:CoffeeWatchUpdate()
                                autocmd BufWritePost <buffer> call s:CoffeeWatchUpdate()
                              augroup END
                            
                              call s:CoffeeWatchUpdate()
                            endfunction
                            
                            " Run a snippet of CoffeeScript between startline and endline.
    1              0.000003 function! s:CoffeeRun(startline, endline, args)
                              silent! call s:SwitchWindow(b:coffee_src_buf)
                            
                              if !exists('b:coffee_run_buf')
                                return
                              endif
                            
                              if bufwinnr(b:coffee_run_buf) == -1
                                let src = bufnr('%')
                            
                                let buf = s:ScratchBufBuild(src, exists('g:coffee_run_vert'), 0)
                                let b:coffee_src_buf = src
                            
                                exec 'silent! file [CoffeeRun ' . src . ']'
                            
                                autocmd BufWipeout <buffer> call s:CoffeeRunClose()
                                autocmd BufLeave <buffer> let b:coffee_run_pos = getpos('.')
                            
                                silent doautocmd CoffeeBufNew User CoffeeRun
                            
                                call s:SwitchWindow(src)
                                let b:coffee_run_buf = buf
                              endif
                            
                              if a:startline == 1 && a:endline == line('$')
                                let output = system(g:coffee_compiler .
                                \                   ' ' . b:coffee_litcoffee .
                                \                   ' ' . fnameescape(expand('%')) .
                                \                   ' ' . a:args)
                              else
                                let input = join(getline(a:startline, a:endline), "\n")
                            
                                if !len(input)
                                  return
                                endif
                            
                                let output = system(g:coffee_compiler .
                                \                   ' -s' .
                                \                   ' ' . b:coffee_litcoffee .
                                \                   ' ' . a:args, input)
                              endif
                            
                              call s:ScratchBufUpdate(b:coffee_run_buf, output)
                              call setpos('.', b:coffee_run_pos)
                            
                              silent doautocmd CoffeeBufUpdate User CoffeeRun
                            endfunction
                            
                            " Run coffeelint on a file, and add any errors between startline and endline
                            " to the quickfix list.
    1              0.000003 function! s:CoffeeLint(startline, endline, bang, args)
                              let input = join(getline(a:startline, a:endline), "\n")
                            
                              if !len(input)
                                return
                              endif
                            
                              let output = system(g:coffee_linter .
                              \                   ' -s --reporter csv' .
                              \                   ' ' . b:coffee_litcoffee .
                              \                   ' ' . g:coffee_lint_options .
                              \                   ' ' . a:args .
                              \                   ' 2>&1', input)
                            
                              " Convert output into an array and strip off the csv header.
                              let lines = split(output, "\n")[1:]
                              let buf = bufnr('%')
                              let qflist = []
                            
                              for line in lines
                                let match = matchlist(line, '^stdin,\(\d\+\),\d*,\(error\|warn\),\(.\+\)$')
                            
                                " Ignore unmatched lines.
                                if !len(match)
                                  continue
                                endif
                            
                                " The 'type' will result in either 'E' or 'W'.
                                call add(qflist, {'bufnr': buf, 'lnum': a:startline + str2nr(match[1]) - 1,
                                \                 'type': toupper(match[2][0]), 'text': match[3]})
                              endfor
                            
                              " Replace the quicklist with our items.
                              call setqflist(qflist, 'r')
                            
                              " If not given a bang, jump to first error.
                              if !len(a:bang)
                                silent! cc 1
                              endif
                            endfunction
                            
                            " Complete arguments for Coffee* commands.
    1              0.000002 function! s:CoffeeComplete(cmd, cmdline, cursor)
                              let args = ['vertical']
                            
                              " If no partial command, return all possibilities.
                              if !len(a:cmd)
                                return args
                              endif
                            
                              let pat = '^' . a:cmd
                            
                              for arg in args
                                if arg =~ pat
                                  return [arg]
                                endif
                              endfor
                            endfunction
                            
                            " Set initial state variables if they don't exist
    1              0.000005 if !exists('b:coffee_compile_buf')
    1   0.000017   0.000010   call s:CoffeeCompileResetVars()
    1              0.000002 endif
                            
    1              0.000003 if !exists('b:coffee_watch_buf')
    1   0.000013   0.000008   call s:CoffeeWatchResetVars()
    1              0.000001 endif
                            
    1              0.000002 if !exists('b:coffee_run_buf')
    1   0.000012   0.000008   call s:CoffeeRunResetVars()
    1              0.000001 endif
                            
    1              0.000013 command! -buffer -range=% -bar -nargs=* -complete=customlist,s:CoffeeComplete
                            \        CoffeeCompile call s:CoffeeCompile(<line1>, <line2>, <q-args>)
    1              0.000007 command! -buffer -bar -nargs=* -complete=customlist,s:CoffeeComplete
                            \        CoffeeWatch call s:CoffeeWatch(<q-args>)
    1              0.000011 command! -buffer -range=% -bar -nargs=* CoffeeRun
                            \        call s:CoffeeRun(<line1>, <line2>, <q-args>)
    1              0.000014 command! -buffer -range=% -bang -bar -nargs=* CoffeeLint

SCRIPT  /Users/klangton/.yadr/vim/bundle/vim-coffee-script/autoload/coffee.vim
Sourced 1 time
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
                            " Language:    CoffeeScript
                            " Maintainer:  Mick Koch <mick@kochm.co>
                            " URL:         http://github.com/kchmck/vim-coffee-script
                            " License:     WTFPL
                            
                            " Set up some common global/buffer variables.
    1              0.000006 function! coffee#CoffeeSetUpVariables()
                              " Path to coffee executable
                              if !exists('g:coffee_compiler')
                                let g:coffee_compiler = 'coffee'
                              endif
                            
                              " Options passed to coffee with make
                              if !exists('g:coffee_make_options')
                                let g:coffee_make_options = ''
                              endif
                            
                              " Path to cake executable
                              if !exists('g:coffee_cake')
                                let g:coffee_cake = 'cake'
                              endif
                            
                              " Extra options passed to cake
                              if !exists('g:coffee_cake_options')
                                let g:coffee_cake_options = ''
                              endif
                            
                              " Path to coffeelint executable
                              if !exists('g:coffee_linter')
                                let g:coffee_linter = 'coffeelint'
                              endif
                            
                              " Options passed to CoffeeLint
                              if !exists('g:coffee_lint_options')
                                let g:coffee_lint_options = ''
                              endif
                            
                              " Pass the litcoffee flag to tools in this buffer if a litcoffee file is open.
                              " Let the variable be overwritten so it can be updated if a different filetype
                              " is set.
                              if &filetype == 'litcoffee'
                                let b:coffee_litcoffee = '--literate'
                              else
                                let b:coffee_litcoffee = ''
                              endif
                            endfunction
                            
    1              0.000003 function! coffee#CoffeeSetUpErrorFormat()
                              CompilerSet errorformat=Error:\ In\ %f\\,\ %m\ on\ line\ %l,
                                                     \Error:\ In\ %f\\,\ Parse\ error\ on\ line\ %l:\ %m,
                                                     \SyntaxError:\ In\ %f\\,\ %m,
                                                     \%f:%l:%c:\ error:\ %m,
                                                     \%-G%.%#
                            endfunction

SCRIPT  /Users/klangton/.yadr/vim/bundle/vim-coffee-script/compiler/coffee.vim
Sourced 1 time
Total time:   0.000374
 Self time:   0.000285

count  total (s)   self (s)
                            " Language:    CoffeeScript
                            " Maintainer:  Mick Koch <mick@kochm.co>
                            " URL:         http://github.com/kchmck/vim-coffee-script
                            " License:     WTFPL
                            
                            " All this is needed to support compiling filenames with spaces, quotes, and
                            " such. The filename is escaped and embedded into the `makeprg` setting.
                            "
                            " Because of this, `makeprg` must be updated on every file rename. And because
                            " of that, `CompilerSet` can't be used because it doesn't exist when the
                            " rename autocmd is ran. So, we have to do some checks to see whether `compiler`
                            " was called locally or globally, and respect that in the rest of the script.
                            
    1              0.000006 if exists('current_compiler')
                              finish
                            endif
                            
    1              0.000003 let current_compiler = 'coffee'
    1   0.000045   0.000007 call coffee#CoffeeSetUpVariables()
                            
                            " Pattern to check if coffee is the compiler
    1              0.000003 let s:pat = '^' . current_compiler
                            
                            " Get a `makeprg` for the current filename.
    1              0.000003 function! s:GetMakePrg()
                              return g:coffee_compiler .
                              \      ' -c' .
                              \      ' ' . b:coffee_litcoffee .
                              \      ' ' . g:coffee_make_options .
                              \      ' $*' .
                              \      ' ' . fnameescape(expand('%'))
                            endfunction
                            
                            " Set `makeprg` and return 1 if coffee is still the compiler, else return 0.
    1              0.000002 function! s:SetMakePrg()
                              if &l:makeprg =~ s:pat
                                let &l:makeprg = s:GetMakePrg()
                              elseif &g:makeprg =~ s:pat
                                let &g:makeprg = s:GetMakePrg()
                              else
                                return 0
                              endif
                            
                              return 1
                            endfunction
                            
                            " Set a dummy compiler so we can check whether to set locally or globally.
    1              0.000010 exec 'CompilerSet makeprg=' . current_compiler
                            " Then actually set the compiler.
    1   0.000048   0.000008 call s:SetMakePrg()
    1   0.000021   0.000010 call coffee#CoffeeSetUpErrorFormat()
                            
    1              0.000003 function! s:CoffeeMakeDeprecated(bang, args)
                              echoerr 'CoffeeMake is deprecated! Please use :make instead, its behavior ' .
                              \       'is identical.'
                              sleep 5
                              exec 'make' . a:bang a:args
                            endfunction
                            
                            " Compile the current file.
    1              0.000010 command! -bang -bar -nargs=* CoffeeMake
                            \        call s:CoffeeMakeDeprecated(<q-bang>, <q-args>)
                            
                            " Set `makeprg` on rename since we embed the filename in the setting.
    1              0.000003 augroup CoffeeUpdateMakePrg
    1              0.000118   autocmd!
                            
                              " Update `makeprg` if coffee is still the compiler, else stop running this
                              " function.
    1              0.000004   function! s:UpdateMakePrg()
                                if !s:SetMakePrg()
                                  autocmd! CoffeeUpdateMakePrg
                                endif
                              endfunction
                            
                              " Set autocmd locally if compiler was set locally.
    1              0.000009   if &l:makeprg =~ s:pat
    1              0.000008     autocmd BufWritePre,BufFilePost <buffer> call s:UpdateMakePrg()
    1              0.000001   else
                                autocmd BufWritePre,BufFilePost          call s:UpdateMakePrg()
                              endif
    1              0.000004 augroup END

SCRIPT  /Users/klangton/.yadr/vim/bundle/splitjoin.vim/ftplugin/javascript/splitjoin.vim
Sourced 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                            if !exists('b:splitjoin_split_callbacks')
    1              0.000010   let b:splitjoin_split_callbacks = [
                                    \ 'sj#js#SplitArray',
                                    \ 'sj#js#SplitObjectLiteral',
                                    \ 'sj#js#SplitFunction',
                                    \ 'sj#js#SplitOneLineIf',
                                    \ 'sj#js#SplitArgs'
                                    \ ]
    1              0.000001 endif
                            
    1              0.000003 if !exists('b:splitjoin_join_callbacks')
    1              0.000007   let b:splitjoin_join_callbacks = [
                                    \ 'sj#js#JoinArray',
                                    \ 'sj#js#JoinArgs',
                                    \ 'sj#js#JoinFunction',
                                    \ 'sj#js#JoinOneLineIf',
                                    \ 'sj#js#JoinObjectLiteral',
                                    \ ]
    1              0.000004 endif

SCRIPT  /usr/local/Cellar/macvim/7.4-73/MacVim.app/Contents/Resources/vim/runtime/ftplugin/javascript.vim
Sourced 1 time
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	Javascript
                            " Maintainer:	Doug Kearns <dougkearns@gmail.com>
                            " Last Change:  2008 Jun 15
                            " URL:		http://gus.gscit.monash.edu.au/~djkea2/vim/ftplugin/javascript.vim
                            
    1              0.000006 if exists("b:did_ftplugin")
                              finish
                            endif
    1              0.000003 let b:did_ftplugin = 1
                            
    1              0.000006 let s:cpo_save = &cpo
    1              0.000007 set cpo-=C
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " " and insert the comment leader when hitting <CR> or using "o".
    1              0.000004 setlocal formatoptions-=t formatoptions+=croql
                            
                            " Set completion with CTRL-X CTRL-O to autoloaded function.
    1              0.000004 if exists('&ofu')
    1              0.000003     setlocal omnifunc=javascriptcomplete#CompleteJS
    1              0.000000 endif
                            
                            " Set 'comments' to format dashed lists in comments.
    1              0.000004 setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://
                            
    1              0.000002 setlocal commentstring=//%s
                            
                            " Change the :browse e filter to primarily show Java-related files.
    1              0.000005 if has("gui_win32")
                                let  b:browsefilter="Javascript Files (*.js)\t*.js\n" .
                            		\	"All Files (*.*)\t*.*\n"
                            endif
                                   
    1              0.000003 let b:undo_ftplugin = "setl fo< ofu< com< cms<" 
                            
    1              0.000006 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save

SCRIPT  /usr/local/Cellar/macvim/7.4-73/MacVim.app/Contents/Resources/vim/runtime/indent/javascript.vim
Sourced 1 time
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Javascript
                            " Maintainer:	None!  Wanna improve this?
                            " Last Change:	2007 Jan 22
                            
                            " Only load this indent file when no other was loaded.
    1              0.000006 if exists("b:did_indent")
                               finish
                            endif
    1              0.000003 let b:did_indent = 1
                            
                            " C indenting is not too bad.
    1              0.000003 setlocal cindent
    1              0.000004 setlocal cinoptions+=j1,J1
                            
    1              0.000005 let b:undo_indent = "setl cin<"

SCRIPT  /Users/klangton/.yadr/vim/bundle/vim-slim/indent/slim.vim
Sourced 1 time
Total time:   0.001519
 Self time:   0.001380

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Slim
                            
    1              0.000006 if exists("b:did_indent")
                              finish
                            endif
    1              0.000376 runtime! indent/ruby.vim
    1              0.000004 unlet! b:did_indent
    1              0.000003 let b:did_indent = 1
                            
    1              0.000011 setlocal autoindent sw=2 et
    1              0.000004 setlocal indentexpr=GetSlimIndent()
    1              0.000003 setlocal indentkeys=o,O,*<Return>,},],0),!^F,=end,=else,=elsif,=rescue,=ensure,=when
                            
                            " Only define the function once.
    1              0.000004 if exists("*GetSlimIndent")
                              finish
                            endif
                            
    1              0.000003 let s:attributes = '\%({.\{-\}}\|\[.\{-\}\]\)'
    1              0.000003 let s:tag = '\%([%.#][[:alnum:]_-]\+\|'.s:attributes.'\)*[<>]*'
                            
    1              0.000003 if !exists('g:haml_self_closing_tags')
    1              0.000003   let g:haml_self_closing_tags = 'meta|link|img|hr|br'
    1              0.000001 endif
                            
    1              0.000008 function! GetSlimIndent()
                              let lnum = prevnonblank(v:lnum-1)
                              if lnum == 0
                                return 0
                              endif
                              let line = substitute(getline(lnum),'\s\+$','','')
                              let cline = substitute(substitute(getline(v:lnum),'\s\+$','',''),'^\s\+','','')
                              let lastcol = strlen(line)
                              let line = substitute(line,'^\s\+','','')
                              let indent = indent(lnum)
                              let cindent = indent(v:lnum)
                              if cline =~# '\v^-\s*%(elsif|else|when)>'
                                let indent = cindent < indent ? cindent : indent - &sw
                              endif
                              let increase = indent + &sw
                              if indent == indent(lnum)
                                let indent = cindent <= indent ? -1 : increase
                              endif
                            
                              let group = synIDattr(synID(lnum,lastcol,1),'name')
                            
                              if line =~ '^doctype'
                                return indent
                              elseif line =~ '^/\%(\[[^]]*\]\)\=$'
                                return increase
                              elseif line =~ '^[\.#]'
                                return increase
                              elseif line =~? '^div'
                                return increase
                              elseif group == 'hamlFilter'
                                return increase
                              elseif line =~ '^'.s:tag.'[&!]\=[=~-]\s*\%(\%(if\|else\|elsif\|unless\|case\|when\|while\|until\|for\|begin\|module\|class\|def\)\>\%(.*\<end\>\)\@!\|.*do\%(\s*|[^|]*|\)\=\s*$\)'
                                return increase
                              elseif line =~ '^'.s:tag.'[&!]\=[=~-].*,\s*$'
                                return increase
                              elseif line == '-#'
                                return increase
                              elseif group =~? '\v^(hamlSelfCloser)$' || line =~? '^\v('.g:haml_self_closing_tags.')>'
                                return indent
                              elseif group =~? '\v^(hamlTag|hamlAttributesDelimiter|hamlObjectDelimiter|hamlClass|hamlId|htmlTagName|htmlSpecialTagName)$'
                                return increase
                              elseif synIDattr(synID(v:lnum,1,1),'name') ==? 'hamlRubyFilter'
                                return GetRubyIndent()
                              else
                                return indent
                              endif
                            endfunction
                            
                            " vim:set sw=2:

SCRIPT  /Users/klangton/.yadr/vim/bundle/vim-slim/syntax/slim.vim
Sourced 1 time
Total time:   6.394454
 Self time:   0.020263

count  total (s)   self (s)
                            " Vim syntax file
                            " Language: Slim
                            " Maintainer: Andrew Stone <andy@stonean.com>
                            " Version:  1
                            " Last Change:  2010 Sep 25
                            " TODO: Feedback is welcomed.
                            
                            " Quit when a syntax file is already loaded.
    1              0.000006 if exists("b:current_syntax")
                              finish
                            endif
                            
    1              0.000003 if !exists("main_syntax")
    1              0.000003   let main_syntax = 'slim'
    1              0.000001 endif
                            
                            " Allows a per line syntax evaluation.
    1              0.000002 let b:ruby_no_expensive = 1
                            
                            " Include Ruby syntax highlighting
    1              0.000259 syn include @slimRubyTop syntax/ruby.vim
    1              0.000004 unlet! b:current_syntax
                            " Include Haml syntax highlighting
    1              0.000531 syn include @slimHaml syntax/haml.vim
    1              0.000005 unlet! b:current_syntax
                            
    1              0.000048 syn match slimBegin  "^\s*\(&[^= ]\)\@!" nextgroup=slimTag,slimClassChar,slimIdChar,slimRuby
                            
    1              0.000014 syn region  rubyCurlyBlock start="{" end="}" contains=@slimRubyTop contained
    1              0.000011 syn cluster slimRubyTop    add=rubyCurlyBlock
                            
    1              0.000041 syn cluster slimComponent contains=slimClassChar,slimIdChar,slimWrappedAttrs,slimRuby,slimAttr,slimInlineTagChar
                            
    1              0.000014 syn keyword slimDocType        contained html 5 1.1 strict frameset mobile basic transitional
    1              0.000016 syn match   slimDocTypeKeyword "^\s*\(doctype\)\s\+" nextgroup=slimDocType
                            
    1              0.000011 syn keyword slimTodo        FIXME TODO NOTE OPTIMIZE XXX contained
    1              0.000008 syn keyword htmlTagName     contained script
                            
    1              0.000019 syn match slimTag           "\w\+[><]*"         contained contains=htmlTagName nextgroup=@slimComponent
    1              0.000018 syn match slimIdChar        "#{\@!"        contained nextgroup=slimId
    1              0.000008 syn match slimId            "\%(\w\|-\)\+" contained nextgroup=@slimComponent
    1              0.000021 syn match slimClassChar     "\."           contained nextgroup=slimClass
    1              0.000008 syn match slimClass         "\%(\w\|-\)\+" contained nextgroup=@slimComponent
    1              0.000008 syn match slimInlineTagChar "\s*:\s*"      contained nextgroup=slimTag,slimClassChar,slimIdChar
                            
    1              0.000020 syn region slimWrappedAttrs matchgroup=slimWrappedAttrsDelimiter start="\s*{\s*" skip="}\s*\""  end="\s*}\s*"  contained contains=slimAttr nextgroup=slimRuby
    1              0.000010 syn region slimWrappedAttrs matchgroup=slimWrappedAttrsDelimiter start="\s*\[\s*" end="\s*\]\s*" contained contains=slimAttr nextgroup=slimRuby
    1              0.000010 syn region slimWrappedAttrs matchgroup=slimWrappedAttrsDelimiter start="\s*(\s*"  end="\s*)\s*"  contained contains=slimAttr nextgroup=slimRuby
                            
    1              0.000030 syn match slimAttr /\s*\%(\w\|-\)\+\s*=/me=e-1 contained contains=htmlArg nextgroup=slimAttrAssignment
    1              0.000023 syn match slimAttrAssignment "\s*=\s*" contained nextgroup=slimWrappedAttrValue,slimAttrString
                            
    1              0.000016 syn region slimWrappedAttrValue start="[^"']" end="\s\|$" contained contains=slimAttrString,@slimRubyTop nextgroup=slimAttr,slimRuby,slimInlineTagChar
    1              0.000023 syn region slimWrappedAttrValue matchgroup=slimWrappedAttrValueDelimiter start="{" end="}" contained contains=slimAttrString,@slimRubyTop nextgroup=slimAttr,slimRuby,slimInlineTagChar
    1              0.000014 syn region slimWrappedAttrValue matchgroup=slimWrappedAttrValueDelimiter start="\[" end="\]" contained contains=slimAttrString,@slimRubyTop nextgroup=slimAttr,slimRuby,slimInlineTagChar
    1              0.000018 syn region slimWrappedAttrValue matchgroup=slimWrappedAttrValueDelimiter start="(" end=")" contained contains=slimAttrString,@slimRubyTop nextgroup=slimAttr,slimRuby,slimInlineTagChar
                            
    1              0.000033 syn region slimAttrString start=+\s*"+ skip=+\%(\\\\\)*\\"+ end=+"\s*+ contained contains=slimInterpolation,slimInterpolationEscape nextgroup=slimAttr,slimRuby,slimInlineTagChar
    1              0.000018 syn region slimAttrString start=+\s*'+ skip=+\%(\\\\\)*\\"+ end=+'\s*+ contained contains=slimInterpolation,slimInterpolationEscape nextgroup=slimAttr,slimRuby,slimInlineTagChar
                            
    1              0.000027 syn region slimInnerAttrString start=+\s*"+ skip=+\%(\\\\\)*\\"+ end=+"\s*+ contained contains=slimInterpolation,slimInterpolationEscape nextgroup=slimAttr
    1              0.000015 syn region slimInnerAttrString start=+\s*'+ skip=+\%(\\\\\)*\\"+ end=+'\s*+ contained contains=slimInterpolation,slimInterpolationEscape nextgroup=slimAttr
                            
    1              0.000031 syn region slimInterpolation matchgroup=slimInterpolationDelimiter start="#{" end="}" contains=@hamlRubyTop containedin=javascriptStringS,javascriptStringD,slimWrappedAttrs
    1              0.000333 syn region slimInterpolation matchgroup=slimInterpolationDelimiter start="#{{" end="}}" contains=@hamlRubyTop containedin=javascriptStringS,javascriptStringD,slimWrappedAttrs
    1              0.000027 syn match  slimInterpolationEscape "\\\@<!\%(\\\\\)*\\\%(\\\ze#{\|#\ze{\)"
                            
    1              0.000038 syn region slimRuby matchgroup=slimRubyOutputChar start="\s*[=]\==[']\=" skip="\%\(,\s*\|\\\)$" end="$" contained contains=@slimRubyTop keepend
    1              0.000022 syn region slimRuby matchgroup=slimRubyChar       start="\s*-"           skip="\%\(,\s*\|\\\)$" end="$" contained contains=@slimRubyTop keepend
                            
    1              0.000022 syn match slimComment /^\(\s*\)[/].*\(\n\1\s.*\)*/ contains=slimTodo
    1              0.000018 syn match slimText    /^\(\s*\)[`|'].*\(\n\1\s.*\)*/ contains=slimInterpolation
                            
    1              0.000023 syn match slimFilter /\s*\w\+:\s*/                            contained
    1              0.000024 syn match slimHaml   /^\(\s*\)\<haml:\>.*\(\n\1\s.*\)*/       contains=@slimHaml,slimFilter
                            
    1              0.000018 syn match slimIEConditional "\%(^\s*/\)\@<=\[\s*if\>[^]]*]" contained containedin=slimComment
                            
    1              0.000011 hi def link slimAttrString                String
    1              0.000008 hi def link slimBegin                     String
    1              0.000008 hi def link slimClass                     Type
    1              0.000008 hi def link slimAttr                      Type
    1              0.000008 hi def link slimClassChar                 Type
    1              0.000007 hi def link slimComment                   Comment
    1              0.000007 hi def link slimDocType                   Identifier
    1              0.000008 hi def link slimDocTypeKeyword            Keyword
    1              0.000007 hi def link slimFilter                    Keyword
    1              0.000008 hi def link slimIEConditional             SpecialComment
    1              0.000008 hi def link slimId                        Identifier
    1              0.000008 hi def link slimIdChar                    Identifier
    1              0.000007 hi def link slimInnerAttrString           String
    1              0.000008 hi def link slimInterpolationDelimiter    Delimiter
    1              0.000007 hi def link slimRubyChar                  Special
    1              0.000008 hi def link slimRubyOutputChar            Special
    1              0.000007 hi def link slimText                      String
    1              0.000008 hi def link slimTodo                      Todo
    1              0.000007 hi def link slimWrappedAttrValueDelimiter Delimiter
    1              0.000008 hi def link slimWrappedAttrsDelimiter     Delimiter
    1              0.000007 hi def link slimInlineTagChar             Delimiter
                            
    1              0.000007 let b:current_syntax = "slim"

SCRIPT  /usr/local/Cellar/macvim/7.4-73/MacVim.app/Contents/Resources/vim/runtime/syntax/haml.vim
Sourced 1 time
Total time:   6.369402
 Self time:   0.017505

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Haml
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Filenames:	*.haml
                            " Last Change:	2010 Aug 09
                            
    1              0.000007 if exists("b:current_syntax")
                              finish
                            endif
                            
    1              0.000003 if !exists("main_syntax")
                              let main_syntax = 'haml'
                            endif
    1              0.000003 let b:ruby_no_expensive = 1
                            
    1              0.000550 runtime! syntax/html.vim
    1              0.000004 unlet! b:current_syntax
    1              0.000559 silent! syn include @hamlSassTop syntax/sass.vim
    1              0.000004 unlet! b:current_syntax
    1              0.000255 syn include @hamlRubyTop syntax/ruby.vim
                            
    1              0.000002 syn case match
                            
    1              0.000015 syn region  rubyCurlyBlock   start="{" end="}" contains=@hamlRubyTop contained
    1              0.000010 syn cluster hamlRubyTop add=rubyCurlyBlock
                            
    1              0.000071 syn cluster hamlComponent    contains=hamlAttributes,hamlAttributesHash,hamlClassChar,hamlIdChar,hamlObject,hamlDespacer,hamlSelfCloser,hamlRuby,hamlPlainChar,hamlInterpolatable
    1              0.000014 syn cluster hamlEmbeddedRuby contains=hamlAttributesHash,hamlObject,hamlRuby,hamlRubyFilter
    1              0.000036 syn cluster hamlTop          contains=hamlBegin,hamlPlainFilter,hamlRubyFilter,hamlSassFilter,hamlComment,hamlHtmlComment
                            
    1              0.000028 syn match   hamlBegin "^\s*\%([<>]\|&[^=~ ]\)\@!" nextgroup=hamlTag,hamlClassChar,hamlIdChar,hamlRuby,hamlPlainChar,hamlInterpolatable
                            
    1              0.000031 syn match   hamlTag        "%\w\+\%(:\w\+\)\=" contained contains=htmlTagName,htmlSpecialTagName nextgroup=@hamlComponent
    1              0.000050 syn region  hamlAttributes     matchgroup=hamlAttributesDelimiter start="(" end=")" contained contains=htmlArg,hamlAttributeString,hamlAttributeVariable,htmlEvent,htmlCssDefinition nextgroup=@hamlComponent
    1              0.000014 syn region  hamlAttributesHash matchgroup=hamlAttributesDelimiter start="{" end="}" contained contains=@hamlRubyTop nextgroup=@hamlComponent
    1              0.000017 syn region  hamlObject         matchgroup=hamlObjectDelimiter     start="\[" end="\]" contained contains=@hamlRubyTop nextgroup=@hamlComponent
    1              0.000011 syn match   hamlDespacer "[<>]" contained nextgroup=hamlDespacer,hamlSelfCloser,hamlRuby,hamlPlainChar,hamlInterpolatable
    1              0.000004 syn match   hamlSelfCloser "/" contained
    1              0.000016 syn match   hamlClassChar "\." contained nextgroup=hamlClass
    1              0.000013 syn match   hamlIdChar "#{\@!" contained nextgroup=hamlId
    1              0.000007 syn match   hamlClass "\%(\w\|-\)\+" contained nextgroup=@hamlComponent
    1              0.000006 syn match   hamlId    "\%(\w\|-\)\+" contained nextgroup=@hamlComponent
    1              0.000015 syn region  hamlDocType start="^\s*!!!" end="$"
                            
    1              0.000031 syn region  hamlRuby   matchgroup=hamlRubyOutputChar start="[!&]\==\|\~" skip=",\s*$" end="$" contained contains=@hamlRubyTop keepend
    1              0.000020 syn region  hamlRuby   matchgroup=hamlRubyChar       start="-"           skip=",\s*$" end="$" contained contains=@hamlRubyTop keepend
    1              0.000004 syn match   hamlPlainChar "\\" contained
    1              0.000042 syn region hamlInterpolatable matchgroup=hamlInterpolatableChar start="!\===\|!=\@!" end="$" keepend contained contains=hamlInterpolation,hamlInterpolationEscape,@hamlHtmlTop
    1              0.000013 syn region hamlInterpolatable matchgroup=hamlInterpolatableChar start="&==\|&=\@!"   end="$" keepend contained contains=hamlInterpolation,hamlInterpolationEscape
    1              0.000030 syn region hamlInterpolation matchgroup=hamlInterpolationDelimiter start="#{" end="}" contains=@hamlRubyTop containedin=javascriptStringS,javascriptStringD
    1              0.000012 syn match  hamlInterpolationEscape "\\\@<!\%(\\\\\)*\\\%(\\\ze#{\|#\ze{\)"
    1              0.000018 syn region hamlErbInterpolation matchgroup=hamlInterpolationDelimiter start="<%[=-]\=" end="-\=%>" contained contains=@hamlRubyTop
                            
    1              0.000014 syn region  hamlAttributeString start=+\%(=\s*\)\@<='+ skip=+\%(\\\\\)*\\'+ end=+'+ contains=hamlInterpolation,hamlInterpolationEscape
    1              0.000016 syn region  hamlAttributeString start=+\%(=\s*\)\@<="+ skip=+\%(\\\\\)*\\"+ end=+"+ contains=hamlInterpolation,hamlInterpolationEscape
    1              0.000006 syn match   hamlAttributeVariable "\%(=\s*\)\@<=\%(@@\=\|\$\)\=\w\+" contained
                            
    1              0.000021 syn match   hamlHelper  "\<action_view?\|\<block_is_haml?\|\<is_haml?\|\.\@<!\<flatten" contained containedin=@hamlEmbeddedRuby,@hamlRubyTop
    1              0.000022 syn keyword hamlHelper   capture_haml escape_once find_and_preserve haml_concat haml_indent haml_tag html_attrs html_esape init_haml_helpers list_of non_haml precede preserve succeed surround tab_down tab_up page_class contained containedin=@hamlEmbeddedRuby,@hamlRubyTop
                            
    1              0.000333 syn cluster hamlHtmlTop contains=@htmlTop,htmlBold,htmlItalic,htmlUnderline
    1              0.000061 syn region  hamlPlainFilter      matchgroup=hamlFilter start="^\z(\s*\):\%(plain\|preserve\|redcloth\|textile\|markdown\|maruku\)\s*$" end="^\%(\z1 \| *$\)\@!" contains=@hamlHtmlTop,hamlInterpolation
    1              0.000033 syn region  hamlEscapedFilter    matchgroup=hamlFilter start="^\z(\s*\):\%(escaped\|cdata\)\s*$"    end="^\%(\z1 \| *$\)\@!" contains=hamlInterpolation
    1              0.000024 syn region  hamlErbFilter        matchgroup=hamlFilter start="^\z(\s*\):erb\s*$"        end="^\%(\z1 \| *$\)\@!" contains=@hamlHtmlTop,hamlErbInterpolation
    1              0.000012 syn region  hamlRubyFilter       matchgroup=hamlFilter start="^\z(\s*\):ruby\s*$"       end="^\%(\z1 \| *$\)\@!" contains=@hamlRubyTop
    1              0.000022 syn region  hamlJavascriptFilter matchgroup=hamlFilter start="^\z(\s*\):javascript\s*$" end="^\%(\z1 \| *$\)\@!" contains=@htmlJavaScript,hamlInterpolation keepend
    1              0.000022 syn region  hamlCSSFilter        matchgroup=hamlFilter start="^\z(\s*\):css\s*$"        end="^\%(\z1 \| *$\)\@!" contains=@htmlCss,hamlInterpolation keepend
    1              0.000012 syn region  hamlSassFilter       matchgroup=hamlFilter start="^\z(\s*\):sass\s*$"       end="^\%(\z1 \| *$\)\@!" contains=@hamlSassTop
                            
    1              0.000030 syn region  hamlJavascriptBlock start="^\z(\s*\)%script" nextgroup=@hamlComponent,hamlError end="^\%(\z1 \| *$\)\@!" contains=@hamlTop,@htmlJavaScript keepend
    1              0.000023 syn region  hamlCssBlock        start="^\z(\s*\)%style" nextgroup=@hamlComponent,hamlError  end="^\%(\z1 \| *$\)\@!" contains=@hamlTop,@htmlCss keepend
    1              0.000005 syn match   hamlError "\$" contained
                            
    1              0.000018 syn region  hamlComment     start="^\z(\s*\)-#" end="^\%(\z1 \| *$\)\@!" contains=rubyTodo
    1              0.000019 syn region  hamlHtmlComment start="^\z(\s*\)/"  end="^\%(\z1 \| *$\)\@!" contains=@hamlTop,rubyTodo
    1              0.000016 syn match   hamlIEConditional "\%(^\s*/\)\@<=\[if\>[^]]*]" contained containedin=hamlHtmlComment
                            
    1              0.000012 hi def link hamlSelfCloser             Special
    1              0.000009 hi def link hamlDespacer               Special
    1              0.000007 hi def link hamlClassChar              Special
    1              0.000008 hi def link hamlIdChar                 Special
    1              0.000007 hi def link hamlTag                    Special
    1              0.000007 hi def link hamlClass                  Type
    1              0.000007 hi def link hamlId                     Identifier
    1              0.000007 hi def link hamlPlainChar              Special
    1              0.000002 hi def link hamlInterpolatableChar     hamlRubyChar
    1              0.000002 hi def link hamlRubyOutputChar         hamlRubyChar
    1              0.000007 hi def link hamlRubyChar               Special
    1              0.000007 hi def link hamlInterpolationDelimiter Delimiter
    1              0.000007 hi def link hamlInterpolationEscape    Special
    1              0.000007 hi def link hamlAttributeString        String
    1              0.000008 hi def link hamlAttributeVariable      Identifier
    1              0.000007 hi def link hamlDocType                PreProc
    1              0.000007 hi def link hamlFilter                 PreProc
    1              0.000007 hi def link hamlAttributesDelimiter    Delimiter
    1              0.000008 hi def link hamlObjectDelimiter        Delimiter
    1              0.000007 hi def link hamlHelper                 Function
    1              0.000002 hi def link hamlHtmlComment            hamlComment
    1              0.000007 hi def link hamlComment                Comment
    1              0.000007 hi def link hamlIEConditional          SpecialComment
    1              0.000008 hi def link hamlError                  Error
                            
    1              0.000004 let b:current_syntax = "haml"
                            
    1              0.000003 if main_syntax == "haml"
                              unlet main_syntax
                            endif
                            
                            " vim:set sw=2:

SCRIPT  /usr/local/Cellar/macvim/7.4-73/MacVim.app/Contents/Resources/vim/runtime/syntax/sass.vim
Sourced 1 time
Total time:   3.175071
 Self time:   0.006872

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Sass
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Filenames:	*.sass
                            " Last Change:	2013 May 30
                            
    1              0.000007 if exists("b:current_syntax")
                              finish
                            endif
                            
    1              0.000094 runtime! syntax/css.vim
                            
    1              0.000002 syn case ignore
                            
    1              0.000100 syn cluster sassCssProperties contains=cssFontProp,cssFontDescriptorProp,cssColorProp,cssTextProp,cssBoxProp,cssGeneratedContentProp,cssPagingProp,cssUIProp,cssRenderProp,cssAuralProp,cssTableProp
    1              0.000942 syn cluster sassCssAttributes contains=css.*Attr,scssComment,cssValue.*,cssColor,cssURL,sassDefault,cssImportant,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssRenderProp
                            
    1              0.000027 syn region sassDefinition matchgroup=cssBraces start="{" end="}" contains=TOP
                            
    1              0.001128 syn match sassProperty "\%([{};]\s*\|^\)\@<=\%([[:alnum:]-]\|#{[^{}]*}\)\+\s*:" contains=css.*Prop skipwhite nextgroup=sassCssAttribute contained containedin=sassDefinition
    1              0.001089 syn match sassProperty "^\s*\zs\s\%(\%([[:alnum:]-]\|#{[^{}]*}\)\+\s*:\|:[[:alnum:]-]\+\)"hs=s+1 contains=css.*Prop skipwhite nextgroup=sassCssAttribute
    1              0.001105 syn match sassProperty "^\s*\zs\s\%(:\=[[:alnum:]-]\+\s*=\)"hs=s+1 contains=css.*Prop skipwhite nextgroup=sassCssAttribute
    1              0.000038 syn match sassCssAttribute +\%("\%([^"]\|\\"\)*"\|'\%([^']\|\\'\)*'\|#{[^{}]*}\|[^{};]\)*+ contained contains=@sassCssAttributes,sassVariable,sassFunction,sassInterpolation
    1              0.000013 syn match sassDefault "!default\>" contained
    1              0.000008 syn match sassVariable "!\%(important\>\|default\>\)\@![[:alnum:]_-]\+"
    1              0.000005 syn match sassVariable "$[[:alnum:]_-]\+"
    1              0.000026 syn match sassVariableAssignment "\%([!$][[:alnum:]_-]\+\s*\)\@<=\%(||\)\==" nextgroup=sassCssAttribute skipwhite
    1              0.000011 syn match sassVariableAssignment "\%([!$][[:alnum:]_-]\+\s*\)\@<=:" nextgroup=sassCssAttribute skipwhite
                            
    1              0.000007 syn match sassFunction "\<\%(rgb\|rgba\|red\|green\|blue\|mix\)\>(\@=" contained
    1              0.000010 syn match sassFunction "\<\%(hsl\|hsla\|hue\|saturation\|lightness\|adjust-hue\|lighten\|darken\|saturate\|desaturate\|grayscale\|complement\)\>(\@=" contained
    1              0.000008 syn match sassFunction "\<\%(alpha\|opacity\|rgba\|opacify\|fade-in\|transparentize\|fade-out\)\>(\@=" contained
    1              0.000004 syn match sassFunction "\<\%(unquote\|quote\)\>(\@=" contained
    1              0.000006 syn match sassFunction "\<\%(percentage\|round\|ceil\|floor\|abs\)\>(\@=" contained
    1              0.000005 syn match sassFunction "\<\%(type-of\|unit\|unitless\|comparable\)\>(\@=" contained
                            
    1              0.000043 syn region sassInterpolation matchgroup=sassInterpolationDelimiter start="#{" end="}" contains=@sassCssAttributes,sassVariable,sassFunction containedin=cssStringQ,cssStringQQ,cssPseudoClass,sassProperty
                            
    1              0.000021 syn match sassMixinName "[[:alnum:]_-]\+" contained nextgroup=sassCssAttribute
    1              0.000016 syn match sassMixin  "^="               nextgroup=sassMixinName skipwhite
    1              0.000010 syn match sassMixin  "\%([{};]\s*\|^\s*\)\@<=@mixin"   nextgroup=sassMixinName skipwhite
    1              0.000014 syn match sassMixing "^\s\+\zs+"        nextgroup=sassMixinName
    1              0.000009 syn match sassMixing "\%([{};]\s*\|^\s*\)\@<=@include" nextgroup=sassMixinName skipwhite
    1              0.000013 syn match sassExtend "\%([{};]\s*\|^\s*\)\@<=@extend"
    1              0.000016 syn match sassPlaceholder "\%([{};]\s*\|^\s*\)\@<=%"   nextgroup=sassMixinName skipwhite
                            
    1              0.000015 syn match sassFunctionName "[[:alnum:]_-]\+" contained nextgroup=sassCssAttribute
    1              0.000016 syn match sassFunctionDecl "\%([{};]\s*\|^\s*\)\@<=@function"   nextgroup=sassFunctionName skipwhite
    1              0.000014 syn match sassReturn "\%([{};]\s*\|^\s*\)\@<=@return"
                            
    1              0.000013 syn match sassEscape     "^\s*\zs\\"
    1              0.000020 syn match sassIdChar     "#[[:alnum:]_-]\@=" nextgroup=sassId
    1              0.000006 syn match sassId         "[[:alnum:]_-]\+" contained
    1              0.000018 syn match sassClassChar  "\.[[:alnum:]_-]\@=" nextgroup=sassClass
    1              0.000012 syn match sassClass      "[[:alnum:]_-]\+" contained
    1              0.000012 syn match sassAmpersand  "&"
                            
                            " TODO: Attribute namespaces
                            " TODO: Arithmetic (including strings and concatenation)
                            
    1              0.000037 syn region sassInclude start="@import" end=";\|$" contains=scssComment,cssStringQ,cssStringQQ,cssURL,cssUnicodeEscape,cssMediaType
    1              0.000026 syn region sassDebugLine end=";\|$" matchgroup=sassDebug start="@debug\>" contains=@sassCssAttributes,sassVariable,sassFunction
    1              0.000458 syn region sassWarnLine end=";\|$" matchgroup=sassWarn start="@warn\>" contains=@sassCssAttributes,sassVariable,sassFunction
    1              0.000058 syn region sassControlLine matchgroup=sassControl start="@\%(if\|else\%(\s\+if\)\=\|while\|for\|each\)\>" end="[{};]\@=\|$" contains=sassFor,@sassCssAttributes,sassVariable,sassFunction
    1              0.000006 syn keyword sassFor from to through in contained
                            
    1              0.000011 syn keyword sassTodo        FIXME NOTE TODO OPTIMIZE XXX contained
    1              0.000024 syn region  sassComment     start="^\z(\s*\)//"  end="^\%(\z1 \)\@!" contains=sassTodo,@Spell
    1              0.000022 syn region  sassCssComment  start="^\z(\s*\)/\*" end="^\%(\z1 \)\@!" contains=sassTodo,@Spell
                            
    1              0.000003 hi def link sassCssComment              sassComment
    1              0.000009 hi def link sassComment                 Comment
    1              0.000003 hi def link sassDefault                 cssImportant
    1              0.000007 hi def link sassVariable                Identifier
    1              0.000007 hi def link sassFunction                Function
    1              0.000007 hi def link sassMixing                  PreProc
    1              0.000007 hi def link sassMixin                   PreProc
    1              0.000007 hi def link sassPlaceholder             PreProc
    1              0.000006 hi def link sassExtend                  PreProc
    1              0.000007 hi def link sassFunctionDecl            PreProc
    1              0.000006 hi def link sassReturn                  PreProc
    1              0.000007 hi def link sassTodo                    Todo
    1              0.000007 hi def link sassInclude                 Include
    1              0.000001 hi def link sassDebug                   sassControl
    1              0.000002 hi def link sassWarn                    sassControl
    1              0.000007 hi def link sassControl                 PreProc
    1              0.000016 hi def link sassFor                     PreProc
    1              0.000008 hi def link sassEscape                  Special
    1              0.000007 hi def link sassIdChar                  Special
    1              0.000007 hi def link sassClassChar               Special
    1              0.000007 hi def link sassInterpolationDelimiter  Delimiter
    1              0.000007 hi def link sassAmpersand               Character
    1              0.000006 hi def link sassId                      Identifier
    1              0.000007 hi def link sassClass                   Type
                            
    1              0.000003 let b:current_syntax = "sass"
                            
                            " vim:set sw=2:

SCRIPT  /Users/klangton/.yadr/vim/bundle/vim-coffee-script/after/syntax/haml.vim
Sourced 1 time
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
                            " Language:    CoffeeScript
                            " Maintainer:  Sven Felix Oberquelle <Svelix.Github@gmail.com>
                            " URL:         http://github.com/kchmck/vim-coffee-script
                            " License:     WTFPL
                            
                            " Inherit coffee from html so coffeeComment isn't redefined and given higher
                            " priority than hamlInterpolation.
    1              0.000007 syn cluster hamlCoffeescript contains=@htmlCoffeeScript
    1              0.000034 syn region  hamlCoffeescriptFilter matchgroup=hamlFilter

FUNCTION  <SNR>125_addfilecmds()
Called 100 times
Total time:   0.044687
 Self time:   0.036527

count  total (s)   self (s)
  100   0.001282   0.000492   let l = s:sub(a:type,'^.','\l&')
 1200              0.001899   for prefix in ['E', 'S', 'V', 'T', 'D', 'R', 'RE', 'RS', 'RV', 'RT', 'RD']
 1100              0.003880     let cplt = " -complete=customlist,".s:sid.l."List"
 1100   0.035380   0.028010     exe "command! -buffer -bar ".(prefix =~# 'D' ? '-range=0 ' : '')."-nargs=*".cplt." ".prefix.l." :execute s:".l.'Edit("'.(prefix =~# 'D' ? '<line1>' : '').s:sub(prefix, '^R', '').'<bang>",<f-args>)'
 1100              0.001041   endfor

FUNCTION  eighties#EightiesResize()
Called 10 times
Total time:   0.001366
 Self time:   0.000149

count  total (s)   self (s)
   10   0.001281   0.000064   if g:eighties_enabled && !s:in_file_browser()
                                let l:size = s:new_width()
                            
                                if l:size > s:current_width()
                                  exec "silent vertical resize " . l:size
                                end
                              endif

FUNCTION  <SNR>125_function()
Called 41 times
Total time:   0.000645
 Self time:   0.000645

count  total (s)   self (s)
   41              0.000614     return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))

FUNCTION  <SNR>71_project_locked()
Called 75 times
Total time:   0.003567
 Self time:   0.003424

count  total (s)   self (s)
   75   0.000448   0.000305   let lock_file = self.lock()
   75              0.000473   let time = getftime(lock_file)
   75              0.000244   if time != -1 && time != get(self,'_lock_time',-1)
                                let self._locked = {'git': [], 'gem': [], 'path': []}
                                let self._versions = {}
                            
                                for line in readfile(lock_file)
                                  if line =~# '^\S'
                                    let properties = {'versions': {}}
                                    if has_key(self._locked, tolower(line))
                                      call extend(self._locked[tolower(line)], [properties])
                                    endif
                                  elseif line =~# '^  \w\+: '
                                    let properties[matchstr(line, '\w\+')] = matchstr(line, ': \zs.*')
                                  elseif line =~# '^    [a-zA-Z0-9._-]\+\s\+(\d\+'
                                    let name = split(line, ' ')[0]
                                    let ver = substitute(line, '.*(\|).*', '', 'g')
                                    let properties.versions[name] = ver
                                    let self._versions[name] = ver
                                  endif
                                endfor
                                let self._lock_time = time
                              endif
   75              0.000177   return get(self, '_locked', {})

FUNCTION  <SNR>49_activateFileNode()
Called 10 times
Total time:  14.314594
 Self time:   0.000087

count  total (s)   self (s)
   10  14.314589   0.000082     call a:node.activate({'reuse': 'all', 'where': 'p'})

FUNCTION  RailsFilePath()
Called 20 times
Total time:   0.004189
 Self time:   0.000379

count  total (s)   self (s)
   20              0.000058   if !exists("b:rails_root")
                                return ""
                              else
   20   0.004086   0.000276     return rails#buffer().name()
                              endif

FUNCTION  <SNR>125_BufCommands()
Called 10 times
Total time:   0.013058
 Self time:   0.001758

count  total (s)   self (s)
   10   0.002143   0.000043   call s:BufNavCommands()
   10   0.001585   0.000045   call s:BufScriptWrappers()
   10              0.000072   command! -buffer -bar -nargs=+ Rnavcommand :call s:Navcommand(<bang>0,<f-args>)
   10              0.000064   command! -buffer -bar -nargs=* -bang Rabbrev :call s:Abbrev(<bang>0,<f-args>)
   10              0.000143   command! -buffer -bar -nargs=? -bang -count -complete=customlist,rails#complete_rake Rake    :call s:Rake(<bang>0,!<count> && <line1> ? -1 : <count>,<q-args>)
   10              0.000096   command! -buffer -bar -nargs=? -bang -range -complete=customlist,s:Complete_preview Rpreview :call s:Preview(<bang>0,<line1>,<q-args>)
   10              0.000094   command! -buffer -bar -nargs=? -bang -range -complete=customlist,s:Complete_preview Rbrowse :call s:Preview(<bang>0,<line1>,<q-args>)
   10              0.000097   command! -buffer -bar -nargs=? -bang -range -complete=customlist,s:Complete_preview Preview :call s:Preview(<bang>0,<line1>,<q-args>)
   10              0.000068   command! -buffer -bar -nargs=? -bang -complete=customlist,s:Complete_environments   Rlog     :call s:Log(<bang>0,<q-args>)
   10              0.000064   command! -buffer -bar -nargs=* -bang                                                Rset     :call s:Set(<bang>0,<f-args>)
   10              0.000053   command! -buffer -bar -nargs=0 Rtags       :execute rails#app().tags_command()
   10              0.000051   command! -buffer -bar -nargs=0 Ctags       :execute rails#app().tags_command()
   10              0.000123   command! -buffer -bar -nargs=0 -bang Rrefresh :if <bang>0|unlet! g:autoloaded_rails|source `=s:file`|endif|call s:Refresh(<bang>0)
   10              0.000030   if exists("g:loaded_dbext")
                                command! -buffer -bar -nargs=? -complete=customlist,s:Complete_environments Rdbext  :call s:BufDatabase(2,<q-args>)|let b:dbext_buffer_defaulted = 1
                              endif
   10              0.000034   let ext = expand("%:e")
   10   0.002199   0.000076   if RailsFilePath() =~ '\<app/views/'
                                " TODO: complete controller names with trailing slashes here
    1              0.000014     command! -buffer -bar -bang -nargs=? -range -complete=customlist,s:controllerList Rextract :<line1>,<line2>call s:Extract(<bang>0,<f-args>)
    1              0.000011     command! -buffer -bar -bang -nargs=? -range -complete=customlist,s:controllerList Extract  :<line1>,<line2>call s:Extract(<bang>0,<f-args>)
    1              0.000002   elseif rails#buffer().name() =~# '^app/helpers/.*\.rb$'
                                command! -buffer -bar -bang -nargs=1 -range Rextract :<line1>,<line2>call s:RubyExtract(<bang>0, 'app/helpers', [], s:sub(<f-args>, '_helper$|Helper$|$', '_helper'))
                                command! -buffer -bar -bang -nargs=1 -range Extract  :<line1>,<line2>call s:RubyExtract(<bang>0, 'app/helpers', [], s:sub(<f-args>, '_helper$|Helper$|$', '_helper'))
                              elseif rails#buffer().name() =~# '^app/\w\+/.*\.rb$'
                                command! -buffer -bar -bang -nargs=1 -range Rextract :<line1>,<line2>call s:RubyExtract(<bang>0, matchstr(rails#buffer().name(), '^app/\w\+/').'concerns', ['  extend ActiveSupport::Concern', ''], <f-args>)
                                command! -buffer -bar -bang -nargs=1 -range Extract  :<line1>,<line2>call s:RubyExtract(<bang>0, matchstr(rails#buffer().name(), '^app/\w\+/').'concerns', ['  extend ActiveSupport::Concern', ''], <f-args>)
                              endif
   10   0.002144   0.000078   if RailsFilePath() =~ '\<db/migrate/.*\.rb$'
                                command! -buffer -bar                 Rinvert  :call s:Invert(<bang>0)
                              endif

FUNCTION  <SNR>125_buffer_path()
Called 61 times
Total time:   0.002481
 Self time:   0.001859

count  total (s)   self (s)
   61   0.002456   0.001834   return s:gsub(fnamemodify(bufname(self.number()),':p'),'\\ @!','/')

FUNCTION  <SNR>90_repo_dir()
Called 756 times
Total time:   0.004755
 Self time:   0.004755

count  total (s)   self (s)
  756              0.004324   return join([self.git_dir]+a:000,'/')

FUNCTION  RailsDetect()
Called 27 times
Total time:   0.002771
 Self time:   0.002771

count  total (s)   self (s)
   27              0.000083   if exists('b:rails_root')
   17              0.000020     return 1
                              endif
   10              0.000267   let fn = fnamemodify(a:0 ? a:1 : expand('%'), ':p')
   10              0.000072   if fn =~# ':[\/]\{2\}'
                                return 0
                              endif
   10              0.000047   if !isdirectory(fn)
   10              0.000038     let fn = fnamemodify(fn, ':h')
   10              0.000006   endif
   10              0.001685   let file = findfile('config/environment.rb', escape(fn, ', ').';')
   10              0.000254   if !empty(file) && isdirectory(fnamemodify(file, ':p:h:h') . '/app')
   10              0.000187     let b:rails_root = fnamemodify(file, ':p:h:h')
   10              0.000014     return 1
                              endif

FUNCTION  <SNR>90_buffer_commit()
Called 10 times
Total time:   0.000617
 Self time:   0.000109

count  total (s)   self (s)
   10   0.000612   0.000104   return matchstr(self.spec(),'^fugitive://.\{-\}//\zs\w*')

FUNCTION  <SNR>79_get()
Called 700 times
Total time:   0.011832
 Self time:   0.011832

count  total (s)   self (s)
  700              0.000892   if a:0 == 2
                                return deepcopy(get(a:2, 'delimitMate_' . a:name, a:1))
                              elseif a:0 == 1
   40              0.000179     let bufoptions = get(s:options, bufnr('%'), {})
   40              0.000149     return deepcopy(get(bufoptions, a:name, a:1))
                              else
  660              0.004357     return deepcopy(eval('s:options.' . bufnr('%') . '.' . a:name))
                              endif

FUNCTION  <SNR>71_project_sorted()
Called 4 times
Total time:   0.000877
 Self time:   0.000028

count  total (s)   self (s)
    4   0.000863   0.000014   call self.paths()
    4              0.000012   return get(self, '_sorted', [])

FUNCTION  <SNR>78_init()
Called 20 times
Total time:   0.036742
 Self time:   0.006288

count  total (s)   self (s)
                            " Initialize variables:
                              " autoclose
   20   0.001330   0.000092   call s:option_init("autoclose", 1)
                              " matchpairs
   20   0.001294   0.000164   call s:option_init("matchpairs", string(&matchpairs)[1:-2])
   20   0.002418   0.000731   call s:option_init("matchpairs_list", map(split(s:get('matchpairs'), '.:.\zs,\ze.:.'), 'split(v:val, ''^.\zs:\ze.$'')'))
   20   0.000653   0.000089   let pairs = s:get('matchpairs_list')
   20              0.000207   if len(filter(pairs, 'v:val[0] ==# v:val[1]'))
                                echohl ErrorMsg
                                echom 'delimitMate: each member of a pair in delimitMate_matchpairs must be different from each other.'
                                echom 'delimitMate: invalid pairs: ' . join(map(pairs, 'join(v:val, ":")'), ', ')
                                echohl Normal
                                return 0
                              endif
   20   0.001946   0.000271   call s:option_init("left_delims", map(copy(s:get('matchpairs_list')), 'v:val[0]'))
   20   0.001935   0.000279   call s:option_init("right_delims", map(copy(s:get('matchpairs_list')), 'v:val[1]'))
                              " quotes
   20   0.001172   0.000094   call s:option_init("quotes", "\" ' `")
   20   0.001898   0.000272   call s:option_init("quotes_list",split(s:get('quotes'), '\s\+'))
                              " nesting_quotes
   20   0.001191   0.000093   call s:option_init("nesting_quotes", [])
                              " excluded_regions
   20   0.001200   0.000094   call s:option_init("excluded_regions", "Comment")
   20   0.001894   0.000223   call s:option_init("excluded_regions_list", split(s:get('excluded_regions'), ',\s*'))
   20   0.000628   0.000120   let enabled = len(s:get('excluded_regions_list')) > 0
   20   0.001189   0.000098   call s:option_init("excluded_regions_enabled", enabled)
                              " expand_space
   20              0.000080   if exists("b:delimitMate_expand_space") && type(b:delimitMate_expand_space) == type("")
                                echom "b:delimitMate_expand_space is '".b:delimitMate_expand_space."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_space' for more details."
                                unlet b:delimitMate_expand_space
                                let b:delimitMate_expand_space = 1
                              endif
   20              0.000068   if exists("g:delimitMate_expand_space") && type(g:delimitMate_expand_space) == type("")
                                echom "delimitMate_expand_space is '".g:delimitMate_expand_space."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_space' for more details."
                                unlet g:delimitMate_expand_space
                                let g:delimitMate_expand_space = 1
                              endif
   20   0.001163   0.000084   call s:option_init("expand_space", 0)
                              " expand_cr
   20              0.000079   if exists("b:delimitMate_expand_cr") && type(b:delimitMate_expand_cr) == type("")
                                echom "b:delimitMate_expand_cr is '".b:delimitMate_expand_cr."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_cr' for more details."
                                unlet b:delimitMate_expand_cr
                                let b:delimitMate_expand_cr = 1
                              endif
   20              0.000065   if exists("g:delimitMate_expand_cr") && type(g:delimitMate_expand_cr) == type("")
                                echom "delimitMate_expand_cr is '".g:delimitMate_expand_cr."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_cr' for more details."
                                unlet g:delimitMate_expand_cr
                                let g:delimitMate_expand_cr = 1
                              endif
   20              0.000190   if ((&backspace !~ 'eol' || &backspace !~ 'start') && &backspace != 2) && ((exists('b:delimitMate_expand_cr') && b:delimitMate_expand_cr == 1) || (exists('g:delimitMate_expand_cr') && g:delimitMate_expand_cr == 1))
                                echom "delimitMate: There seems to be some incompatibility with your settings that may interfer with the expansion of <CR>. See :help 'delimitMate_expand_cr' for details."
                              endif
   20   0.001200   0.000092   call s:option_init("expand_cr", 0)
                              " expand_in_quotes
   20   0.001140   0.000091   call s:option_init('expand_inside_quotes', 0)
                              " jump_expansion
   20   0.001195   0.000089   call s:option_init("jump_expansion", 0)
                              " smart_matchpairs
   20   0.001237   0.000119   call s:option_init("smart_matchpairs", '^\%(\w\|\!\|[$]\|[^[:punct:][:space:]]\)')
                              " smart_quotes
                              " XXX: backward compatibility. Ugly, should go the way of the dodo soon.
   20   0.000735   0.000199   let quotes = escape(join(s:get('quotes_list'), ''), '\-^[]')
   20              0.000109   let default_smart_quotes = '\%(\w\|[^[:punct:][:space:]' . quotes . ']\|\%(\\\\\)*\\\)\%#\|\%#\%(\w\|[^[:space:][:punct:]' . quotes . ']\)'
   20              0.000078   if exists('g:delimitMate_smart_quotes') && type(g:delimitMate_smart_quotes) == type(0)
                                if g:delimitMate_smart_quotes
                                  unlet g:delimitMate_smart_quotes
                                else
                                  unlet g:delimitMate_smart_quotes
                                  let g:delimitMate_smart_quotes = ''
                                endif
                              endif
   20              0.000069   if exists('b:delimitMate_smart_quotes') && type(b:delimitMate_smart_quotes) == type(0)
                                if b:delimitMate_smart_quotes
                                  unlet b:delimitMate_smart_quotes
                                  if exists('g:delimitMate_smart_quotes') && type(g:delimitMate_smart_quotes) && g:delimitMate_smart_quotes
                                    let b:delimitMate_smart_quotes = default_smart_quotes
                                  endif
                                else
                                  unlet b:delimitMate_smart_quotes
                                  let b:delimitMate_smart_quotes = ''
                                endif
                              endif
   20   0.001227   0.000109   call s:option_init("smart_quotes", default_smart_quotes)
                              " apostrophes
   20   0.001188   0.000088   call s:option_init("apostrophes", "")
   20   0.001864   0.000212   call s:option_init("apostrophes_list", split(s:get('apostrophes'), ":\s*"))
                              " tab2exit
   20   0.001192   0.000088   call s:option_init("tab2exit", 1)
                              " balance_matchpairs
   20   0.001222   0.000096   call s:option_init("balance_matchpairs", 0)
                              " eol marker
   20   0.001228   0.000105   call s:option_init("insert_eol_marker", 1)
   20   0.001208   0.000101   call s:option_init("eol_marker", "")
                              " Everything is fine.
   20              0.000018   return 1

FUNCTION  <SNR>125_RefreshBuffer()
Called 20 times
Total time:   0.000182
 Self time:   0.000182

count  total (s)   self (s)
   20              0.000075   if exists("b:rails_refresh") && b:rails_refresh
                                let b:rails_refresh = 0
                                let &filetype = &filetype
                                unlet! b:rails_refresh
                              endif

FUNCTION  <SNR>71_Detect()
Called 10 times
Total time:   0.002030
 Self time:   0.000203

count  total (s)   self (s)
   10              0.000030   if !exists('b:bundler_lock')
   10   0.001895   0.000068     let lock = s:FindBundlerLock(a:path)
   10              0.000030     if !empty(lock)
   10              0.000020       let b:bundler_lock = lock
   10              0.000007     endif
   10              0.000005   endif
   10              0.000025   return exists('b:bundler_lock')

FUNCTION  <SNR>71_buffer_alter_paths()
Called 10 times
Total time:   0.019834
 Self time:   0.000702

count  total (s)   self (s)
   10   0.000121   0.000078   if self.getvar('&suffixesadd') =~# '\.rb\>'
    4   0.001264   0.000039     let new = self.project().sorted()
    4   0.000045   0.000031     let old = type(self.getvar('bundler_paths')) == type([]) ? self.getvar('bundler_paths') : []
   12              0.000034     for [option, suffix] in [['path', 'lib'], ['tags', 'tags']]
    8   0.000075   0.000039       let value = self.getvar('&'.option)
    8              0.000015       if !empty(old)
                                    let drop = s:build_path_option(old,suffix)
                                    let index = stridx(value,drop)
                                    if index > 0
                                      let value = value[0:index-1] . value[index+strlen(drop):-1]
                                    endif
                                  endif
    8   0.017891   0.000097       call self.setvar('&'.option,value.s:build_path_option(new,suffix))
    8              0.000013     endfor
    4   0.000039   0.000019     call self.setvar('bundler_paths',new)
    4              0.000002   endif

FUNCTION  <SNR>71_Setup()
Called 10 times
Total time:   0.024015
 Self time:   0.000289

count  total (s)   self (s)
   10   0.002089   0.000059   if s:Detect(a:path)
   10   0.021899   0.000203     silent doautocmd User Bundler
   10              0.000010   endif

FUNCTION  <SNR>17_LoadIndent()
Called 10 times
Total time:   0.049319
 Self time:   0.040192

count  total (s)   self (s)
   10              0.000031     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
   10              0.000038     let s = expand("<amatch>")
   10              0.000014     if s != ""
   10              0.000019       if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   20              0.000072       for name in split(s, '\.')
   10   0.049000   0.039873 	exe 'runtime! indent/' . name . '.vim'
   10              0.000019       endfor
   10              0.000009     endif

FUNCTION  <SNR>125_BufScriptWrappers()
Called 10 times
Total time:   0.001540
 Self time:   0.001540

count  total (s)   self (s)
   10              0.000176   command! -buffer -bang -bar -nargs=* -complete=customlist,s:Complete_script   Rscript       :execute empty(<q-args>) ? rails#app().script_command(<bang>0, 'console') : rails#app().script_command(<bang>0,<f-args>)
   10              0.000074   command! -buffer -bang -bar -nargs=* -complete=customlist,s:Complete_environments Console   :Rails<bang> console <args>
   10              0.000093   command! -buffer -bang -bar -nargs=* -complete=customlist,s:Complete_script   Rails         :execute rails#app().script_command(<bang>0,<f-args>)
   10              0.000105   command! -buffer -bang -bar -nargs=* -complete=customlist,s:Complete_generate Rgenerate     :execute rails#app().generator_command(<bang>0,'generate',<f-args>)
   10              0.000103   command! -buffer -bang -bar -nargs=* -complete=customlist,s:Complete_generate Generate      :execute rails#app().generator_command(<bang>0,'generate',<f-args>)
   10              0.000083   command! -buffer -bar -nargs=*       -complete=customlist,s:Complete_destroy  Rdestroy      :execute rails#app().generator_command(1,'destroy',<f-args>)
   10              0.000080   command! -buffer -bar -nargs=*       -complete=customlist,s:Complete_destroy  Destroy       :execute rails#app().generator_command(1,'destroy',<f-args>)
   10              0.000094   command! -buffer -bar -nargs=? -bang -complete=customlist,s:Complete_server   Rserver       :execute rails#app().server_command(<bang>0, 1, <q-args>)
   10              0.000095   command! -buffer -bar -nargs=? -bang -complete=customlist,s:Complete_server   Server        :execute rails#app().server_command(0, <bang>0, <q-args>)
   10              0.000141   command! -buffer -bang -nargs=? -range=0 -complete=customlist,s:Complete_edit Rrunner       :execute rails#buffer().runner_command(<bang>0, <count>?<line1>:0, <q-args>)
   10              0.000141   command! -buffer -bang -nargs=? -range=0 -complete=customlist,s:Complete_edit Runner        :execute rails#buffer().runner_command(<bang>0, <count>?<line1>:0, <q-args>)
   10              0.000155   command! -buffer       -nargs=1 -range=0 -complete=customlist,s:Complete_ruby Rp            :execute rails#app().output_command(<count>==<line2>?<count>:-1, 'p begin '.<q-args>.' end')
   10              0.000173   command! -buffer       -nargs=1 -range=0 -complete=customlist,s:Complete_ruby Rpp           :execute rails#app().output_command(<count>==<line2>?<count>:-1, 'require %{pp}; pp begin '.<q-args>.' end')

FUNCTION  <SNR>32_TmuxAwareNavigate()
Called 10 times
Total time:   0.042137
 Self time:   0.000376

count  total (s)   self (s)
   10              0.000051   let nr = winnr()
   10              0.000040   let tmux_last_pane = (a:direction == 'p' && s:tmux_is_last_pane)
   10              0.000011   if !tmux_last_pane
   10   0.041818   0.000057     call s:VimNavigate(a:direction)
   10              0.000008   endif
                              " Forward the switch panes command to tmux if:
                              " a) we're toggling between the last tmux pane;
                              " b) we tried switching windows in vim but it didn't have effect.
   10              0.000030   if tmux_last_pane || nr == winnr()
                                if g:tmux_navigator_save_on_switch
                                  update
                                endif
                                let cmd = 'tmux select-pane -' . tr(a:direction, 'phjkl', 'lLDUR')
                                silent call system(cmd)
                                if s:NeedsVitalityRedraw()
                                  redraw!
                                endif
                                let s:tmux_is_last_pane = 1
                              else
   10              0.000020     let s:tmux_is_last_pane = 0
   10              0.000008   endif

FUNCTION  <SNR>125_buffer_number()
Called 1187 times
Total time:   0.002217
 Self time:   0.002217

count  total (s)   self (s)
 1187              0.001732   return self['#']

FUNCTION  <SNR>125_buffer_type_name()
Called 133 times
Total time:   0.031203
 Self time:   0.002945

count  total (s)   self (s)
  133   0.001049   0.000781   let type = getbufvar(self.number(),'rails_cached_file_type')
  133              0.000183   if type == ''
   51   0.026294   0.000275     let type = self.calculate_file_type()
   51              0.000031   endif
  133   0.003300   0.001329   return call('s:match_type',[type == '-' ? '' : type] + a:000)

FUNCTION  delimitMate#Get()
Called 700 times
Total time:   0.015069
 Self time:   0.003237

count  total (s)   self (s)
  700   0.014810   0.002978   return call('s:get', a:000)

FUNCTION  <SNR>125_BufMappings()
Called 10 times
Total time:   0.002652
 Self time:   0.002652

count  total (s)   self (s)
   10              0.000479   nnoremap <buffer> <silent> <Plug>RailsFind       :<C-U>call <SID>Find(v:count1,'E')<CR>
   10              0.000159   nnoremap <buffer> <silent> <Plug>RailsSplitFind  :<C-U>call <SID>Find(v:count1,'S')<CR>
   10              0.000146   nnoremap <buffer> <silent> <Plug>RailsVSplitFind :<C-U>call <SID>Find(v:count1,'V')<CR>
   10              0.000139   nnoremap <buffer> <silent> <Plug>RailsTabFind    :<C-U>call <SID>Find(v:count1,'T')<CR>
   10              0.000534   if !hasmapto("<Plug>RailsFind")
   10              0.000113     nmap <buffer> gf              <Plug>RailsFind
   10              0.000006   endif
   10              0.000397   if !hasmapto("<Plug>RailsSplitFind")
   10              0.000115     nmap <buffer> <C-W>f          <Plug>RailsSplitFind
   10              0.000008   endif
   10              0.000394   if !hasmapto("<Plug>RailsTabFind")
   10              0.000117     nmap <buffer> <C-W>gf         <Plug>RailsTabFind
   10              0.000006   endif

FUNCTION  ctrlp#utils#writecache()
Called 10 times
Total time:   0.012682
 Self time:   0.012539

count  total (s)   self (s)
   10   0.000222   0.000079 	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
   10              0.012428 		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
   10              0.000018 	en

FUNCTION  <SNR>90_can_diffoff()
Called 20 times
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
   20              0.000143   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  <SNR>73_Setup()
Called 10 times
Total time:   0.003027
 Self time:   0.000112

count  total (s)   self (s)
   10   0.002973   0.000058   call s:Detect(a:path)
   10              0.000024   if exists('b:rake_root')
                                silent doautocmd User Rake
                              endif

FUNCTION  <SNR>66_BufEnterHook()
Called 20 times
Total time:   0.008799
 Self time:   0.000800

count  total (s)   self (s)
   20   0.000505   0.000304     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufEnter, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))) . ', &buftype = ' . string(&buftype))
   20              0.000030     if &buftype ==# ''
   10   0.007882   0.000084         call s:notifiers.refresh(g:SyntasticLoclist.current())
   10              0.000010     elseif &buftype ==# 'quickfix'
                                    " TODO: this is needed because in recent versions of Vim lclose
                                    " can no longer be called from BufWinLeave
                                    " TODO: at this point there is no b:syntastic_loclist
                                    let loclist = filter(copy(getloclist(0)), 'v:val["valid"] == 1')
                                    let owner = str2nr(getbufvar(bufnr(''), 'syntastic_owner_buffer'))
                                    let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
                                    if get(w:, 'syntastic_loclist_set', 0) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                        call SyntasticLoclistHide()
                                    endif
                                endif

FUNCTION  <SNR>125_gsub()
Called 1177 times
Total time:   0.008673
 Self time:   0.008673

count  total (s)   self (s)
 1177              0.008071   return substitute(a:str,'\v\C'.a:pat,a:rep,'g')

FUNCTION  <SNR>125_AddBracketExpand()
Called 7 times
Total time:   0.000488
 Self time:   0.000039

count  total (s)   self (s)
    7   0.000484   0.000035   call s:AddSelectiveExpand(a:abbr,'[[.]',a:expn)

FUNCTION  <SNR>78_Unmap()
Called 10 times
Total time:   0.008240
 Self time:   0.007128

count  total (s)   self (s)
   10   0.001606   0.000641   let imaps = s:get('right_delims', []) + s:get('left_delims', []) + s:get('quotes_list', []) + s:get('apostrophes_list', []) + ['<BS>', '<C-h>', '<S-BS>', '<Del>', '<CR>', '<Space>', '<S-Tab>', '<Esc>'] + ['<Up>', '<Down>', '<Left>', '<Right>', '<LeftMouse>', '<RightMouse>'] + ['<C-Left>', '<C-Right>'] + ['<Home>', '<End>', '<PageUp>', '<PageDown>', '<S-Down>', '<S-Up>', '<C-G>g']
                            
  334              0.000338   for map in imaps
  324              0.003507     if maparg(map, "i") =~# '^<Plug>delimitMate'
  124              0.000226       if map == '|'
                                    let map = '<Bar>'
                                  endif
  124              0.000662       exec 'silent! iunmap <buffer> ' . map
  124              0.000063     endif
  324              0.000247   endfor
   10   0.000365   0.000218   silent! doautocmd <nomodeline> User delimitMate_unmap
   10              0.000035   let b:delimitMate_enabled = 0

FUNCTION  syntastic#log#debug()
Called 70 times
Total time:   0.000596
 Self time:   0.000397

count  total (s)   self (s)
   70   0.000497   0.000298     if !s:_isDebugEnabled(a:level)
   70              0.000050         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0 > 0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  <SNR>83_YRWinLeave()
Called 10 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
                                " Track which window we are last in.  We will use this information
                                " to determine where we need to paste any contents, or which
                                " buffer to return to.
                            
   10              0.000029     if s:yr_buffer_id < 0
                                    " The yankring window has never been activated
   10              0.000011         return
                                endif
                            
                                if winbufnr(winnr()) == s:yr_buffer_id
                                    " Ignore leaving the yankring window
                                    return
                                endif
                            
                                if bufwinnr(s:yr_buffer_id) != -1
                                    " YankRing window is visible, so save off the previous buffer ids
                                    let s:yr_buffer_last_winnr = winnr()
                                    let s:yr_buffer_last       = winbufnr(s:yr_buffer_last_winnr)
                                " else
                                "     let s:yr_buffer_last_winnr = -1
                                "     let s:yr_buffer_last       = -1
                                endif

FUNCTION  <SNR>10_setf()
Called 4 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    4              0.000011   if &filetype !=# a:filetype
                                let &filetype = a:filetype
                              endif

FUNCTION  ShouldMatchWhitespace()
Called 10 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
   10              0.000020     for ft in g:extra_whitespace_ignored_filetypes
                                    if ft ==# &filetype | return 0 | endif
                                endfor
   10              0.000006     return 1

FUNCTION  <SNR>86_abbrev()
Called 10 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
   10              0.000030   if exists('g:endwise_abbreviations')
                                for word in split(get(b:, 'endwise_words', ''), ',')
                                  execute 'iabbrev <buffer><script>' word word.'<CR><SID>DiscretionaryEnd<Space><C-U><BS>'
                                endfor
                              endif

FUNCTION  <SNR>188_FGforBG()
Called 147 times
Total time:   0.003693
 Self time:   0.003693

count  total (s)   self (s)
                              " takes a 6hex color code and returns a matching color that is visible
  147              0.001044   let pure = substitute(a:bg,'^#','','')
  147              0.000709   let r = eval('0x'.pure[0].pure[1])
  147              0.000569   let g = eval('0x'.pure[2].pure[3])
  147              0.000531   let b = eval('0x'.pure[4].pure[5])
  147              0.000345   if r*30 + g*59 + b*11 > 12000
  105              0.000109     return '#000000'
                              else
   42              0.000039     return '#ffffff'
                              end

FUNCTION  <SNR>66_BufReadPostHook()
Called 10 times
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
   10              0.000018     if g:syntastic_check_on_open
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufReadPost, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))))
                                    call s:UpdateErrors(1, [])
                                endif

FUNCTION  <SNR>129__isDebugEnabled_smart()
Called 70 times
Total time:   0.000199
 Self time:   0.000199

count  total (s)   self (s)
   70              0.000160     return and(g:syntastic_debug, a:level)

FUNCTION  lightline#update()
Called 30 times
Total time:   0.068844
 Self time:   0.001852

count  total (s)   self (s)
   30              0.000147   if s:_ | call lightline#init() | call lightline#colorscheme() | endif
   30              0.000094   if !s:lightline.enable.statusline | return | endif
   30              0.000072   let w = winnr()
   30   0.067299   0.000307   let s = winnr('$') == 1 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
   90              0.000170   for n in range(1, winnr('$'))
   60              0.000591     call setwinvar(n, '&statusline', s[n!=w])
   60              0.000193     call setwinvar(n, 'lightline', n!=w)
   60              0.000042   endfor

FUNCTION  <SNR>71_buffer()
Called 10 times
Total time:   0.000258
 Self time:   0.000213

count  total (s)   self (s)
   10              0.000056   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
   10              0.000062   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
   10   0.000112   0.000067   if !empty(buffer.getvar('bundler_lock'))
   10              0.000010     return buffer
                              endif
                              call s:throw('not a Bundler project: '.(a:0 ? a:1 : expand('%')))

FUNCTION  <SNR>81_gotoline()
Called 10 times
Total time:   0.000213
 Self time:   0.000213

count  total (s)   self (s)
   10              0.000037 	let file = bufname("%")
                            
                            	" :e command calls BufRead even though the file is a new one.
                            	" As a workaround Jonas Pfenniger<jonas@pfenniger.name> added an
                            	" AutoCmd BufRead, this will test if this file actually exists before
                            	" searching for a file and line to goto.
   10              0.000120 	if (filereadable(file) || file == '')
   10              0.000017 		return file
                            	endif
                            
                            	let l:names = []
                            	for regexp in s:regexpressions
                            		let l:names =  matchlist(file, regexp)
                            
                            		if ! empty(l:names)
                            			let file_name = l:names[1]
                            			let line_num  = l:names[2] == ''? '0' : l:names[2]
                            			let  col_num  = l:names[3] == ''? '0' : l:names[3]
                            			call s:reopenAndGotoLine(file_name, line_num, col_num)
                            			return file_name
                            		endif
                            	endfor

FUNCTION  <SNR>125_app_projections()
Called 61 times
Total time:   0.055886
 Self time:   0.029223

count  total (s)   self (s)
   61              0.000827   let dict = deepcopy(s:default_projections)
   61   0.002808   0.000393   if !self.has('rails3')
                                let dict['config/environment.rb'] = remove(dict, 'config/application.rb')
                              endif
   61   0.001607   0.000407   call s:combine_projections(dict, get(g:, 'rails_projections', ''))
   61              0.000257   for gem in keys(get(g:, 'rails_gem_projections', {}))
                                if self.has_gem(gem)
                                  call s:combine_projections(dict, g:rails_gem_projections[gem])
                                endif
                              endfor
   61   0.041488   0.021335   let gem_path = escape(join(values(self.gems()),','), ' ')
   61              0.000219   if !empty(gem_path)
   61              0.001018     if !has_key(s:projections_for_gems, gem_path)
                                  let gem_projections = {}
                                  for path in ['lib/', 'lib/rails/']
                                    for file in findfile(path.'projections.json', gem_path, -1)
                                      try
                                        call s:combine_projections(gem_projections, rails#json_parse(readfile(self.path(file))))
                                      catch
                                      endtry
                                    endfor
                                  endfor
                                  let s:projections_for_gems[gem_path] = gem_projections
                                endif
   61   0.002498   0.001224     call s:combine_projections(dict, s:projections_for_gems[gem_path])
   61              0.000041   endif
   61   0.000451   0.000257   if self.cache.needs('projections')
                                call self.cache.set('projections', {})
                            
                                let projections = {}
                                if self.has_path('config/projections.json')
                                  try
                                    let projections = rails#json_parse(readfile(self.path('config/projections.json')))
                                    if type(projections) == type({})
                                      call self.cache.set('projections', projections)
                                    endif
                                  catch /^invalid JSON:/
                                  endtry
                                endif
                              endif
                            
   61   0.001891   0.000464   call s:combine_projections(dict, self.cache.get('projections'))
   61              0.000055   return dict

FUNCTION  <SNR>125_define_navcommand()
Called 110 times
Total time:   0.073941
 Self time:   0.072927

count  total (s)   self (s)
  110              0.000234   if empty(a:projection)
                                return
                              endif
  110   0.001585   0.000571   let name = s:gsub(a:name, '[[:punct:][:space:]]', '')
  110              0.000586   if name !~# '^[a-z]\+$'
                                return s:error("E182: Invalid command name ".name)
                              endif
 1320              0.001969   for prefix in ['E', 'S', 'V', 'T', 'D', 'R', 'RE', 'RS', 'RV', 'RT', 'RD']
 1210              0.066867     exe 'command! -buffer -bar -bang -nargs=* ' . (prefix =~# 'D' ? '-range=0 ' : '') . '-complete=customlist,'.s:sid.'CommandList ' . prefix . name . ' :execute s:CommandEdit(' . string((prefix =~# 'D' ? '<line1>' : '') . prefix . "<bang>") . ',' . string(a:name) . ',' . string(a:projection) . ',<f-args>)' . (a:0 ? '|' . a:1 : '')
 1210              0.000991   endfor

FUNCTION  <SNR>195_GetMakePrg()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000015   return g:coffee_compiler .      ' -c' .      ' ' . b:coffee_litcoffee .      ' ' . g:coffee_make_options .      ' $*' .      ' ' . fnameescape(expand('%'))

FUNCTION  <SNR>125_app_rake_command()
Called 10 times
Total time:   0.000398
 Self time:   0.000158

count  total (s)   self (s)
   10              0.000050   if get(a:, 1, '') !=# 'static' && self.has_path('.zeus.sock') && executable('zeus')
                                return 'zeus rake'
                              elseif self.has_path('bin/rake')
   10   0.000129   0.000050     return self.ruby_script_command('bin/rake')
                              elseif self.has('bundler')
                                return 'bundle exec rake'
                              else
                                return 'rake'
                              endif

FUNCTION  <SNR>120_line()
Called 60 times
Total time:   0.065891
 Self time:   0.032292

count  total (s)   self (s)
   60              0.000152   let _ = a:tabline ? '' : '%{lightline#link()}'
   60              0.000244   if s:lightline.palette == {} | call lightline#colorscheme() | endif
   60              0.000284   let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
   60              0.000265   let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
   60              0.000233   let [c, f, t] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type]
   60              0.000149   let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
   60              0.000300   let l_ = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
   60   0.013133   0.000502   let [ll, lc, lt] = s:expand(copy(l_))
   60              0.000284   let r_ = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
   60   0.014752   0.000519   let [rl, rc, rt] = s:expand(copy(r_))
  150              0.000283   for i in range(len(lt))
   90              0.000563     let _ .= printf('%%#LightLineLeft_%s_%s#', mode, ll[i])
  300              0.000529     for j in range(len(lt[i]))
  210              0.003493       let x = substitute('%( '.(lc[i][j] ? lt[i][j] : has_key(f,lt[i][j])?'%{exists("*'.f[lt[i][j]].'")?'.f[lt[i][j]].'():""}':get(c,lt[i][j],'')).' %)', '^%(  %)', '', '')
  210              0.001365       let _ .= has_key(t,lt[i][j])&&t[lt[i][j]]==#'raw'&&strlen(x)>7 ? x[3:-2] : x
  390   0.007075   0.002388       if j < len(lt[i]) - 1 | let _ .= s:subseparator(lt[i][j], lt[i][j+1:], s.left, lc[i][j], lc[i][j+1:]) | endif
  210              0.000182     endfor
   90              0.001349     let _ .= printf('%%#LightLineLeft_%s_%s_%s#', mode, ll[i], ll[i + 1]) . (i < l + len(lt) - len(l_) && ll[i] < l || type(ll[i]) != type(ll[i + 1]) || type(ll[i]) && type(ll[i + 1]) && ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : '')
   90              0.000144   endfor
   60              0.000256   let _ .= printf('%%#LightLineMiddle_%s#%%=', mode)
  210              0.000362   for i in reverse(range(len(rt)))
  150              0.002271     let _ .= printf('%%#LightLineRight_%s_%s_%s#', mode, rl[i], rl[i + 1]) . (i < r + len(rt) - len(r_) && rl[i] < r || type(rl[i]) != type(rl[i + 1]) || type(rl[i]) && type(rl[i + 1]) && rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : '')
  150              0.000825     let _ .= printf('%%#LightLineRight_%s_%s#', mode, rl[i])
  360              0.000725     for j in range(len(rt[i]))
  330   0.003287   0.001239       if j | let _ .= s:subseparator(rt[i][j], rt[i][:j-1], s.right, rc[i][j], rc[i][:j-1]) | endif
  210              0.003011       let x = substitute('%( '.(rc[i][j] ? rt[i][j] : has_key(f,rt[i][j])?'%{exists("*'.f[rt[i][j]].'")?'.f[rt[i][j]].'():""}':get(c,rt[i][j],'')).' %)', '^%(  %)', '', '')
  210              0.001376       let _ .= has_key(t,rt[i][j])&&t[rt[i][j]]==#'raw'&&strlen(x)>7 ? x[3:-4] : x
  210              0.000246     endfor
  150              0.000094   endfor
   60              0.000077   return _

FUNCTION  <SNR>31_record()
Called 50 times
Total time:   0.027403
 Self time:   0.001426

count  total (s)   self (s)
   50              0.000138 	if s:locked | retu | en
   50              0.000112 	let bufnr = a:bufnr + 0
   50              0.000152 	let bufname = bufname(bufnr)
   50              0.000119 	if bufnr > 0 && !empty(bufname)
   50              0.000386 		cal filter(s:mrbs, 'v:val != bufnr')
   50              0.000121 		cal insert(s:mrbs, bufnr)
   50   0.026253   0.000276 		cal s:addtomrufs(bufname)
   50              0.000032 	en

FUNCTION  <SNR>71_buffer_getvar()
Called 36 times
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
   36              0.000132   return getbufvar(self['#'],a:var)

FUNCTION  <SNR>188_pow()
Called 224910 times
Total time:   1.738797
 Self time:   1.738797

count  total (s)   self (s)
224910              0.326459   let x = a:x
224910              0.615493   for i in range(a:n-1)
224910              0.289010     let x = x*a:x
224910              0.185909   return x

FUNCTION  fugitive#detect()
Called 10 times
Total time:   0.016966
 Self time:   0.001984

count  total (s)   self (s)
   10              0.000034   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
                                unlet b:git_dir
                              endif
   10              0.000018   if !exists('b:git_dir')
   10   0.006094   0.000064     let dir = fugitive#extract_git_dir(a:path)
   10              0.000013     if dir !=# ''
   10              0.000020       let b:git_dir = dir
   10              0.000006     endif
   10              0.000001   endif
   10              0.000026   if exists('b:git_dir')
   10              0.000071     if exists('#User#FugitiveBoot')
                                  try
                                    let [save_mls, &modelines] = [&mls, 0]
                                    doautocmd User FugitiveBoot
                                  finally
                                    let &mls = save_mls
                                  endtry
                                endif
   10              0.000022     if !exists('g:fugitive_no_maps')
   10              0.000195       cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
   10              0.000139       nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
   10              0.000004     endif
   10   0.000389   0.000048     let buffer = fugitive#buffer()
   10              0.000298     if expand('%:p') =~# '//'
                                  call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
                                endif
   10   0.000245   0.000195     if stridx(buffer.getvar('&tags'), escape(b:git_dir, ', ')) == -1
   10              0.000086       if filereadable(b:git_dir.'/tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
                                  endif
   10              0.000124       if &filetype !=# '' && filereadable(b:git_dir.'/'.&filetype.'.tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
                                  endif
   10              0.000003     endif
   10              0.000008     try
   10              0.000073       let [save_mls, &modelines] = [&mls, 0]
   10   0.008721   0.000160       doautocmd User Fugitive
   10              0.000008     finally
   10              0.000050       let &mls = save_mls
   10              0.000009     endtry
   10              0.000004   endif

FUNCTION  ctrlp#utils#readfile()
Called 10 times
Total time:   0.001422
 Self time:   0.001422

count  total (s)   self (s)
   10              0.000158 	if filereadable(a:file)
   10              0.001170 		let data = readfile(a:file)
   10              0.000040 		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
   10              0.000010 		retu data
                            	en
                            	retu []

FUNCTION  10()
Called 105 times
Total time:   0.003367
 Self time:   0.002437

count  total (s)   self (s)
  105              0.000177     let prependCWD = 0
  105   0.001291   0.000361     if nerdtree#runningWindows()
                                    let prependCWD = a:str !~# '^.:\(\\\|\/\)' && a:str !~# '^\(\\\\\|\/\/\)'
                                else
  105              0.000596         let prependCWD = a:str !~# '^/'
  105              0.000087     endif
                            
  105              0.000181     let toReturn = a:str
  105              0.000099     if prependCWD
                                    let toReturn = getcwd() . s:Path.Slash() . a:str
                                endif
                            
  105              0.000121     return toReturn

FUNCTION  12()
Called 81 times
Total time:   0.038974
 Self time:   0.004466

count  total (s)   self (s)
   81   0.001300   0.000359     let self.cachedDisplayString = self.flagSet.renderToString()
                            
   81   0.001338   0.000390     let self.cachedDisplayString .= self.getLastPathComponent(1)
                            
   81              0.000081     if self.isExecutable
                                    let self.cachedDisplayString = self.cachedDisplayString . '*'
                                endif
                            
   81              0.000150     let self._bookmarkNames = []
  243   0.001012   0.000504     for i in g:NERDTreeBookmark.Bookmarks()
  162   0.032742   0.000631         if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
  162              0.000113     endfor
   81              0.000146     if !empty(self._bookmarkNames)
                                    let self.cachedDisplayString .= ' {' . join(self._bookmarkNames) . '}'
                                endif
                            
   81              0.000072     if self.isSymLink
                                    let self.cachedDisplayString .=  ' -> ' . self.symLinkDest
                                endif
                            
   81              0.000072     if self.isReadOnly
                                    let self.cachedDisplayString .=  ' [RO]'
                                endif

FUNCTION  syntastic#util#stamp()
Called 20 times
Total time:   0.000317
 Self time:   0.000317

count  total (s)   self (s)
   20              0.000306     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  109()
Called 10 times
Total time:  14.314507
 Self time:   0.000143

count  total (s)   self (s)
   10  14.314504   0.000140     call self.open(a:0 ? a:1 : {})

FUNCTION  <SNR>90_repo_head()
Called 378 times
Total time:   0.048553
 Self time:   0.011904

count  total (s)   self (s)
  378   0.034731   0.002815     let head = s:repo().head_ref()
                            
  378              0.002669     if head =~# '^ref: '
  378   0.007296   0.002563       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
  378              0.000502     elseif head =~# '^\x\{40\}$'
                                  " truncate hash to a:1 characters if we're in detached head mode
                                  let len = a:0 ? a:1 : 0
                                  let branch = len ? head[0:len-1] : ''
                                else
                                  return ''
                                endif
                            
  378              0.000367     return branch

FUNCTION  <SNR>188_SetNamedColor()
Called 147 times
Total time:   3.155180
 Self time:   0.010249

count  total (s)   self (s)
  147              0.001370   let group = 'cssColor'.substitute(a:clr,'^#','','')
  147              0.001310   exe 'syn keyword '.group.' '.a:name.' contained'
  147              0.001401   exe 'syn cluster cssColors add='.group
  147              0.000522   if has('gui_running')
                                exe 'hi '.group.' guifg='.s:FGforBG(a:clr)
                                exe 'hi '.group.' guibg='.a:clr
                              elseif &t_Co == 256
  147   1.576721   0.002380     exe 'hi '.group.' ctermfg='.s:Rgb2xterm(s:FGforBG(a:clr))
  147   1.572519   0.001929     exe 'hi '.group.' ctermbg='.s:Rgb2xterm(a:clr)
  147              0.000086   endif
  147              0.000114   return 23

FUNCTION  <SNR>71_FindBundlerLock()
Called 10 times
Total time:   0.001827
 Self time:   0.001594

count  total (s)   self (s)
   10   0.000155   0.000066   let path = s:shellslash(a:path)
   10              0.000142   let fn = fnamemodify(path,':s?[\/]$??')
   10              0.000018   let ofn = ""
   10              0.000012   let nfn = fn
   40              0.000082   while fn != ofn
   40              0.000417     if filereadable(fn.'/Gemfile')
   10   0.000279   0.000135       return s:sub(simplify(fnamemodify(fn,':p')),'[\\/]$','/Gemfile.lock')
                                elseif filereadable(fn.'/gems.locked')
                                  return s:sub(simplify(fnamemodify(fn,':p')),'[\\/]$','/gems.locked')
                                endif
   30              0.000050     let ofn = fn
   30              0.000105     let fn = fnamemodify(ofn,':h')
   30              0.000030   endwhile
                              return ''

FUNCTION  21()
Called 842 times
Total time:   0.044115
 Self time:   0.005141

count  total (s)   self (s)
  842              0.001458     if self.cachedDisplayString ==# ""
   81   0.039248   0.000274         call self.cacheDisplayString()
   81              0.000050     endif
                            
  842              0.000876     return self.cachedDisplayString

FUNCTION  22()
Called 10 times
Total time:  14.298072
 Self time:   0.085859

count  total (s)   self (s)
   10  14.298069   0.085856     exec "edit " . self.str({'format': 'Edit'})

FUNCTION  23()
Called 105 times
Total time:   0.002668
 Self time:   0.001848

count  total (s)   self (s)
  105   0.001119   0.000299     if nerdtree#runningWindows()
                                    if a:fullpath =~ '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', "g")
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
                                else
  105              0.000308         let self.drive = ''
  105              0.000065     endif
                            

FUNCTION  25()
Called 23 times
Total time:   0.000331
 Self time:   0.000157

count  total (s)   self (s)
   23   0.000243   0.000069     if nerdtree#runningWindows()
                                    return " `\|\"#%&,?()\*^<>"
                                endif
                            
   23              0.000028     return " \\`\|\"#%&,?()\*^<>[]"

FUNCTION  28()
Called 2496 times
Total time:   0.027429
 Self time:   0.027429

count  total (s)   self (s)
 2496              0.004811     if empty(self.pathSegments)
                                    return ''
                                endif
 2496              0.006091     let toReturn = self.pathSegments[-1]
 2496              0.003501     if a:dirSlash && self.isDirectory
  123              0.000264         let toReturn = toReturn . '/'
  123              0.000074     endif
 2496              0.002395     return toReturn

FUNCTION  29()
Called 80 times
Total time:   0.006281
 Self time:   0.003721

count  total (s)   self (s)
   80              0.000107     let i = 0
  275              0.000575     while i < len(g:NERDTreeSortOrder)
  236   0.004288   0.001728         if  self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
   41              0.000048             return i
                                    endif
  195              0.000322         let i = i + 1
  195              0.000180     endwhile
   39              0.000051     return s:NERDTreeSortStarIndex

FUNCTION  <SNR>125_app_commands()
Called 10 times
Total time:   0.033751
 Self time:   0.009015

count  total (s)   self (s)
   10              0.000020   let commands = {}
                            
   10   0.004729   0.001026   let commands['unit test'] = map(filter([ ['test', 'test/unit/*_test.rb', "require 'test_helper'\n\nclass %STest < ActiveSupport::TestCase\nend", 'model', 1], ['test', 'test/models/*_test.rb', "require 'test_helper'\n\nclass %STest < ActiveSupport::TestCase\nend", 'model', 1], ['test', 'test/helpers/*_test.rb', "require 'test_helper'\n\nclass %STest < ActionView::TestCase\nend", '', 1], ['test', 'test/helpers/*_helper_test.rb', "require 'test_helper'\n\nclass %SHelperTest < ActionView::TestCase\nend", 'controller', 0], ['spec', 'spec/models/*_spec.rb', "require 'spec_helper'\n\ndescribe %S do\nend", 'model', 1], ['spec', 'spec/helpers/*_spec.rb', "require 'spec_helper'\n\ndescribe %S do\nend", '', 1], ['spec', 'spec/helpers/*_helper_spec.rb', "require 'spec_helper'\n\ndescribe %SHelper do\nend", 'controller', 0]], 'rails#app().has(v:val[0])'), '{"pattern": v:val[1], "template": v:val[2], "affinity": v:val[3], "complete": v:val[4]}')
   10   0.005341   0.001141   let commands['functional test'] = map(filter([ ['test', 'test/functional/*_test.rb', "require 'test_helper'\n\nclass %STest < ActionController::TestCase\nend", '', 1], ['test', 'test/functional/*_controller_test.rb', "require 'test_helper'\n\nclass %SControllerTest < ActionController::TestCase\nend", 'controller', 0], ['test', 'test/controllers/*_test.rb', "require 'test_helper'\n\nclass %STest < ActionController::TestCase\nend", '', 1], ['test', 'test/controllers/*_controller_test.rb', "require 'test_helper'\n\nclass %SControllerTest < ActionController::TestCase\nend", 'controller', 0], ['test', 'test/mailers/', "require 'test_helper'\n\nclass %STest < ActionMailer::TestCase\nend", 'model', 1], ['spec', 'spec/controllers/*_spec.rb', "require 'spec_helper'\n\ndescribe %S do\nend", '', 1], ['spec', 'spec/controllers/*_controller_spec.rb', "require 'spec_helper'\n\ndescribe %SController do\nend", 'controller', 0], ['spec', 'spec/mailers/*_spec.rb', "require 'spec_helper'\n\ndescribe %S do\nend", 'controller', 0]], 'rails#app().has(v:val[0])'), '{"pattern": v:val[1], "template": v:val[2], "affinity": v:val[3], "complete": v:val[4]}')
   10   0.006522   0.001243   let commands['integration test'] = map(filter([ ['test', 'test/integration/*_test.rb', "require 'test_helper'\n\nclass %STest < ActionDispatch::IntegrationTest\nend"], ['spec', 'spec/features/*_spec.rb', "require 'spec_helper'\n\ndescribe \"%h\" do\nend"], ['spec', 'spec/requests/*_spec.rb', "require 'spec_helper'\n\ndescribe \"%h\" do\nend"], ['spec', 'spec/integration/*_spec.rb', "require 'spec_helper'\n\ndescribe \"%h\" do\nend"], ['cucumber', 'features/*.feature', "Feature: %h"], ['turnip', 'spec/acceptance/*.feature', "Feature: %h"], ['test', 'test/test_helper.rb', ""], ['cucumber', 'features/support/env.rb', ""], ['spec', 'spec/rails_helper.rb', ""], ['spec', 'spec/spec_helper.rb', ""]], 'rails#app().has(v:val[0])'), '{"pattern": v:val[1], "template": v:val[2]}')
                            
   10   0.009434   0.000046   let all = self.projections()
  140   0.002082   0.000919   for pattern in sort(keys(all), function('rails#lencmp'))
  130              0.000270     let projection = all[pattern]
  260   0.002196   0.001193     for name in s:split(get(projection, 'command', get(projection, 'type', get(projection, 'name', ''))))
  130              0.000637       let command = { 'pattern': pattern, 'affinity': get(projection, 'affinity', '')}
  130              0.000289       if !has_key(commands, name)
   80              0.000162         let commands[name] = []
   80              0.000052       endif
  130              0.000347       call insert(commands[name], command)
  130              0.000091     endfor
  130              0.000101   endfor
   10              0.000121   call filter(commands, '!empty(v:val)')
   10              0.000010   return commands

FUNCTION  117()
Called 18 times
Total time:   0.003655
 Self time:   0.000103

count  total (s)   self (s)
   18   0.003615   0.000063     if a:path.equals(self.path)
   10              0.000010         return self
                                endif
    8              0.000005     return {}

FUNCTION  323()
Called 10 times
Total time:   0.007268
 Self time:   0.002723

count  total (s)   self (s)
   10   0.000074   0.000046     if !a:loclist.isEmpty() && !a:loclist.isNewerThan([])
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
   10   0.000123   0.000049     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
   60              0.000083     for type in self._enabled_types
   50              0.000458         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
   50   0.000955   0.000362         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
   50              0.000157             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
   20              0.000079                 if !exists('b:syntastic_private_' . type . '_stamp')
   20              0.000080                     let b:syntastic_private_{type}_stamp = []
   20              0.000016                 endif
   20   0.000548   0.000163                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
   20   0.001466   0.000093                     call self._notifier[type].refresh(a:loclist)
   20   0.000452   0.000135                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
   20              0.000020                 endif
   20              0.000013             else
   30   0.001915   0.000140                 call self._notifier[type].refresh(a:loclist)
   30              0.000016             endif
   50              0.000023         endif
   50              0.000059     endfor

FUNCTION  <SNR>71_buffer_setvar()
Called 12 times
Total time:   0.000108
 Self time:   0.000108

count  total (s)   self (s)
   12              0.000092   return setbufvar(self['#'],a:var,a:value)

FUNCTION  rails#buffer()
Called 85 times
Total time:   0.001651
 Self time:   0.001651

count  total (s)   self (s)
   85              0.001592   return extend(extend({'#': bufnr(a:0 ? a:1 : '%')},s:buffer_prototype,'keep'),s:readable_prototype,'keep')

FUNCTION  30()
Called 480 times
Total time:   0.015511
 Self time:   0.008291

count  total (s)   self (s)
  480              0.001172     if !exists("self._sortKey")
   80   0.001279   0.000340         let path = self.getLastPathComponent(1)
   80              0.000116         if !g:NERDTreeSortHiddenFirst
                                        let path = substitute(path, '^[._]', '', '')
                                    endif
   80              0.000102         if !g:NERDTreeCaseSensitiveSort
   80              0.000200             let path = tolower(path)
   80              0.000048         endif
   80   0.006901   0.000620         let self._sortKey = printf(s:sortKeyFormat, self.getSortOrderIndex()) . path
   80              0.000060     endif
                            
  480              0.000492     return self._sortKey

FUNCTION  31()
Called 997 times
Total time:   0.017094
 Self time:   0.006373

count  total (s)   self (s)
  997   0.016676   0.005955     return self.getLastPathComponent(0) =~# '^\.'

FUNCTION  33()
Called 997 times
Total time:   0.099217
 Self time:   0.037869

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
  997              0.001455     if b:NERDTreeIgnoreEnabled
 1994              0.002603         for i in g:NERDTreeIgnore
  997   0.041604   0.003859             if self._ignorePatternMatches(i)
                                            return 1
                                        endif
  997              0.000929         endfor
                            
  997   0.010451   0.003942         for callback in g:NERDTree.PathFilters()
                                        if {callback}({'path': self, 'nerdtree': b:NERDTree})
                                            return 1
                                        endif
                                    endfor
  997              0.000591     endif
                            
                                "dont show hidden files unless instructed to
  997   0.021217   0.004123     if b:NERDTreeShowHidden ==# 0 && self.isUnixHiddenFile()
   72              0.000071         return 1
                                endif
                            
  925              0.001820     if b:NERDTreeShowFiles ==# 0 && self.isDirectory ==# 0
                                    return 1
                                endif
                            
  925              0.000603     return 0

FUNCTION  34()
Called 997 times
Total time:   0.037745
 Self time:   0.026728

count  total (s)   self (s)
  997              0.001780     let pat = a:pattern
  997              0.004224     if strpart(pat,len(pat)-7) == '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
                                elseif strpart(pat,len(pat)-8) == '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
                                endif
                            
  997   0.016969   0.005952     return self.getLastPathComponent(0) =~# pat

FUNCTION  37()
Called 382 times
Total time:   0.075205
 Self time:   0.002852

count  total (s)   self (s)
  382   0.075054   0.002701     return self.str() ==# a:path.str()

FUNCTION  38()
Called 105 times
Total time:   0.031239
 Self time:   0.004136

count  total (s)   self (s)
  105              0.001963     let newPath = copy(self)
                            
  105   0.027183   0.000913     call newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:path))
                            
  105              0.000335     let newPath.cachedDisplayString = ""
  105   0.001399   0.000566     let newPath.flagSet = g:NERDTreeFlagSet.New()
                            
  105              0.000098     return newPath

FUNCTION  169()
Called 20 times
Total time:   0.000250
 Self time:   0.000195

count  total (s)   self (s)
   20              0.000025     if self._keepopen
                                    return
                                endif
                            
   20              0.000047     if (a:newtab && self._where == 't') || !a:newtab
   10   0.000096   0.000041         call g:NERDTree.CloseIfQuitOnOpen()
   10              0.000007     endif

FUNCTION  ctrlp#mrufiles#cachefile()
Called 10 times
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
   10              0.000046 	if !exists('s:cadir') || !exists('s:cafile')
                            		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
                            		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
                            	en
   10              0.000010 	retu s:cafile

FUNCTION  123()
Called 13 times
Total time:   0.002771
 Self time:   0.000132

count  total (s)   self (s)
   13   0.000089   0.000041     if !g:NERDTree.ExistsForBuf()
                                    throw "NERDTree.NoTreeError: No tree exists for the current buffer"
                                endif
                            
   13   0.002640   0.000049     return self.equals(b:NERDTreeRoot)

FUNCTION  125()
Called 82 times
Total time:   0.002798
 Self time:   0.001110

count  total (s)   self (s)
   82              0.000095     if a:path.isDirectory
   41   0.001856   0.000168         return g:NERDTreeDirNode.New(a:path)
                                else
   41              0.000458         let newTreeNode = copy(self)
   41              0.000078         let newTreeNode.path = a:path
   41              0.000082         let newTreeNode.parent = {}
   41              0.000044         return newTreeNode
                                endif

FUNCTION  126()
Called 10 times
Total time:  14.314364
 Self time:   0.000127

count  total (s)   self (s)
   10              0.000019     let opts = a:0 ? a:1 : {}
   10   0.000615   0.000053     let opener = g:NERDTreeOpener.New(self.path, opts)
   10  14.313720   0.000045     call opener.open(self)

FUNCTION  <SNR>125_pathsplit()
Called 10 times
Total time:   0.000579
 Self time:   0.000385

count  total (s)   self (s)
   10              0.000057   if type(a:path) == type([]) | return copy(a:path) | endif
   10   0.000514   0.000320   return split(s:gsub(a:path, '\\ ', ' '), ',')

FUNCTION  MyReadonly()
Called 1356 times
Total time:   0.008603
 Self time:   0.008603

count  total (s)   self (s)
 1356              0.002540   if &filetype == "help"
                                return ""
                              elseif &readonly
                                return " "
                              else
 1356              0.000963     return ""
                              endif

FUNCTION  338()
Called 20 times
Total time:   0.000303
 Self time:   0.000126

count  total (s)   self (s)
   20   0.000297   0.000120     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  nerdtree#checkForBrowse()
Called 20 times
Total time:   0.000226
 Self time:   0.000226

count  total (s)   self (s)
   20              0.000138     if a:dir != '' && isdirectory(a:dir)
                                    call g:NERDTreeCreator.CreateSecondary(a:dir)
                                endif

FUNCTION  <SNR>78_AutoClose()
Called 20 times
Total time:   0.021993
 Self time:   0.011366

count  total (s)   self (s)
                              " Add matching pair and jump to the midle:
                              " inoremap <silent> <buffer> ( ()<Left>
   20              0.000033   let i = 0
   84   0.003023   0.000595   while i < len(s:get('matchpairs_list'))
   64   0.003984   0.000711     let ld = s:get('left_delims')[i] == '|' ? '<bar>' : s:get('left_delims')[i]
   64   0.003951   0.000675     let rd = s:get('right_delims')[i] == '|' ? '<bar>' : s:get('right_delims')[i]
   64              0.001852     exec 'inoremap <expr><silent> <Plug>delimitMate' . ld. ' <SID>TriggerAbb().delimitMate#ParenDelim("' . escape(rd, '|') . '")'
   64              0.000960     exec 'silent! imap <unique> <buffer> '.ld.' <Plug>delimitMate'.ld
   64              0.000119     let i += 1
   64              0.000072   endwhile
                            
                              " Exit from inside the matching pair:
   84   0.000712   0.000180   for delim in s:get('right_delims')
   64              0.000163     let delim = delim == '|' ? '<bar>' : delim
   64              0.001398     exec 'inoremap <expr><silent> <Plug>delimitMate' . delim. ' <SID>TriggerAbb().delimitMate#JumpOut("\' . delim . '")'
   64              0.000936     exec 'silent! imap <unique> <buffer> ' . delim. ' <Plug>delimitMate'. delim
   64              0.000054   endfor
                            
                              " Add matching quote and jump to the midle, or exit if inside a pair of matching quotes:
                              " inoremap <silent> <buffer> " <C-R>=delimitMate#QuoteDelim("\"")<CR>
   80   0.000758   0.000184   for delim in s:get('quotes_list')
   60              0.000104     if delim == '|'
                                  let delim = '<Bar>'
                                endif
   60              0.001408     exec 'inoremap <expr><silent> <Plug>delimitMate' . delim. ' <SID>TriggerAbb()."<C-R>=delimitMate#QuoteDelim(\"\\\' . delim . '\")<CR>"'
   60              0.000869     exec 'silent! imap <unique> <buffer> ' . delim. ' <Plug>delimitMate' . delim
   60              0.000049   endfor
                            
                              " Try to fix the use of apostrophes (kept for backward compatibility):
                              " inoremap <silent> <buffer> n't n't
   20   0.000637   0.000093   for map in s:get('apostrophes_list')
                                exec "inoremap <silent> " . map . " " . map
                                exec 'silent! imap <unique> <buffer> ' . map . ' <Plug>delimitMate' . map
                              endfor

FUNCTION  40()
Called 210 times
Total time:   0.005349
 Self time:   0.005349

count  total (s)   self (s)
  210              0.002660     let tmp = resolve(a:path)
  210              0.002560     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  41()
Called 105 times
Total time:   0.022903
 Self time:   0.011235

count  total (s)   self (s)
  105   0.003095   0.000427     call self.extractDriveLetter(a:fullpath)
                            
  105   0.001851   0.000500     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
  105              0.000952     if getftype(fullpath) ==# "fifo"
                                    throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
                                endif
                            
  105              0.000906     let self.pathSegments = split(fullpath, '/')
                            
  105              0.000291     let self.isReadOnly = 0
  105              0.000530     if isdirectory(a:fullpath)
   54              0.000157         let self.isDirectory = 1
   54              0.000083     elseif filereadable(a:fullpath)
   51              0.000190         let self.isDirectory = 0
   51              0.000490         let self.isReadOnly = filewritable(a:fullpath) ==# 0
   51              0.000047     else
                                    throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
                                endif
                            
  105              0.000273     let self.isExecutable = 0
  105              0.000116     if !self.isDirectory
   51              0.000404         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
   51              0.000045     endif
                            
                                "grab the last part of the path (minus the trailing slash)
  105   0.001800   0.000556     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
  105   0.004613   0.000863     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
  105   0.003559   0.000904     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
  105              0.000136     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
                                endif

FUNCTION  45()
Called 1283 times
Total time:   0.121354
 Self time:   0.054516

count  total (s)   self (s)
 1283              0.002853     let options = a:0 ? a:1 : {}
 1283              0.001680     let toReturn = ""
                            
 1283              0.002667     if has_key(options, 'format')
   85              0.000174         let format = options['format']
   85              0.000238         if has_key(self, '_strFor' . format)
   85   0.002635   0.000615             exec 'let toReturn = self._strFor' . format . '()'
   85              0.000056         else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
   85              0.000037     else
 1198   0.062933   0.004918         let toReturn = self._str()
 1198              0.000950     endif
                            
 1283   0.009475   0.004817     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
 1283              0.002446     if has_key(options, 'truncateTo')
   13              0.000027         let limit = options['truncateTo']
   13              0.000038         if len(toReturn) > limit-1
   13              0.000056             let toReturn = toReturn[(len(toReturn)-limit+1):]
   13              0.000095             if len(split(toReturn, '/')) > 1
   13              0.000133                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
   13              0.000009             else
                                            let toReturn = '<' . toReturn
                                        endif
   13              0.000005         endif
   13              0.000008     endif
                            
 1283              0.001395     return toReturn

FUNCTION  46()
Called 62 times
Total time:   0.000846
 Self time:   0.000846

count  total (s)   self (s)
   62              0.000380     let toReturn = '/' . join(self.pathSegments, '/')
   62              0.000143     if self.isDirectory && toReturn != '/'
   62              0.000123         let toReturn  = toReturn . '/'
   62              0.000043     endif
   62              0.000068     return toReturn

FUNCTION  48()
Called 10 times
Total time:   0.001652
 Self time:   0.000495

count  total (s)   self (s)
   10   0.001325   0.000168     let p = escape(self.str(), self._escChars())
                            
                                "make it relative
   10              0.000194     let p = fnamemodify(p, ':.')
                            
                                "handle the edge case where the file begins with a + (vim interprets
                                "the +foo in `:e +foo` as an option to :edit)
   10              0.000036     if p[0] == "+"
                                    let p = '\' . p
                                endif
                            
   10              0.000014     if p ==# ''
                                    let p = '.'
                                endif
                            
   10              0.000009     return p

FUNCTION  49()
Called 13 times
Total time:   0.001174
 Self time:   0.000486

count  total (s)   self (s)
   13   0.000217   0.000053     let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
   13   0.000133   0.000034     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
   13   0.000251   0.000105     let toReturn = lead . join(self.pathSegments, s:Path.Slash())
                            
   13   0.000132   0.000035     if !nerdtree#runningWindows()
   13   0.000342   0.000160         let toReturn = escape(toReturn, self._escChars())
   13              0.000008     endif
   13              0.000013     return toReturn

FUNCTION  <SNR>125_BufAbbreviations()
Called 10 times
Total time:   0.047816
 Self time:   0.003344

count  total (s)   self (s)
                              " Some of these were cherry picked from the TextMate snippets
   10              0.000034   if !exists('g:rails_no_abbreviations')
   10   0.000241   0.000039     let buffer = rails#buffer()
                                " Limit to the right filetypes.  But error on the liberal side
   10   0.000686   0.000070     if buffer.type_name('controller','view','helper','test-functional','test-integration')
    1   0.000186   0.000011       Rabbrev pa[ params
    1   0.000175   0.000011       Rabbrev rq[ request
    1   0.000181   0.000010       Rabbrev rs[ response
    1   0.000173   0.000011       Rabbrev se[ session
    1   0.000180   0.000010       Rabbrev hd[ headers
    1   0.000175   0.000010       Rabbrev coo[ cookies
    1   0.000172   0.000010       Rabbrev fl[ flash
    1   0.000162   0.000010       Rabbrev rr( render
    1   0.000160   0.000011       Rabbrev rf( render :file\ =>\ 
    1   0.000166   0.000010       Rabbrev rj( render :json\ =>\ 
    1   0.000160   0.000010       Rabbrev rp( render :partial\ =>\ 
    1   0.000159   0.000011       Rabbrev rt( render :text\ =>\ 
    1   0.000170   0.000011       Rabbrev rx( render :xml\ =>\ 
                                  " ))))))
    1              0.000001     endif
   10   0.000421   0.000053     if buffer.type_name('view','helper')
    1   0.000186   0.000012       Rabbrev dotiw distance_of_time_in_words
    1   0.000186   0.000011       Rabbrev taiw  time_ago_in_words
    1              0.000001     endif
   10   0.000360   0.000047     if buffer.type_name('controller')
                                  Rabbrev re(  redirect_to
                                  Rabbrev rst( respond_to
                                  " ))
                                endif
   10   0.000630   0.000077     if buffer.type_name() ==# 'model' || buffer.type_name('model-arb')
                                  Rabbrev bt(    belongs_to
                                  Rabbrev ho(    has_one
                                  Rabbrev hm(    has_many
                                  Rabbrev habtm( has_and_belongs_to_many
                                  Rabbrev co(    composed_of
                                  Rabbrev va(    validates_associated
                                  Rabbrev vb(    validates_acceptance_of
                                  Rabbrev vc(    validates_confirmation_of
                                  Rabbrev ve(    validates_exclusion_of
                                  Rabbrev vf(    validates_format_of
                                  Rabbrev vi(    validates_inclusion_of
                                  Rabbrev vl(    validates_length_of
                                  Rabbrev vn(    validates_numericality_of
                                  Rabbrev vp(    validates_presence_of
                                  Rabbrev vu(    validates_uniqueness_of
                                  " )))))))))))))))
                                endif
   10   0.000416   0.000053     if buffer.type_name('db-migration','db-schema')
    1   0.000172   0.000011       Rabbrev mac(  add_column
    1   0.000179   0.000015       Rabbrev mrnc( rename_column
    1   0.000164   0.000010       Rabbrev mrc(  remove_column
    1   0.000169   0.000010       Rabbrev mct(  create_table
    1   0.000158   0.000010       Rabbrev mcht( change_table
    1   0.000157   0.000010       Rabbrev mrnt( rename_table
    1   0.000164   0.000010       Rabbrev mdt(  drop_table
                                  " )))))))
    1              0.000001     endif
   10   0.000356   0.000045     if buffer.type_name('test')
                                  Rabbrev ase(  assert_equal
                                  Rabbrev asko( assert_kind_of
                                  Rabbrev asnn( assert_not_nil
                                  Rabbrev asr(  assert_raise
                                  Rabbrev asre( assert_response
                                  Rabbrev art(  assert_redirected_to
                                  " ))))))
                                endif
   10   0.001737   0.000105     Rabbrev logd( logger.debug
   10   0.001619   0.000103     Rabbrev logi( logger.info
   10   0.001599   0.000102     Rabbrev logw( logger.warn
   10   0.001655   0.000100     Rabbrev loge( logger.error
   10   0.001612   0.000103     Rabbrev logf( logger.fatal
   10   0.001792   0.000098     Rabbrev AR::  ActiveRecord
   10   0.001835   0.000132     Rabbrev AV::  ActionView
   10   0.001800   0.000108     Rabbrev AC::  ActionController
   10   0.001849   0.000109     Rabbrev AD::  ActionDispatch
   10   0.001799   0.000107     Rabbrev AS::  ActiveSupport
   10   0.001800   0.000103     Rabbrev AM::  ActionMailer
   10   0.001848   0.000132     Rabbrev AO::  ActiveModel
   10   0.001786   0.000106     Rabbrev AJ::  ActiveJob
                                " )))))
   10              0.000068     for pairs in items(type(get(g:, 'rails_abbreviations', 0)) == type({}) ? g:rails_abbreviations : {})
                                  call call(function(s:sid.'Abbrev'), [0, pairs[0]] + s:split(pairs[1]))
                                endfor
   10   0.017163   0.000259     for hash in reverse(rails#buffer().projected('abbreviations'))
                                  for pairs in items(hash)
                                    call call(function(s:sid.'Abbrev'), [0, pairs[0]] + s:split(pairs[1]))
                                  endfor
                                endfor
   10              0.000009   endif

FUNCTION  <SNR>125_HiDefaults()
Called 7 times
Total time:   0.001435
 Self time:   0.001435

count  total (s)   self (s)
    7              0.000040   hi def link rubyRailsAPIMethod              rubyRailsMethod
    7              0.000029   hi def link rubyRailsARAssociationMethod    rubyRailsARMethod
    7              0.000027   hi def link rubyRailsARCallbackMethod       rubyRailsARMethod
    7              0.000031   hi def link rubyRailsARClassMethod          rubyRailsARMethod
    7              0.000029   hi def link rubyRailsARValidationMethod     rubyRailsARMethod
    7              0.000030   hi def link rubyRailsARMethod               rubyRailsMethod
    7              0.000026   hi def link rubyRailsRenderMethod           rubyRailsMethod
    7              0.000028   hi def link rubyRailsHelperMethod           rubyRailsMethod
    7              0.000030   hi def link rubyRailsViewMethod             rubyRailsMethod
    7              0.000029   hi def link rubyRailsMigrationMethod        rubyRailsMethod
    7              0.000028   hi def link rubyRailsControllerMethod       rubyRailsMethod
    7              0.000027   hi def link rubyRailsFilterMethod           rubyRailsMethod
    7              0.000029   hi def link rubyRailsTestControllerMethod   rubyRailsTestMethod
    7              0.000030   hi def link rubyRailsTestViewMethod         rubyRailsTestMethod
    7              0.000026   hi def link rubyRailsTestHelperMethod       rubyRailsTestMethod
    7              0.000029   hi def link rubyRailsTestMethod             rubyRailsMethod
    7              0.000029   hi def link rubyRailsRakeMethod             rubyRailsMethod
    7              0.000027   hi def link rubyRailsMethod                 railsMethod
    7              0.000029   hi def link rubyRailsInclude                rubyInclude
    7              0.000029   hi def link rubyRailsUserClass              railsUserClass
    7              0.000028   hi def link rubyRailsUserMethod             railsUserMethod
    7              0.000027   hi def link erubyRailsHelperMethod          erubyRailsMethod
    7              0.000029   hi def link erubyRailsViewMethod            erubyRailsMethod
    7              0.000026   hi def link erubyRailsRenderMethod          erubyRailsMethod
    7              0.000027   hi def link erubyRailsMethod                railsMethod
    7              0.000028   hi def link erubyRailsUserMethod            railsUserMethod
    7              0.000027   hi def link erubyRailsUserClass             railsUserClass
    7              0.000028   hi def link hamlRailsHelperMethod           hamlRailsMethod
    7              0.000024   hi def link hamlRailsViewMethod             hamlRailsMethod
    7              0.000026   hi def link hamlRailsRenderMethod           hamlRailsMethod
    7              0.000026   hi def link hamlRailsMethod                 railsMethod
    7              0.000026   hi def link hamlRailsUserMethod             railsUserMethod
    7              0.000026   hi def link hamlRailsUserClass              railsUserClass
    7              0.000028   hi def link railsUserMethod                 railsMethod
    7              0.000056   hi def link yamlRailsDelimiter              Delimiter
    7              0.000026   hi def link yamlRailsMethod                 railsMethod
    7              0.000047   hi def link yamlRailsComment                Comment
    7              0.000027   hi def link yamlRailsUserClass              railsUserClass
    7              0.000027   hi def link yamlRailsUserMethod             railsUserMethod
    7              0.000027   hi def link javascriptRailsFunction         railsMethod
    7              0.000027   hi def link railsUserClass                  railsClass
    7              0.000044   hi def link railsMethod                     Function
    7              0.000043   hi def link railsClass                      Type
    7              0.000028   hi def link railsOrderSpecial               railsStringSpecial
    7              0.000028   hi def link railsConditionsSpecial          railsStringSpecial
    7              0.000046   hi def link railsStringSpecial              Identifier

FUNCTION  130()
Called 13 times
Total time:   0.026831
 Self time:   0.000394

count  total (s)   self (s)
   13   0.026549   0.000112     let ln = b:NERDTree.ui.getLineNum(self)
   13              0.000013     if ln != -1
   13              0.000013         if a:isJump
                                        mark '
                                    endif
   13              0.000042         call cursor(ln, col("."))
   13              0.000009     else
                                    if a:recurseUpward
                                        let node = self
                                        while node != {} && b:NERDTree.ui.getLineNum(node) ==# -1
                                            let node = node.parent
                                            call node.open()
                                        endwhile
                                        call b:NERDTree.render()
                                        call node.putCursorHere(a:isJump, 0)
                                    endif
                                endif

FUNCTION  134()
Called 13 times
Total time:   0.235171
 Self time:   0.000126

count  total (s)   self (s)
   13   0.235166   0.000121     return self._renderToString(0, 0, [], self.getChildCount() ==# 1)

FUNCTION  135()
Called 855 times
Total time:   0.633479
 Self time:   0.546634

count  total (s)   self (s)
  855              0.001363     let output = ""
  855              0.000941     if a:drawText ==# 1
                            
  842              0.001123         let treeParts = ''
                            
                                    "get all the leading spaces and vertical tree parts for this line
  842              0.000891         if a:depth > 1
 1521              0.002704             for j in a:vertMap[0:-2]
  887              0.001019                 if g:NERDTreeDirArrows
  887              0.001851                     let treeParts = treeParts . '  '
  887              0.000589                 else
                                                if j ==# 1
                                                    let treeParts = treeParts . '| '
                                                else
                                                    let treeParts = treeParts . '  '
                                                endif
                                            endif
  887              0.000960             endfor
  634              0.000374         endif
                            
                                    "get the last vertical tree part for this line which will be different
                                    "if this node is the last child of its parent
  842              0.000911         if !g:NERDTreeDirArrows
                                        if a:isLastChild
                                            let treeParts = treeParts . '`'
                                        else
                                            let treeParts = treeParts . '|'
                                        endif
                                    endif
                            
                                    "smack the appropriate dir/file symbol on the line before the file/dir
                                    "name itself
  842              0.000977         if self.path.isDirectory
  372              0.000370             if self.isOpen
  104              0.000098                 if g:NERDTreeDirArrows
  104              0.000219                     let treeParts = treeParts . ' '
  104              0.000068                 else
                                                let treeParts = treeParts . '~'
                                            endif
  104              0.000047             else
  268              0.000257                 if g:NERDTreeDirArrows
  268              0.000566                     let treeParts = treeParts . ' '
  268              0.000153                 else
                                                let treeParts = treeParts . '+'
                                            endif
  268              0.000141             endif
  372              0.000161         else
  470              0.000455             if g:NERDTreeDirArrows
  470              0.000952                 let treeParts = treeParts . '  '
  470              0.000285             else
                                            let treeParts = treeParts . '-'
                                        endif
  470              0.000229         endif
  842   0.051088   0.003831         let line = treeParts . self.displayString()
                            
  842              0.002098         let output = output . line . "\n"
  842              0.000515     endif
                            
                                "if the node is an open dir, draw its children
  855              0.001316     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
  117   0.100825   0.000575         let childNodesToDraw = self.getVisibleChildren()
  117              0.000239         if len(childNodesToDraw) > 0
                            
                                        "draw all the nodes children except the last
  117              0.000352             let lastIndx = len(childNodesToDraw)-1
  117              0.000124             if lastIndx > 0
  832              0.001087                 for i in childNodesToDraw[0:lastIndx-1]
  725              0.004791                     let output = output . i._renderToString(a:depth + 1, 1, add(copy(a:vertMap), 1), 0)
  725              0.000664                 endfor
  107              0.000061             endif
                            
                                        "draw the last child, indicating that it IS the last
  117              0.000863             let output = output . childNodesToDraw[lastIndx]._renderToString(a:depth + 1, 1, add(copy(a:vertMap), 0), 1)
  117              0.000079         endif
  117              0.000053     endif
                            
  855              0.000842     return output

FUNCTION  137()
Called 13 times
Total time:   0.336885
 Self time:   0.000211

count  total (s)   self (s)
   13              0.000026     let opts = a:0 ? a:1 : {}
   13   0.069432   0.000051     call self.toggleOpen(opts)
   13   0.240517   0.000055     call b:NERDTree.render()
   13   0.026895   0.000064     call self.putCursorHere(0, 0)

FUNCTION  138()
Called 82 times
Total time:   0.000732
 Self time:   0.000732

count  total (s)   self (s)
   82              0.000229     call add(self.children, a:treenode)
   82              0.000142     let a:treenode.parent = self
                            
   82              0.000078     if a:inOrder
                                    call self.sortChildren()
                                endif

FUNCTION  <SNR>125_startswith()
Called 447 times
Total time:   0.002162
 Self time:   0.002162

count  total (s)   self (s)
  447              0.001934   return strpart(a:string, 0, strlen(a:prefix)) ==# a:prefix

FUNCTION  <SNR>71_project_lock()
Called 75 times
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
   75              0.000109   return self._lock

FUNCTION  341()
Called 10 times
Total time:   0.000407
 Self time:   0.000385

count  total (s)   self (s)
   10              0.000020     let loclist = a:loclist
   10   0.000052   0.000030     if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
                                endif

FUNCTION  342()
Called 10 times
Total time:   0.000132
 Self time:   0.000132

count  total (s)   self (s)
   10              0.000029     if has('signs')
   10              0.000033         for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
                                    endfor
   10              0.000007     endif

FUNCTION  343()
Called 10 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
   10              0.000029     if !exists('b:syntastic_private_sign_ids')
   10              0.000025         let b:syntastic_private_sign_ids = []
   10              0.000004     endif
   10              0.000012     return b:syntastic_private_sign_ids

FUNCTION  <SNR>125_SetBasePath()
Called 10 times
Total time:   0.089811
 Self time:   0.005381

count  total (s)   self (s)
   10   0.000218   0.000034   let self = rails#buffer()
   10   0.000602   0.000095   if self.app().path() =~ '://'
                                return
                              endif
   10   0.000172   0.000086   let add_dot = self.getvar('&path') =~# '^\.\%(,\|$\)'
   10   0.000850   0.000110   let old_path = s:pathsplit(s:sub(self.getvar('&path'),'^\.%(,|$)',''))
                            
   10              0.000021   let path = ['lib', 'vendor']
   10              0.000031   let path += get(g:, 'rails_path_additions', [])
   10              0.000023   let path += get(g:, 'rails_path', [])
   10              0.000058   let path += ['app/models/concerns', 'app/controllers/concerns', 'app/controllers', 'app/helpers', 'app/mailers', 'app/models']
                            
  140   0.009966   0.000436   for [key, projection] in items(self.app().projections())
  130              0.000437     if get(projection, 'path', 0) is 1 || get(projection, 'autoload', 0) is 1
                                  let path += split(key, '*')[0]
                                endif
  130              0.000069   endfor
   10   0.016764   0.000165   let path += filter(self.projected('path'), 'type(v:val) == type("")')
                            
   10              0.000028   let path += ['app/*', 'app/views']
   10   0.017749   0.000056   if self.controller_name() != ''
    4   0.007119   0.000038     let path += ['app/views/'.self.controller_name(), 'app/views/application', 'public']
    4              0.000004   endif
   10   0.000932   0.000123   if self.app().has('test')
                                let path += ['test', 'test/unit', 'test/functional', 'test/integration', 'test/controllers', 'test/helpers', 'test/mailers', 'test/models']
                              endif
   10   0.000851   0.000084   if self.app().has('spec')
   10              0.000088     let path += ['spec', 'spec/controllers', 'spec/helpers', 'spec/mailers', 'spec/models', 'spec/views', 'spec/lib', 'spec/features', 'spec/requests', 'spec/integration']
   10              0.000006   endif
   10   0.000840   0.000076   if self.app().has('cucumber')
                                let path += ['features']
                              endif
   10              0.000051   let path += ['vendor/plugins/*/lib', 'vendor/plugins/*/test', 'vendor/rails/*/lib', 'vendor/rails/*/test']
   10   0.006707   0.001356   call map(path, 'rails#app().path(v:val)')
   10   0.004299   0.000256   let engine_paths = map(copy(self.app().engines()), 'v:val . "/app/*"')
   10   0.021399   0.001123   call self.setvar('&path',(add_dot ? '.,' : '').s:pathjoin(s:uniq(path + [self.app().path()] + old_path + engine_paths)))

FUNCTION  51()
Called 105 times
Total time:   0.001056
 Self time:   0.001056

count  total (s)   self (s)
  105              0.001015     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  52()
Called 10 times
Total time:   0.001773
 Self time:   0.000817

count  total (s)   self (s)
   10   0.001000   0.000044     let str = self.str()
   20              0.000049     for t in range(tabpagenr('$'))
   30              0.000064         for b in tabpagebuflist(t+1)
   20              0.000466             if str == expand('#' . b . ':p')
                                            return t+1
                                        endif
   20              0.000010         endfor
   10              0.000008     endfor
   10              0.000009     return 0

FUNCTION  53()
Called 105 times
Total time:   0.001351
 Self time:   0.000524

count  total (s)   self (s)
  105   0.001150   0.000323     if !nerdtree#runningWindows()
  105              0.000127         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', "g")
                            
                                return toReturn

FUNCTION  <SNR>108_Highlight_Matching_Pair()
Called 173 times
Total time:   0.014982
 Self time:   0.014982

count  total (s)   self (s)
                              " Remove any previous match.
  173              0.000528   if exists('w:paren_hl_on') && w:paren_hl_on
   16              0.000039     3match none
   16              0.000039     let w:paren_hl_on = 0
   16              0.000013   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  173              0.000768   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  173              0.000574   let c_lnum = line('.')
  173              0.000393   let c_col = col('.')
  173              0.000202   let before = 0
                            
  173              0.000789   let c = getline(c_lnum)[c_col - 1]
  173              0.002754   let plist = split(&matchpairs, '.\zs[:,]')
  173              0.000596   let i = index(plist, c)
  173              0.000205   if i < 0
                                " not found, in Insert mode try character before the cursor
  157              0.000348     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = 1
                                  let c = getline(c_lnum)[c_col - 2]
                                  let i = index(plist, c)
                                endif
  157              0.000136     if i < 0
                                  " not found, nothing to do
  157              0.000146       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
   16              0.000019   if i % 2 == 0
   16              0.000024     let s_flags = 'nW'
   16              0.000044     let c2 = plist[i + 1]
   16              0.000010   else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
   16              0.000033   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   16              0.000017   if before > 0
                                let save_cursor = winsaveview()
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " When not in a string or comment ignore matches inside them.
                              " We match "escape" for special items, such as lispEscapeSpecial.
   16              0.000061   let s_skip ='synIDattr(synID(line("."), col("."), 0), "name") ' . '=~?  "string\\|character\\|singlequote\\|escape\\|comment"'
   16              0.001319   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
   16              0.000134   let stoplinebottom = line('w$')
   16              0.000043   let stoplinetop = line('w0')
   16              0.000019   if i % 2 == 0
   16              0.000025     let stopline = stoplinebottom
   16              0.000012   else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   16              0.000048   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
   16              0.000069     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   16              0.000004   endif
   16              0.000015   try
   16              0.000727     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
   16              0.000028   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
   16              0.000016   if before > 0
                                call winrestview(save_cursor)
                              endif
                            
                              " If a match is found setup match highlighting.
   16              0.000037   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   16              0.000474     exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
   16              0.000043     let w:paren_hl_on = 1
   16              0.000010   endif

FUNCTION  <SNR>32_TmuxWinCmd()
Called 10 times
Total time:   0.042430
 Self time:   0.000212

count  total (s)   self (s)
   10   0.000174   0.000093   if s:InTmuxSession()
   10   0.042201   0.000064     call s:TmuxAwareNavigate(a:direction)
   10              0.000002   else
                                call s:VimNavigate(a:direction)
                              endif

FUNCTION  141()
Called 82 times
Total time:   0.004436
 Self time:   0.000906

count  total (s)   self (s)
   82   0.003190   0.000392     let newTreeNode = g:NERDTreeFileNode.New(a:path)
   82   0.001081   0.000349     call self.addChild(newTreeNode, a:inOrder)
   82              0.000087     return newTreeNode

FUNCTION  142()
Called 202 times
Total time:   0.192048
 Self time:   0.042893

count  total (s)   self (s)
  202   0.040306   0.000764     if a:path.equals(self.path)
   13              0.000013         return self
                                endif
  189   0.036756   0.001581     if stridx(a:path.str(), self.path.str(), 0) ==# -1
  133              0.000135         return {}
                                endif
                            
   56              0.000070     if self.path.isDirectory
  197              0.000272         for i in self.children
  197   0.004314   0.000659             let retVal = i.findNode(a:path)
  197              0.000284             if retVal != {}
   56              0.000050                 return retVal
                                        endif
  141              0.000120         endfor
                                endif
                                return {}

FUNCTION  143()
Called 26 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
   26              0.000053     return len(self.children)

FUNCTION  145()
Called 2 times
Total time:   0.000272
 Self time:   0.000026

count  total (s)   self (s)
    2   0.000257   0.000011     let array_to_search = a:visible? self.getVisibleChildren() : self.children
    2              0.000004     if a:indx > len(array_to_search)
                                    throw "NERDTree.InvalidArgumentsError: Index is out of bounds."
                                endif
    2              0.000004     return array_to_search[a:indx]

FUNCTION  148()
Called 13 times
Total time:   0.008969
 Self time:   0.000068

count  total (s)   self (s)
   13   0.008966   0.000065     return len(self.getVisibleChildren())

FUNCTION  149()
Called 132 times
Total time:   0.109397
 Self time:   0.010180

count  total (s)   self (s)
  132              0.000212     let toReturn = []
 1129              0.001155     for i in self.children
  997   0.103231   0.004014         if i.path.ignore() ==# 0
  925              0.002109             call add(toReturn, i)
  925              0.000599         endif
  997              0.000695     endfor
  132              0.000116     return toReturn

FUNCTION  <SNR>125_readable_find_affinity()
Called 14 times
Total time:   0.020073
 Self time:   0.003361

count  total (s)   self (s)
   14   0.002426   0.000059   let f = self.name()
   14   0.013218   0.000093   let all = self.app().projections()
  126   0.002792   0.001777   for pattern in reverse(sort(filter(keys(all), 'v:val =~# "^[^*{}]*\\*[^*{}]*$"'), s:function('rails#lencmp')))
  112              0.000304     if !has_key(all[pattern], 'affinity')
   70              0.000063       continue
                                endif
   42              0.000279     let [prefix, suffix; _] = split(pattern, '\*', 1)
   42   0.000449   0.000244     if s:startswith(f, prefix) && s:endswith(f, suffix)
                                  let root = f[strlen(prefix) : -strlen(suffix)-1]
                                  return [all[pattern].affinity, root]
                                endif
   42              0.000027   endfor
   14              0.000019   return ['', '']

FUNCTION  <SNR>71_project_paths()
Called 75 times
Total time:   0.015753
 Self time:   0.012186

count  total (s)   self (s)
   75   0.003879   0.000312   call self.locked()
   75              0.000209   let time = get(self, '_lock_time', -1)
   75              0.000240   if a:0 && a:1 ==# 'refresh' || time != -1 && time != get(self, '_path_time', -1)
                                let paths = {}
                            
                                let chdir = exists("*haslocaldir") && haslocaldir() ? "lchdir" : "chdir"
                                let cwd = getcwd()
                            
                                " Explicitly setting $PATH means /etc/zshenv on OS X can't touch it.
                                if executable('env')
                                  let prefix = 'env PATH='.s:shellesc($PATH).' '
                                else
                                  let prefix = ''
                                endif
                            
                                let gem_paths = []
                                if exists('$GEM_PATH')
                                  let gem_paths = split($GEM_PATH, has('win32') ? ';' : ':')
                                endif
                            
                                try
                                  exe chdir s:fnameescape(self.path())
                            
                                  if len(gem_paths) == 0
                                    let gem_paths = split(system(prefix.'ruby -rubygems -e "print Gem.path.join(%(;))"'), ';')
                                  endif
                            
                                  let abi_version = system('ruby -rrbconfig -e "print RbConfig::CONFIG[\"ruby_version\"]"')
                                  exe chdir s:fnameescape(cwd)
                                finally
                                  exe chdir s:fnameescape(cwd)
                                endtry
                            
                                for config in [expand('~/.bundle/config'), self.path('.bundle/config')]
                                  if filereadable(config)
                                    let body = join(readfile(config), "\n")
                                    let bundle_path = matchstr(body, "\\C\\<BUNDLE_PATH: [\"']\\=\\zs[^\n'\"]*")
                                    if !empty(bundle_path)
                                      if body =~# '\C\<BUNDLE_DISABLE_SHARED_GEMS:'
                                        let gem_paths = [self.path(bundle_path, 'ruby', abi_version)]
                                      else
                                        let gem_paths = [self.path(bundle_path)]
                                      endif
                                    endif
                                  endif
                                endfor
                            
                                let git_sudo_install_path = expand('~/.bundler/ruby/').abi_version
                                for source in self._locked.git
                                  for [name, ver] in items(source.versions)
                                    for path in gem_paths
                                      let dir = path . '/bundler/gems/' . matchstr(source.remote, '.*/\zs.\{-\}\ze\%(\.git\)\=$') . '-' . source.revision[0:11]
                                      if isdirectory(dir)
                                        let files = split(glob(dir . '/*/' . name . '.gemspec'), "\n")
                                        if empty(files)
                                          let paths[name] = dir
                                        else
                                          let paths[name] = files[0][0 : -10-strlen(name)]
                                        endif
                                        break
                                      endif
                                    endfor
                                    let dir = git_sudo_install_path . '/' . matchstr(source.remote, '.*/\zs.\{-\}\ze\%(\.git\)\=$') . '-' . source.revision[0:11]
                                    if isdirectory(dir)
                                      let files = split(glob(dir . '/*/' . name . '.gemspec'), "\n")
                                      if empty(files)
                                        let paths[name] = dir
                                      else
                                        let paths[name] = files[0][0 : -10-strlen(name)]
                                      endif
                                    endif
                                  endfor
                                endfor
                            
                                for source in self._locked.path
                                  for [name, ver] in items(source.versions)
                                    if source.remote =~# '^\~/'
                                      let local = expand(source.remote)
                                    elseif source.remote !~# '^/'
                                      let local = simplify(self.path(source.remote))
                                    else
                                      let local = source.remote
                                    endif
                                    let files = split(glob(local . '/*/' . name . '.gemspec'), "\n")
                                    if empty(files)
                                      let paths[name] = local
                                    else
                                      let paths[name] = files[0][0 : -10-strlen(name)]
                                    endif
                                  endfor
                                endfor
                            
                                for source in self._locked.gem
                                  for [name, ver] in items(source.versions)
                                    for path in gem_paths
                                      let dir = path . '/gems/' . name . '-' . ver
                                      if isdirectory(dir)
                                        let paths[name] = dir
                                        break
                                      endif
                                    endfor
                                    if !has_key(paths, name)
                                      for path in gem_paths
                                        let dir = glob(path . '/gems/' . name . '-' . ver . '-*')
                                        if isdirectory(dir)
                                          let paths[name] = dir
                                          break
                                        endif
                                      endfor
                                    endif
                                  endfor
                                endfor
                            
                                if has_key(self, '_projections_list')
                                  call remove(self, '_projections_list')
                                endif
                                let self._path_time = time
                                let self._paths = paths
                                let self._sorted = sort(values(paths))
                                let index = index(self._sorted, self.path())
                                if index > 0
                                  call insert(self._sorted, remove(self._sorted,index))
                                endif
                                call self.alter_buffer_paths()
                                return paths
                              endif
   75              0.000180   return get(self,'_paths',{})

FUNCTION  <SNR>125_readable_projected()
Called 27 times
Total time:   0.045375
 Self time:   0.011566

count  total (s)   self (s)
   27   0.004990   0.000138   let f = self.name()
   27   0.026141   0.000193   let all = self.app().projections()
   27              0.000039   let mine = []
   27              0.000056   if has_key(all, f)
    3   0.000050   0.000028     let mine += map(s:getlist(all[f], a:key), 's:expand_placeholders(v:val, a:0 ? a:1 : {})')
    3              0.000003   endif
  243   0.005420   0.003450   for pattern in reverse(sort(filter(keys(all), 'v:val =~# "^[^*{}]*\\*[^*{}]*$"'), s:function('rails#lencmp')))
  216              0.001403     let [prefix, suffix; _] = split(pattern, '\*', 1)
  216   0.002265   0.001248     if s:startswith(f, prefix) && s:endswith(f, suffix)
                                  let root = f[strlen(prefix) : -strlen(suffix)-1]
                                  let ph = extend({ 'match': root, 'file': self.path(), 'project': self.app().path(), 's': root, 'S': rails#camelize(root), 'h': toupper(root[0]) . tr(rails#underscore(root), '_', ' ')[1:-1], 'p': rails#pluralize(root), 'i': rails#singularize(root), '%': '%'}, a:0 ? a:1 : {})
                                  if suffix =~# '\.js\>'
                                    let ph.S = s:gsub(ph.S, '::', '.')
                                  endif
                                  let mine += map(s:getlist(all[pattern], a:key), 's:expand_placeholders(v:val, ph)')
                                endif
  216              0.000175   endfor
   27              0.000076   return filter(mine, '!empty(v:val)')

FUNCTION  <SNR>71_sub()
Called 10 times
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
   10              0.000134   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  MyFugitive()
Called 378 times
Total time:   0.067247
 Self time:   0.004157

count  total (s)   self (s)
  378              0.001166   if exists("*fugitive#head")
  378   0.064529   0.001439     let _ = fugitive#head()
  378              0.001144     return strlen(_) ? ' '._ : ''
                              endif
                              return ''

FUNCTION  <SNR>71_buffer_project()
Called 4 times
Total time:   0.000348
 Self time:   0.000056

count  total (s)   self (s)
    4   0.000343   0.000051   return s:project(fnamemodify(self.getvar('bundler_lock'), ':h'))

FUNCTION  <SNR>90_define_commands()
Called 10 times
Total time:   0.003762
 Self time:   0.003762

count  total (s)   self (s)
  280              0.000331   for command in s:commands
  270              0.003118     exe 'command! -buffer '.command
  270              0.000224   endfor

FUNCTION  <SNR>125_buffer_getvar()
Called 732 times
Total time:   0.005219
 Self time:   0.003881

count  total (s)   self (s)
  732   0.004930   0.003592   return getbufvar(self.number(),a:varname)

FUNCTION  151()
Called 13 times
Total time:   0.059301
 Self time:   0.007685

count  total (s)   self (s)
                                "remove all the current child nodes
   13              0.000029     let self.children = []
                            
                                "get an array of all the files in the nodes dir
   13              0.000020     let dir = self.path
   13   0.001945   0.000089     let globDir = dir.str({'format': 'Glob'})
                            
   13              0.000017     if version >= 703
   13              0.003070         let filesStr = globpath(globDir, '*', !g:NERDTreeRespectWildIgnore) . "\n" . globpath(globDir, '.*', !g:NERDTreeRespectWildIgnore)
   13              0.000021     else
                                    let filesStr = globpath(globDir, '*') . "\n" . globpath(globDir, '.*')
                                endif
                            
   13              0.000117     let files = split(filesStr, "\n")
                            
   13              0.000049     if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                    call nerdtree#echo("Please wait, caching a large dir ...")
                                endif
                            
   13              0.000020     let invalidFilesFound = 0
  121              0.000146     for i in files
                            
                                    "filter out the .. and . directories
                                    "Note: we must match .. AND ../ cos sometimes the globpath returns
                                    "../ for path with strange chars (eg $)
                            "        if i !~# '\/\.\.\/\?$' && i !~# '\/\.\/\?$'
                            "
                                    " Regular expression is too expensive. Use simply string comparison
                                    " instead
  108              0.001159         if i[len(i)-3:2] != ".." && i[len(i)-2:2] != ".." &&  i[len(i)-2:1] != "." && i[len(i)-1] != "."
                                        "put the next file in a new node and attach it
   82              0.000073             try
   82   0.024391   0.000379                 let path = g:NERDTreePath.New(i)
   82   0.004763   0.000327                 call self.createChild(path, 0)
   82   0.003971   0.000476                 call g:NERDTreePathNotifier.NotifyListeners('init', path, {})
   82              0.000110             catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                            let invalidFilesFound += 1
                                        endtry
   82              0.000041         endif
  108              0.000079     endfor
                            
   13   0.017836   0.000053     call self.sortChildren()
                            
   13              0.000041     if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                    call nerdtree#echo("Please wait, caching a large dir ... DONE (". self.getChildCount() ." nodes cached).")
                                endif
                            
   13              0.000013     if invalidFilesFound
                                    call nerdtree#echoWarning(invalidFilesFound . " file(s) could not be loaded into the NERD tree")
                                endif
   13   0.000081   0.000047     return self.getChildCount()

FUNCTION  152()
Called 41 times
Total time:   0.001688
 Self time:   0.001688

count  total (s)   self (s)
   41              0.000057     if a:path.isDirectory != 1
                                    throw "NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object."
                                endif
                            
   41              0.001077     let newTreeNode = copy(self)
   41              0.000093     let newTreeNode.path = a:path
                            
   41              0.000069     let newTreeNode.isOpen = 0
   41              0.000070     let newTreeNode.children = []
                            
   41              0.000072     let newTreeNode.parent = {}
                            
   41              0.000047     return newTreeNode

FUNCTION  153()
Called 13 times
Total time:   0.059569
 Self time:   0.000268

count  total (s)   self (s)
   13              0.000027     let opts = a:0 ? a:1 : {}
                            
   13              0.000039     if has_key(opts, 'where') && !empty(opts['where'])
                                    let opener = g:NERDTreeOpener.New(self.path, opts)
                                    call opener.open(self)
                                else
   13              0.000017         let self.isOpen = 1
   13              0.000018         if self.children ==# []
   13   0.059394   0.000093             return self._initChildren(0)
                                    else
                                        return 0
                                    endif
                                endif

FUNCTION  154()
Called 13 times
Total time:   0.069166
 Self time:   0.000356

count  total (s)   self (s)
   13              0.000025     let opts = a:0 ? a:1 : {}
   13              0.000015     let level = 0
                            
   13              0.000013     let node = self
   15              0.000018     while node.path.isDirectory
   13   0.059635   0.000066         call node.open(opts)
   13              0.000022         let level += 1
   13   0.009018   0.000049         if node.getVisibleChildCount() == 1
    2   0.000285   0.000013             let node = node.getChildByIndex(0, 1)
    2              0.000001         else
   11              0.000006             break
                                    endif
    2              0.000001     endwhile
   13              0.000013     return level

FUNCTION  <SNR>125_pathjoin()
Called 10 times
Total time:   0.002367
 Self time:   0.002367

count  total (s)   self (s)
   10              0.000018   let i = 0
   10              0.000013   let path = ""
   20              0.000024   while i < a:0
   10              0.000036     if type(a:000[i]) == type([])
   10              0.002012       let path .= "," . escape(join(a:000[i], ','), ' ')
   10              0.000011     else
                                  let path .= "," . a:000[i]
                                endif
   10              0.000011     let i += 1
   10              0.000013   endwhile
   10              0.000101   return substitute(path,'^,','','')

FUNCTION  75()
Called 23 times
Total time:   0.000145
 Self time:   0.000145

count  total (s)   self (s)
   23              0.000059     if !exists("s:keyMaps")
                                    let s:keyMaps = []
                                endif
   23              0.000024     return s:keyMaps

FUNCTION  76()
Called 23 times
Total time:   0.001100
 Self time:   0.000955

count  total (s)   self (s)
  171   0.000358   0.000213     for i in s:KeyMap.All()
  171              0.000375          if i.key ==# a:key && i.scope ==# a:scope
   23              0.000020             return i
                                    endif
  148              0.000079     endfor
                                return {}

FUNCTION  165()
Called 13 times
Total time:   0.017783
 Self time:   0.000516

count  total (s)   self (s)
   13              0.000057     let CompareFunc = function("nerdtree#compareNodesBySortKey")
   13   0.017718   0.000451     call sort(self.children, CompareFunc)

FUNCTION  166()
Called 13 times
Total time:   0.069381
 Self time:   0.000215

count  total (s)   self (s)
   13              0.000024     let opts = a:0 ? a:1 : {}
   13              0.000016     if self.isOpen ==# 1
                                    call self.close()
                                else
   13              0.000026         if g:NERDTreeCascadeOpenSingleChildDir == 0
                                        call self.open(opts)
                                    else
   13   0.069224   0.000058             call self.openAlong(opts)
   13              0.000006         endif
   13              0.000006     endif

FUNCTION  <SNR>125_BufProjectionCommands()
Called 10 times
Total time:   0.155232
 Self time:   0.002122

count  total (s)   self (s)
   10   0.004567   0.000062   call s:addfilecmds("view")
   10   0.004538   0.000051   call s:addfilecmds("controller")
   10   0.004535   0.000048   call s:addfilecmds("migration")
   10   0.004531   0.000052   call s:addfilecmds("schema")
   10   0.004438   0.000053   call s:addfilecmds("layout")
   10   0.004548   0.000047   call s:addfilecmds("fixtures")
   10   0.004524   0.000049   call s:addfilecmds("locale")
   10   0.000647   0.000084   if rails#app().has('spec')
   10   0.004473   0.000048     call s:addfilecmds("spec")
   10              0.000009   endif
   10   0.004540   0.000054   call s:addfilecmds("stylesheet")
   10   0.004507   0.000050   call s:addfilecmds("javascript")
  120   0.034542   0.000623   for [name, command] in items(rails#app().commands())
  110   0.074623   0.000682     call s:define_navcommand(name, command)
  110              0.000103   endfor

FUNCTION  <SNR>125_app_engines()
Called 10 times
Total time:   0.003632
 Self time:   0.000304

count  total (s)   self (s)
   10   0.003387   0.000098   if self.cache.needs('engines') || self.cache.get('engines')[1] isnot# self.gems()
                                let gems = self.gems()
                                let gempath = escape(join(values(gems),','), ' ')
                                if empty(gempath)
                                  call self.cache.set('engines', [[], gems])
                                else
                                  call self.cache.set('engines', [sort(map(finddir('app', gempath, -1), 'fnamemodify(v:val, ":h")')), gems])
                                endif
                              endif
   10   0.000118   0.000079   return self.cache.get('engines')[0]

FUNCTION  80()
Called 23 times
Total time:  14.651886
 Self time:   0.000348

count  total (s)   self (s)
   23              0.000118     let Callback = function(self.callback)
   23              0.000023     if a:0
   23  14.651644   0.000106         call Callback(a:1)
   23              0.000015     else
                                    call Callback()
                                endif

FUNCTION  81()
Called 23 times
Total time:  14.806173
 Self time:   0.001444

count  total (s)   self (s)
                            
                                "required because clicking the command window below another window still
                                "invokes the <LeftRelease> mapping - but changes the window cursor
                                "is in first
                                "
                                "TODO: remove this check when the vim bug is fixed
   23   0.000337   0.000164     if !g:NERDTree.ExistsForBuf()
                                    return {}
                                endif
                            
   23   0.152146   0.000576     let node = g:NERDTreeFileNode.GetSelected()
   23              0.000042     if !empty(node)
                            
                                    "try file node
   23              0.000029         if !node.path.isDirectory
   10   0.000578   0.000062             let km = s:KeyMap.FindFor(a:key, "FileNode")
   10              0.000019             if !empty(km)
   10  14.314819   0.000064                 return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try dir node
   13              0.000013         if node.path.isDirectory
   13   0.000662   0.000078             let km = s:KeyMap.FindFor(a:key, "DirNode")
   13              0.000023             if !empty(km)
   13   0.337194   0.000063                 return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try generic node
                                    let km = s:KeyMap.FindFor(a:key, "Node")
                                    if !empty(km)
                                        return km.invoke(node)
                                    endif
                            
                                endif
                            
                                "try bookmark
                                let bm = g:NERDTreeBookmark.GetSelected()
                                if !empty(bm)
                                    let km = s:KeyMap.FindFor(a:key, "Bookmark")
                                    if !empty(km)
                                        return km.invoke(bm)
                                    endif
                                endif
                            
                                "try all
                                let km = s:KeyMap.FindFor(a:key, "all")
                                if !empty(km)
                                    return km.invoke()
                                endif

FUNCTION  86()
Called 81 times
Total time:   0.000508
 Self time:   0.000508

count  total (s)   self (s)
   81              0.000216     if !exists("g:NERDTreeBookmarks")
                                    let g:NERDTreeBookmarks = []
                                endif
   81              0.000089     return g:NERDTreeBookmarks

FUNCTION  <SNR>73_find_root()
Called 10 times
Total time:   0.002776
 Self time:   0.002496

count  total (s)   self (s)
   10   0.000308   0.000220   let root = s:shellslash(simplify(fnamemodify(a:path, ':p:s?[\/]$??')))
   40              0.000114   for p in [$GEM_HOME] + split($GEM_PATH,':')
   30   0.000434   0.000242     if p !=# '' && s:shellslash(p.'/gems/') ==# (root)[0 : strlen(p)+5]
                                  return simplify(s:shellslash(p.'/gems/')).matchstr(root[strlen(p)+6:-1],'[^\\/]*')
                                endif
   30              0.000018   endfor
   10              0.000016   let previous = ''
   40              0.000089   while root !=# previous && root !=# '/'
   40              0.000630     if filereadable(root.'/Rakefile') || (isdirectory(root.'/lib') && filereadable(root.'/Gemfile'))
   10              0.000116       if filereadable(root.'/config/environment.rb')
   10              0.000010         return ''
                                  else
                                    return root
                                  endif
                                elseif root =~# '[\/]gems[\/][0-9.]\+[\/]gems[\/][[:alnum:]._-]\+$'
                                  return root
                                endif
   30              0.000061     let previous = root
   30              0.000112     let root = fnamemodify(root, ':h')
   30              0.000029   endwhile
                              return ''

FUNCTION  171()
Called 10 times
Total time:   0.010074
 Self time:   0.000356

count  total (s)   self (s)
   10              0.000023     if b:NERDTreeType ==# "secondary"
                                    if self._where == 'v'
                                        vsplit
                                    elseif self._where == 'h'
                                        split
                                    elseif self._where == 't'
                                        tabnew
                                    endif
                                else
   10   0.000125   0.000038         call self._checkToCloseTree(1)
                            
   10              0.000016         if self._where == 'v'
                                        call self._newVSplit()
                                    elseif self._where == 'h'
                                        call self._newSplit()
                                    elseif self._where == 't'
                                        tabnew
                                    elseif self._where == 'p'
   10   0.009506   0.000038             call self._previousWindow()
   10              0.000006         endif
                            
   10   0.000216   0.000053         call self._checkToCloseTree(0)
   10              0.000003     endif

FUNCTION  172()
Called 20 times
Total time:   0.008446
 Self time:   0.000795

count  total (s)   self (s)
                                "gotta split if theres only one window (i.e. the NERD tree)
   20              0.000046     if winnr("$") ==# 1
                                    return 0
                                endif
                            
   20              0.000039     let oldwinnr = winnr()
   20   0.001492   0.000128     call nerdtree#exec(a:winnumber . "wincmd p")
   20              0.000163     let specialWindow = getbufvar("%", '&buftype') != '' || getwinvar('%', '&previewwindow')
   20              0.000040     let modified = &modified
   20   0.006456   0.000169     call nerdtree#exec(oldwinnr . "wincmd p")
                            
                                "if its a special window e.g. quickfix or another explorer plugin then we
                                "have to split
   20              0.000025     if specialWindow
                                    return 0
                                endif
                            
   20              0.000019     if &hidden
   20              0.000019         return 1
                                endif
                            
                                return !modified || self._bufInWindows(winbufnr(a:winnumber)) >= 2

FUNCTION  173()
Called 10 times
Total time:   0.000562
 Self time:   0.000425

count  total (s)   self (s)
   10              0.000097     let newObj = copy(self)
                            
   10              0.000017     let newObj._path = a:path
   10   0.000087   0.000046     let newObj._stay = nerdtree#has_opt(a:opts, 'stay')
                            
   10              0.000019     if has_key(a:opts, 'reuse')
   10              0.000023         let newObj._reuse = a:opts['reuse']
   10              0.000008     else
                                    let newObj._reuse = ''
                                endif
                            
   10   0.000076   0.000043     let newObj._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
   10              0.000036     let newObj._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
   10              0.000023     let newObj._treetype = b:NERDTreeType
   10   0.000100   0.000037     call newObj._saveCursorPos()
                            
   10              0.000012     return newObj

FUNCTION  176()
Called 10 times
Total time:  14.313675
 Self time:   0.000100

count  total (s)   self (s)
   10              0.000012     if self._path.isDirectory
                                    call self._openDirectory(a:target)
                                else
   10  14.313616   0.000041         call self._openFile()
   10              0.000006     endif

FUNCTION  177()
Called 10 times
Total time:  14.313575
 Self time:   0.000277

count  total (s)   self (s)
   10   0.005189   0.000037     if self._reuseWindow()
                                    return
                                endif
                            
   10   0.010114   0.000040     call self._gotoTargetWin()
                            
   10              0.000017     if self._treetype ==# "secondary"
                                    call self._path.edit()
                                else
   10  14.298127   0.000055         call self._path.edit()
                            
                            
   10              0.000026         if self._stay
                                        call self._restoreCursorPos()
                                    endif
   10              0.000005     endif

FUNCTION  179()
Called 10 times
Total time:   0.009468
 Self time:   0.000474

count  total (s)   self (s)
   10   0.004613   0.000071     if !self._isWindowUsable(winnr("#")) && self._firstUsableWindow() ==# -1
                                    call self._newSplit()
                                else
   10              0.000008         try
   10   0.004016   0.000112             if !self._isWindowUsable(winnr("#"))
                                            call nerdtree#exec(self._firstUsableWindow() . "wincmd w")
                                        else
   10   0.000654   0.000106                 call nerdtree#exec('wincmd p')
   10              0.000008             endif
   10              0.000012         catch /^Vim\%((\a\+)\)\=:E37/
                                        call g:NERDTree.CursorToTreeWin()
                                        throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
                                    catch /^Vim\%((\a\+)\)\=:/
                                        echo v:exception
                                    endtry
   10              0.000004     endif

FUNCTION  <SNR>125_buffer_setvar()
Called 72 times
Total time:   0.000655
 Self time:   0.000529

count  total (s)   self (s)
   72   0.000629   0.000503   return setbufvar(self.number(),a:varname,a:val)

FUNCTION  <SNR>31_chop()
Called 10 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
   10              0.000068 	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
   10              0.000012 	retu a:mrufs

FUNCTION  <SNR>188_PreviewCSSColorInLine()
Called 5 times
Total time:   0.000381
 Self time:   0.000381

count  total (s)   self (s)
                              " TODO use cssColor matchdata
    5              0.000009   let n = 1
    5              0.000042   let foundcolor = matchstr( getline(a:where), '#[0-9A-Fa-f]\{3,6\}\>' )
    5              0.000010   while foundcolor != ''
                                if foundcolor =~ '#\x\{6}$'
                                  let color = foundcolor
                                elseif foundcolor =~ '#\x\{3}$'
                                  let color = substitute(foundcolor, '\(\x\)\(\x\)\(\x\)', '\1\1\2\2\3\3', '')
                                else
                                  let color = ''
                                endif
                            
                                if color != ''
                                  call s:SetMatcher(color,foundcolor)
                                endif
                            
                                let n+=1
                                let foundcolor = matchstr( getline(a:where), '#[0-9A-Fa-f]\{3,6}', 0, n )
                              endwhile
                            
                            
    5              0.000005   let n = 1
    5              0.000063   let foundcolorlist = matchlist( getline(a:where), 'rgb[a]\=(\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\).\{-})', 0, n )
    5              0.000013   while len(foundcolorlist) != 0
                                  let foundcolorlist[1] = s:RGBRelativeToAbsolute( foundcolorlist[1] )
                                  let foundcolorlist[2] = s:RGBRelativeToAbsolute( foundcolorlist[2] )
                                  let foundcolorlist[3] = s:RGBRelativeToAbsolute( foundcolorlist[3] )
                            
                                  let color = "#".join( foundcolorlist[1:3], "" )
                            
                                  call s:SetMatcher( color, foundcolorlist[0] )
                            
                                  let n+=1
                                  let foundcolorlist = matchlist( getline(a:where), 'rgb[a]\=(\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\).\{-})', 0, n )
                              endw
    5              0.000006   return 0

FUNCTION  181()
Called 10 times
Total time:   0.005152
 Self time:   0.002407

count  total (s)   self (s)
   10              0.000021     if empty(self._reuse)
                                    return 0
                                endif
                            
                                "check the current tab for the window
   10   0.002978   0.002006     let winnr = bufwinnr('^' . self._path.str() . '$')
   10              0.000024     if winnr != -1
                                    call nerdtree#exec(winnr . "wincmd w")
                                    call self._checkToCloseTree(0)
                                    return 1
                                endif
                            
   10              0.000020     if self._reuse == 'currenttab'
                                    return 0
                                endif
                            
                                "check other tabs
   10   0.001876   0.000103     let tabnr = self._path.tabnr()
   10              0.000009     if tabnr
                                    call self._checkToCloseTree(1)
                                    call nerdtree#exec('normal! ' . tabnr . 'gt')
                                    let winnr = bufwinnr('^' . self._path.str() . '$')
                                    call nerdtree#exec(winnr . "wincmd w")
                                    return 1
                                endif
                            
   10              0.000009     return 0

FUNCTION  182()
Called 10 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
   10              0.000031     let self._bufnr = bufnr("")
   10              0.000025     let self._tabnr = tabpagenr()

FUNCTION  <SNR>28_SetupAutoCommands()
Called 40 times
Total time:   0.007639
 Self time:   0.007639

count  total (s)   self (s)
                                " Auto commands group
   40              0.000067     augroup better_whitespace
   40              0.004194         autocmd!
                            
   40              0.000308         if index(g:better_whitespace_filetypes_blacklist, &ft) >= 0
                                        match ExtraWhitespace ''
                                        return
                                    endif
                            
   40              0.000059         if g:better_whitespace_enabled == 1
   40              0.000064             if s:better_whitespace_initialized == 0
                                            call <SID>WhitespaceInit()
                                        endif
                            
                                        " Check if current line is disabled softly
   40              0.000055             if g:current_line_whitespace_disabled_soft == 0
                                            " Highlight all whitespace upon entering buffer
   40              0.000245                 autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
                                            " Check if current line highglighting is disabled
   40              0.000071                 if g:current_line_whitespace_disabled_hard == 1
                                                " Never highlight whitespace on current line
                                                autocmd InsertEnter,CursorMoved,CursorMovedI * exe 'match ExtraWhitespace ' . '/\%<' . line(".") .  'l\s\+$\|\%>' . line(".") .  'l\s\+$/'
                                            else
                                                " When in insert mode, do not highlight whitespace on the current line
   40              0.000302                     autocmd InsertEnter,CursorMovedI * exe 'match ExtraWhitespace ' . '/\%<' . line(".") .  'l\s\+$\|\%>' . line(".") .  'l\s\+$/'
   40              0.000026                 endif
                                            " Highlight all whitespace when exiting insert mode
   40              0.000900                 autocmd InsertLeave,BufReadPost * match ExtraWhitespace /\s\+$/
                                            " Clear whitespace highlighting when leaving buffer
   40              0.000153                 autocmd BufWinLeave * match ExtraWhitespace ''
   40              0.000027             else
                                            " Highlight extraneous whitespace at the end of lines, but not the
                                            " current line.
                                            call s:InAllWindows('syn clear ExtraWhitespace | syn match ExtraWhitespace excludenl /\s\+$/')
                                            autocmd InsertEnter * syn clear ExtraWhitespace | syn match ExtraWhitespace excludenl /\s\+\%#\@!$/ containedin=ALL
                                            autocmd InsertLeave,BufReadPost * syn clear ExtraWhitespace | syn match ExtraWhitespace excludenl /\s\+$/ containedin=ALL
                                        endif
   40              0.000026         endif
                            
                                    " Strip whitespace on save if enabled
   40              0.000053         if g:strip_whitespace_on_save == 1
                                        autocmd BufWritePre * call <SID>StripWhitespace( 0, line("$") )
                                    endif
                            
   40              0.000035     augroup END

FUNCTION  <SNR>130_nerd_tree_just_opened()
Called 10 times
Total time:   0.000967
 Self time:   0.000967

count  total (s)   self (s)
   10              0.000923   if exists("t:NERDTreeBufName") && bufwinnr(t:NERDTreeBufName) == -1
                                return 1
                              endif
                            
   10              0.000006   return

FUNCTION  <SNR>78_setup()
Called 20 times
Total time:   0.077789
 Self time:   0.001103

count  total (s)   self (s)
   20              0.000049   let swap = a:0 && a:1 == 2
   20              0.000029   let enable = a:0 && a:1
   20              0.000027   let disable = a:0 && !a:1
                              " First, remove all magic, if needed:
   20              0.000052   if get(b:, 'delimitMate_enabled', 0)
   10   0.008351   0.000111     call s:Unmap()
                                " Switch
   10              0.000015     if swap
                                  echo "delimitMate is disabled."
                                  return
                                endif
   10              0.000009   endif
   20              0.000014   if disable
                                " Just disable the mappings.
                                return
                              endif
   20              0.000019   if !a:0
                                " Check if this file type is excluded:
   20              0.000089     if exists("g:delimitMate_excluded_ft") && index(split(g:delimitMate_excluded_ft, ','), &filetype, 0, 1) >= 0
                                  " Finish here:
                                  return 1
                                endif
                                " Check if user tried to disable using b:loaded_delimitMate
   20              0.000046     if exists("b:loaded_delimitMate")
                                  return 1
                                endif
   20              0.000011   endif
                              " Initialize settings:
   20   0.036836   0.000094   if ! s:init()
                                " Something went wrong.
                                return
                              endif
   20              0.000065   if enable || swap || !get(g:, 'delimitMate_offByDefault', 0)
                                " Now, add magic:
   20   0.031793   0.000089     call s:Map()
   20              0.000020     if a:0
                                  echo "delimitMate is enabled."
                                endif
   20              0.000010   endif

FUNCTION  <SNR>13_DetectCoffee()
Called 10 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
   10              0.000058     if getline(1) =~ '^#!.*\<coffee\>'
                                    set filetype=coffee
                                endif

FUNCTION  rails#buffer_setup()
Called 10 times
Total time:   0.394783
 Self time:   0.057712

count  total (s)   self (s)
   10              0.000026   if !exists('b:rails_root')
                                return ''
                              endif
   10   0.000243   0.000038   let self = rails#buffer()
   10   0.005587   0.000068   let b:rails_cached_file_type = self.calculate_file_type()
   10   0.002750   0.000098   call s:BufMappings()
   10   0.013116   0.000058   call s:BufCommands()
   10              0.043836   if !empty(findfile('macros/rails.vim', escape(&runtimepath, ' ')))
                                runtime! macros/rails.vim
                              endif
   10   0.000342   0.000226   silent doautocmd User Rails
   10   0.155324   0.000092   call s:BufProjectionCommands()
   10   0.047937   0.000121   call s:BufAbbreviations()
   10   0.090127   0.000316   call s:SetBasePath()
   10   0.000666   0.000100   let rp = s:gsub(self.app().path(),'[ ,]','\\&')
   10              0.000140   if stridx(&tags,rp.'/tags') == -1
   10              0.000062     let &l:tags = rp . '/tags,' . rp . '/tmp/tags,' . &tags
   10              0.000008   endif
   10   0.000142   0.000051   call self.setvar('&includeexpr','RailsIncludeexpr()')
   10   0.000330   0.000093   call self.setvar('&suffixesadd', s:sub(self.getvar('&suffixesadd'),'^$','.rb'))
   10   0.000111   0.000041   let ft = self.getvar('&filetype')
   10              0.000043   if ft =~# '^ruby\>'
    4   0.002398   0.000034     call self.setvar('&define',self.define_pattern())
                                " This really belongs in after/ftplugin/ruby.vim but we'll be nice
    4   0.000062   0.000030     if exists('g:loaded_surround') && self.getvar('surround_101') == ''
    4   0.000049   0.000017       call self.setvar('surround_5',   "\r\nend")
    4   0.000049   0.000016       call self.setvar('surround_69',  "\1expr: \1\rend")
    4   0.000051   0.000016       call self.setvar('surround_101', "\r\nend")
    4              0.000003     endif
    4              0.000034     if exists(':UltiSnipsAddFiletypes') == 2
                                  UltiSnipsAddFiletypes rails
                                elseif exists(':SnipMateLoadScope') == 2
                                  SnipMateLoadScope rails
                                endif
    4              0.000009   elseif ft =~# 'yaml\>' || fnamemodify(self.name(),':e') ==# 'yml'
    1   0.000204   0.000009     call self.setvar('&define',self.define_pattern())
    1              0.000001   elseif ft =~# '^eruby\>'
                                if exists("g:loaded_ragtag")
                                  call self.setvar('ragtag_stylesheet_link_tag', "<%= stylesheet_link_tag '\r' %>")
                                  call self.setvar('ragtag_javascript_include_tag', "<%= javascript_include_tag '\r' %>")
                                  call self.setvar('ragtag_doctype_index', 10)
                                endif
                              elseif ft =~# '^haml\>'
                                if exists("g:loaded_ragtag")
                                  call self.setvar('ragtag_stylesheet_link_tag', "= stylesheet_link_tag '\r'")
                                  call self.setvar('ragtag_javascript_include_tag', "= javascript_include_tag '\r'")
                                  call self.setvar('ragtag_doctype_index', 10)
                                endif
                              endif
   10              0.000056   if ft =~# '^eruby\>' || ft =~# '^yaml\>'
    1              0.000003     if exists("g:loaded_surround")
    1   0.000013   0.000006       if self.getvar('surround_45') == '' || self.getvar('surround_45') == "<% \r %>" " -
    1   0.000015   0.000007         call self.setvar('surround_45', "<% \r %>")
    1              0.000001       endif
    1   0.000011   0.000005       if self.getvar('surround_61') == '' " =
    1   0.000011   0.000004         call self.setvar('surround_61', "<%= \r %>")
    1              0.000001       endif
    1   0.000010   0.000003       if self.getvar("surround_35") == '' " #
    1   0.000012   0.000004         call self.setvar('surround_35', "<%# \r %>")
    1              0.000000       endif
    1   0.000010   0.000004       if self.getvar('surround_101') == '' || self.getvar('surround_101')== "<% \r %>\n<% end %>" "e
    1   0.000017   0.000004         call self.setvar('surround_5',   "<% \r %>\n<% end %>")
    1   0.000012   0.000005         call self.setvar('surround_69',  "<% \1expr: \1 %>\r<% end %>")
    1   0.000012   0.000004         call self.setvar('surround_101', "<% \r %>\n<% end %>")
    1              0.000000       endif
    1              0.000000     endif
    1              0.000001   endif
                            
   10   0.023724   0.010424   compiler rails
   10              0.000030   let b:current_compiler = 'rake'
   10   0.001003   0.000108   let &l:makeprg = self.app().rake_command('static')
   10   0.000548   0.000106   let &l:errorformat .= ',chdir '.escape(self.app().path(), ',')
                            
   10              0.000068   if exists(':Dispatch') == 2 && !exists('g:autoloaded_dispatch')
                                runtime! autoload/dispatch.vim
                              endif
   10              0.000025   if exists('*dispatch#dir_opt')
                                let dir = dispatch#dir_opt(self.app().path())
                              endif
                            
   10   0.001776   0.000067   if self.name() =~# '^public'
    2   0.000026   0.000010     call self.setvar('dispatch', ':Preview')
    2              0.000004   elseif self.type_name('test', 'spec', 'cucumber')
    1   0.000013   0.000005     call self.setvar('dispatch', ':Runner')
    1              0.000002   elseif self.name() =~# '^\%(app\|config\|db\|lib\|log\|README\|Rakefile\)'
    6              0.000014     if exists('dir')
                                  call self.setvar('dispatch', dir . '-compiler=rails ' . self.app().rake_command('static') . ' `=rails#buffer(' . self['#'] . ').default_rake_task(v:lnum)`')
                                else
    6   0.000097   0.000037       call self.setvar('dispatch', ':Rake')
    6              0.000006     endif
    6              0.000002   endif
                            
   10   0.000107   0.000038   if empty(self.getvar('start'))
   10   0.000111   0.000038     call self.setvar('start', ':Server')
   10              0.000007   endif

FUNCTION  <SNR>180_AddBlockTag()
Called 4 times
Total time:   0.000108
 Self time:   0.000108

count  total (s)   self (s)
    4              0.000013     if !(a:id >= 2 && a:id < 2+len(s:endtags))
                            	return
                                endif
    4              0.000026     let s:indent_tags[a:tag] = a:id
    4              0.000004     if a:0 == 0
    3              0.000020 	let s:indent_tags['/'.a:tag] = -a:id
    3              0.000011 	let s:endtags[a:id-2] = "</".a:tag.">"
    3              0.000002     else
    1              0.000006 	let s:indent_tags[a:1] = -a:id
    1              0.000002 	let s:endtags[a:id-2] = a:1
    1              0.000001     endif

FUNCTION  <SNR>125_AddColonExpand()
Called 80 times
Total time:   0.005887
 Self time:   0.000471

count  total (s)   self (s)
   80   0.005855   0.000439   call s:AddSelectiveExpand(a:abbr,'[:.]',a:expn)

FUNCTION  fugitive#extract_git_dir()
Called 10 times
Total time:   0.006030
 Self time:   0.003414

count  total (s)   self (s)
   10   0.000246   0.000084   if s:shellslash(a:path) =~# '^fugitive://.*//'
                                return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
                              endif
   10   0.000382   0.000230   let root = s:shellslash(simplify(fnamemodify(a:path, ':p:s?[\/]$??')))
   10              0.000017   let previous = ""
   40              0.000071   while root !=# previous
   40              0.000239     if root =~# '\v^//%([^/]+/?)?$'
                                  " This is for accessing network shares from Cygwin Vim. There won't be
                                  " any git directory called //.git or //serverName/.git so let's avoid
                                  " checking for them since such checks are extremely slow.
                                  break
                                endif
   40              0.000253     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
                                  break
                                endif
   40              0.000128     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
                                  return $GIT_DIR
                                endif
   40   0.001026   0.000202     if fugitive#is_git_dir($GIT_DIR)
                                  " Ensure that we've cached the worktree
                                  call s:configured_tree($GIT_DIR)
                                  if has_key(s:dir_for_worktree, root)
                                    return s:dir_for_worktree[root]
                                  endif
                                endif
   40   0.000622   0.000234     let dir = s:sub(root, '[\/]$', '') . '/.git'
   40              0.000290     let type = getftype(dir)
   40   0.000453   0.000139     if type ==# 'dir' && fugitive#is_git_dir(dir)
   10              0.000017       return dir
                                elseif type ==# 'link' && fugitive#is_git_dir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
                                    return simplify(root.'/'.line[8:-1])
                                  elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
                                    return line[8:-1]
                                  endif
                                elseif fugitive#is_git_dir(root)
                                  return root
                                endif
   30              0.000047     let previous = root
   30              0.000110     let root = fnamemodify(root, ':h')
   30              0.000033   endwhile
                              return ''

FUNCTION  <SNR>125_Abbrev()
Called 152 times
Total time:   0.024842
 Self time:   0.011806

count  total (s)   self (s)
  152              0.000448   if !exists("b:rails_abbreviations")
   10              0.000024     let b:rails_abbreviations = {}
   10              0.000007   endif
  152              0.000277   if a:0 > 3 || (a:bang && (a:0 != 1))
                                return s:error("Rabbrev: invalid arguments")
                              endif
  152              0.000135   if a:0 == 0
                                for key in sort(keys(b:rails_abbreviations))
                                  echo key . join(b:rails_abbreviations[key],"\t")
                                endfor
                                return
                              endif
  152              0.000218   let lhs = a:1
  152   0.002181   0.000764   let root = s:sub(lhs,'%(::|\(|\[)$','')
  152              0.000182   if a:bang
                                if has_key(b:rails_abbreviations,root)
                                  call remove(b:rails_abbreviations,root)
                                endif
                                exe "iunabbrev <buffer> ".root
                                return
                              endif
  152              0.000200   if a:0 > 3 || a:0 < 2
                                return s:error("Rabbrev: invalid arguments")
                              endif
  152              0.000217   let rhs = a:2
  152              0.000378   if has_key(b:rails_abbreviations,root)
                                call remove(b:rails_abbreviations,root)
                              endif
  152              0.000483   if lhs =~ '($'
   63              0.000300     let b:rails_abbreviations[root] = ["(", rhs . (a:0 > 2 ? "\t".a:3 : "")]
   63              0.000061     if a:0 > 2
    5   0.000427   0.000025       call s:AddParenExpand(root,rhs,a:3)
    5              0.000003     else
   58   0.004997   0.000307       call s:AddParenExpand(root,rhs)
   58              0.000025     endif
   63              0.000041     return
                              endif
   89              0.000085   if a:0 > 2
                                return s:error("Rabbrev: invalid arguments")
                              endif
   89              0.000292   if lhs =~ ':$'
   80   0.006298   0.000411     call s:AddColonExpand(root,rhs)
   80              0.000085   elseif lhs =~ '\[$'
    7   0.000523   0.000035     call s:AddBracketExpand(root,rhs)
    7              0.000007   elseif lhs =~ '\w$'
    2   0.000163   0.000011     call s:AddTabExpand(lhs,rhs)
    2              0.000001   else
                                return s:error("Rabbrev: unimplemented")
                              endif
   89              0.000745   let b:rails_abbreviations[root] = [matchstr(lhs,'\W*$'),rhs]

FUNCTION  <SNR>6_FThtml()
Called 2 times
Total time:   7.014118
 Self time:   0.000411

count  total (s)   self (s)
    2              0.000008   let n = 1
   20              0.000043   while n < 10 && n < line("$")
   18              0.000102     if getline(n) =~ '\<DTD\s\+XHTML\s'
                                  setf xhtml
                                  return
                                endif
   18              0.000094     if getline(n) =~ '{%\s*\(extends\|block\)\>'
                                  setf htmldjango
                                  return
                                endif
   18              0.000032     let n = n + 1
   18              0.000025   endwhile
    2   7.013717   0.000010   setf html

FUNCTION  <SNR>180_AddITags()
Called 2 times
Total time:   0.000638
 Self time:   0.000638

count  total (s)   self (s)
   95              0.000080     for itag in a:taglist
   93              0.000209 	let s:indent_tags[itag] = 1
   93              0.000251 	let s:indent_tags['/'.itag] = -1
   93              0.000065     endfor

FUNCTION  syntastic#util#compareLexi()
Called 10 times
Total time:   0.000163
 Self time:   0.000163

count  total (s)   self (s)
   10              0.000056     for idx in range(max([len(a:a), len(a:b)]))
                                    let a_element = str2nr(get(a:a, idx, 0))
                                    let b_element = str2nr(get(a:b, idx, 0))
                                    if a_element != b_element
                                        return a_element > b_element ? 1 : -1
                                    endif
                                endfor
                                " still here, thus everything matched
   10              0.000006     return 0

FUNCTION  <SNR>125_readable_controller_name()
Called 14 times
Total time:   0.024774
 Self time:   0.002002

count  total (s)   self (s)
   14   0.002468   0.000060   let f = self.name()
   14   0.000178   0.000078   if has_key(self,'getvar') && self.getvar('rails_controller') != ''
                                return self.getvar('rails_controller')
                              endif
   14   0.020286   0.000213   let [affinity, root] = self.find_affinity()
   14              0.000024   if affinity ==# 'controller'
                                return root
                              elseif affinity ==# 'resource'
                                return rails#pluralize(root)
                              endif
   14              0.000084   if f =~ '\<app/views/layouts/'
                                return s:sub(f,'.*<app/views/layouts/(.{-})\..*','\1')
                              elseif f =~ '\<app/views/'
    2   0.000060   0.000016     return s:sub(f,'.*<app/views/(.{-})/\w+%(\.[[:alnum:]_+]+)=\.\w+$','\1')
                              elseif f =~ '\<app/helpers/.*_helper\.rb$'
                                return s:sub(f,'.*<app/helpers/(.{-})_helper\.rb$','\1')
                              elseif f =~ '\<app/controllers/.*\.rb$'
                                return s:sub(f,'.*<app/controllers/(.{-})%(_controller)=\.rb$','\1')
                              elseif f =~ '\<app/mailers/.*\.rb$'
                                return s:sub(f,'.*<app/mailers/(.{-})\.rb$','\1')
                              elseif f =~ '\<app/apis/.*_api\.rb$'
                                return s:sub(f,'.*<app/apis/(.{-})_api\.rb$','\1')
                              elseif f =~ '\<test/\%(functional\|controllers\)/.*_test\.rb$'
                                return s:sub(f,'.*<test/%(functional|controllers)/(.{-})%(_controller)=_test\.rb$','\1')
                              elseif f =~ '\<test/\%(unit/\)\?helpers/.*_helper_test\.rb$'
                                return s:sub(f,'.*<test/%(unit/)?helpers/(.{-})_helper_test\.rb$','\1')
                              elseif f =~ '\<spec/controllers/.*_spec\.rb$'
    2   0.000069   0.000016     return s:sub(f,'.*<spec/controllers/(.{-})%(_controller)=_spec\.rb$','\1')
                              elseif f =~ '\<spec/helpers/.*_helper_spec\.rb$'
                                return s:sub(f,'.*<spec/helpers/(.{-})_helper_spec\.rb$','\1')
                              elseif f =~ '\<spec/views/.*/\w\+_view_spec\.rb$'
                                return s:sub(f,'.*<spec/views/(.{-})/\w+_view_spec\.rb$','\1')
                              elseif f =~ '\<app/models/.*\.rb$' && self.type_name('mailer')
                                return s:sub(f,'.*<app/models/(.{-})\.rb$','\1')
                              elseif f =~ '\<\%(public\|app/assets\)/stylesheets/.*\.css\%(\.\w\+\)\=$'
                                return s:sub(f,'.*<%(public|app/assets)/stylesheets/(.{-})\.css%(\.\w+)=$','\1')
                              elseif f =~ '\<\%(public\|app/assets\)/javascripts/.*\.js\%(\.\w\+\)\=$'
    4   0.000135   0.000041     return s:sub(f,'.*<%(public|app/assets)/javascripts/(.{-})\.js%(\.\w+)=$','\1')
                              elseif a:0 && a:1
                                return rails#pluralize(self.model_name())
                              endif
    6              0.000005   return ""

FUNCTION  ctrlp#utils#mkdir()
Called 10 times
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
   10              0.000092 	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
   10              0.000010 	retu a:dir

FUNCTION  <SNR>125_combine_projections()
Called 183 times
Total time:   0.003678
 Self time:   0.003678

count  total (s)   self (s)
  183              0.000405   let extra = a:0 ? a:1 : {}
  183              0.000491   if type(a:src) == type({})
  122              0.000306     for [pattern, original] in items(a:src)
                                  let projection = extend(copy(original), extra)
                                  if !has_key(projection, 'prefix') && !has_key(projection, 'format')
                                    let a:dest[pattern] = s:extend_projection(get(a:dest, pattern, {}), projection)
                                  endif
                                endfor
  122              0.000065   endif
  183              0.000180   return a:dest

FUNCTION  <SNR>125_BufDatabase()
Called 20 times
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
   20              0.000085   if exists("s:lock_database") || !exists('g:loaded_dbext') || !exists('b:rails_root')
   20              0.000019     return
                              endif
                              let self = rails#app()
                              if a:level > 1
                                call self.cache.clear('db_config')
                              elseif exists('g:rails_no_dbext')
                                return
                              endif
                              if (a:0 && !empty(a:1))
                                let env = a:1
                              else
                                let env = s:environment()
                              endif
                              if !self.cache.has('db_config') && a:level <= 0
                                return
                              endif
                              let dict = self.dbext_settings(env)
                              if empty(dict)
                                return
                              endif
                              for key in ['type', 'profile', 'bin', 'user', 'passwd', 'dbname', 'srvname', 'host', 'port', 'dsnname', 'extra', 'integratedlogin']
                                let b:dbext_{key} = get(dict,key,'')
                              endfor
                              if b:dbext_type == 'SQLITE'
                                " dbext seems to have overlooked the release of sqlite3 a decade ago
                                let g:dbext_default_SQLITE_bin = "sqlite3"
                              endif
                              if b:dbext_type == 'PGSQL'
                                let $PGPASSWORD = b:dbext_passwd
                              elseif exists('$PGPASSWORD')
                                let $PGPASSWORD = ''
                              endif

FUNCTION  nerdtree#runningWindows()
Called 3984 times
Total time:   0.030815
 Self time:   0.030815

count  total (s)   self (s)
 3984              0.029157     return has("win16") || has("win32") || has("win64")

FUNCTION  lightline#statusline()
Called 60 times
Total time:   0.066992
 Self time:   0.001101

count  total (s)   self (s)
   60              0.000293   if a:inactive && !has_key(s:highlight, 'inactive') | call lightline#highlight('inactive') | endif
   60   0.066655   0.000764   return s:line(0, a:inactive)

FUNCTION  280()
Called 20 times
Total time:   0.000277
 Self time:   0.000101

count  total (s)   self (s)
   20   0.000269   0.000093     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  <SNR>32_InTmuxSession()
Called 10 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
   10              0.000067   return $TMUX != ''

FUNCTION  <SNR>32_VimNavigate()
Called 10 times
Total time:   0.041761
 Self time:   0.004779

count  total (s)   self (s)
   10              0.000021   try
   10   0.041665   0.004683     execute 'wincmd ' . a:direction
   10              0.000021   catch
                                echohl ErrorMsg | echo 'E11: Invalid in command-line window; <CR> executes, CTRL-C quits: wincmd k' | echohl None
                              endtry

FUNCTION  285()
Called 10 times
Total time:   0.000399
 Self time:   0.000399

count  total (s)   self (s)
   10              0.000140     let newObj = copy(self)
                            
   10              0.000040     let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
                            
   10              0.000016     for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
   10              0.000021     let newObj._rawLoclist = llist
   10              0.000018     let newObj._name = ''
   10              0.000021     let newObj._owner = bufnr('')
   10              0.000017     let newObj._sorted = 0
   10              0.000020     let newObj._columns = g:syntastic_cursor_columns
                            
   10              0.000011     return newObj

FUNCTION  rails#lencmp()
Called 1047 times
Total time:   0.003503
 Self time:   0.003503

count  total (s)   self (s)
 1047              0.003144   return len(a:i1) - len(a:i2)

FUNCTION  <SNR>31_addtomrufs()
Called 50 times
Total time:   0.025977
 Self time:   0.008386

count  total (s)   self (s)
   50              0.001407 	let fn = fnamemodify(a:fname, ':p')
   50              0.000343 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
   50              0.004729 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
                            	en
   40              0.000258 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
   40              0.000036 	if idx
   30              0.000379 		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
   30              0.000078 		cal insert(s:mrufs, fn)
   30              0.000093 		if {s:soup} && idx < 0
   10   0.018285   0.000694 			cal s:savetofile(s:mergelists())
   10              0.000008 		en
   30              0.000014 	en

FUNCTION  <SNR>90_repo_head_ref()
Called 378 times
Total time:   0.023594
 Self time:   0.018839

count  total (s)   self (s)
  378   0.010472   0.007921   if !filereadable(self.dir('HEAD'))
                                return ''
                              endif
  378   0.011847   0.009643   return readfile(self.dir('HEAD'))[0]

FUNCTION  115()
Called 842 times
Total time:   0.047257
 Self time:   0.003142

count  total (s)   self (s)
  842   0.046941   0.002826     return self.path.displayString()

FUNCTION  116()
Called 13 times
Total time:   0.002591
 Self time:   0.000102

count  total (s)   self (s)
   13   0.002586   0.000097     return self.path.str() ==# a:treenode.path.str()

FUNCTION  <SNR>125_AddParenExpand()
Called 63 times
Total time:   0.005092
 Self time:   0.000737

count  total (s)   self (s)
   63              0.000063   if a:0
    5   0.000374   0.000034     call s:AddSelectiveExpand(a:abbr,'(',a:expn,a:1)
    5              0.000004   else
   58   0.004367   0.000352     call s:AddSelectiveExpand(a:abbr,'(',a:expn,'')
   58              0.000037   endif

FUNCTION  coffee#CoffeeSetUpVariables()
Called 2 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
                              " Path to coffee executable
    2              0.000009   if !exists('g:coffee_compiler')
    1              0.000002     let g:coffee_compiler = 'coffee'
    1              0.000000   endif
                            
                              " Options passed to coffee with make
    2              0.000005   if !exists('g:coffee_make_options')
    1              0.000002     let g:coffee_make_options = ''
    1              0.000000   endif
                            
                              " Path to cake executable
    2              0.000005   if !exists('g:coffee_cake')
    1              0.000002     let g:coffee_cake = 'cake'
    1              0.000000   endif
                            
                              " Extra options passed to cake
    2              0.000004   if !exists('g:coffee_cake_options')
    1              0.000002     let g:coffee_cake_options = ''
    1              0.000001   endif
                            
                              " Path to coffeelint executable
    2              0.000005   if !exists('g:coffee_linter')
    1              0.000001     let g:coffee_linter = 'coffeelint'
    1              0.000000   endif
                            
                              " Options passed to CoffeeLint
    2              0.000004   if !exists('g:coffee_lint_options')
    1              0.000002     let g:coffee_lint_options = ''
    1              0.000000   endif
                            
                              " Pass the litcoffee flag to tools in this buffer if a litcoffee file is open.
                              " Let the variable be overwritten so it can be updated if a different filetype
                              " is set.
    2              0.000004   if &filetype == 'litcoffee'
                                let b:coffee_litcoffee = '--literate'
                              else
    2              0.000004     let b:coffee_litcoffee = ''
    2              0.000001   endif

FUNCTION  lightline#mode()
Called 189 times
Total time:   0.001068
 Self time:   0.001068

count  total (s)   self (s)
  189              0.000921   return get(s:lightline.mode_map, mode(), s:lightline.mode_map['?'])

FUNCTION  <SNR>90_buffer_spec()
Called 40 times
Total time:   0.001922
 Self time:   0.001251

count  total (s)   self (s)
   40              0.000130     let bufname = bufname(self['#'])
   40   0.001768   0.001097     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))

FUNCTION  <SNR>125_cache_get()
Called 503 times
Total time:   0.001762
 Self time:   0.001762

count  total (s)   self (s)
  503              0.000632   if a:0 == 1
  503              0.000841     return self.dict[a:1]
                              else
                                return self.dict
                              endif

FUNCTION  nerdtree#compareNodesBySortKey()
Called 176 times
Total time:   0.017267
 Self time:   0.001756

count  total (s)   self (s)
  176   0.014636   0.001087     if a:n1.path.getSortKey() < a:n2.path.getSortKey()
  112              0.000093         return -1
                                elseif a:n1.path.getSortKey() > a:n2.path.getSortKey()
   64              0.000052         return 1
                                else
                                    return 0
                                endif

FUNCTION  <SNR>78_set()
Called 460 times
Total time:   0.016610
 Self time:   0.002336

count  total (s)   self (s)
  460   0.016430   0.002156   return call('delimitMate#Set', a:000)

FUNCTION  <SNR>125_split()
Called 130 times
Total time:   0.001003
 Self time:   0.001003

count  total (s)   self (s)
  130              0.000929   return type(a:arg) == type([]) ? copy(a:arg) : split(a:arg, a:0 ? a:1 : "\n")

FUNCTION  <SNR>71_define_commands()
Called 10 times
Total time:   0.000961
 Self time:   0.000961

count  total (s)   self (s)
   80              0.000101   for command in s:commands
   70              0.000759     exe 'command! -buffer '.command
   70              0.000053   endfor

FUNCTION  <SNR>71_project()
Called 4 times
Total time:   0.000277
 Self time:   0.000065

count  total (s)   self (s)
    4   0.000242   0.000030   let project = a:0 ? bundler#project(a:1) : bundler#project()
    4              0.000007   if empty(project)
                                call s:throw('not a Bundler project: '.(a:0 ? a:1 : expand('%')))
                              else
    4              0.000005     return project
                              endif

FUNCTION  nerdtree#has_opt()
Called 1303 times
Total time:   0.004732
 Self time:   0.004732

count  total (s)   self (s)
 1303              0.004155     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  <SNR>49_activateDirNode()
Called 13 times
Total time:   0.336944
 Self time:   0.000059

count  total (s)   self (s)
   13   0.336939   0.000054     call a:node.activate()

FUNCTION  bundler#project()
Called 75 times
Total time:   0.003974
 Self time:   0.003974

count  total (s)   self (s)
   75              0.000089   if !a:0
                                let lock = !empty(get(b:, 'bundler_lock', '')) ? b:bundler_lock : s:FindBundlerLock(expand('%:p'))
                              elseif filereadable(a:1)
                                let lock = a:1
                              elseif filereadable(a:1 . '/Gemfile')
   75              0.000236     let lock = a:1 . '/Gemfile.lock'
   75              0.000120   elseif filereadable(a:1 . '/gems.locked')
                                let lock = a:1 . '/gems.locked'
                              else
                                let lock = ''
                              endif
   75              0.000133   if !empty(lock)
   75              0.000190     if has_key(s:projects, lock)
   75              0.000200       let project = get(s:projects, lock)
   75              0.000045     else
                                  let project = {'root': fnamemodify(lock, ':h'), '_lock': lock}
                                  let s:projects[lock] = project
                                endif
   75              0.000385     return extend(extend(project,s:project_prototype,'keep'),s:abstract_prototype,'keep')
                              endif
                              return {}

FUNCTION  <SNR>16_LoadFTPlugin()
Called 10 times
Total time:   0.159689
 Self time:   0.145482

count  total (s)   self (s)
   10              0.000042     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
   10              0.000036     let s = expand("<amatch>")
   10              0.000017     if s != ""
   10              0.000080       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   20              0.000070       for name in split(s, '\.')
   10   0.159231   0.145024 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
   10              0.000053       endfor
   10              0.000008     endif

FUNCTION  <SNR>78_option_init()
Called 460 times
Total time:   0.025655
 Self time:   0.009045

count  total (s)   self (s)
  460              0.001852   let b = exists("b:delimitMate_" . a:name)
  460              0.001392   let g = exists("g:delimitMate_" . a:name)
                              " Find value to use.
  460              0.000495   if !b && !g
  460              0.000678     let value = a:default
  460              0.000314   elseif b
                                exec "let value = b:delimitMate_" . a:name
                              else
                                exec "let value = g:delimitMate_" . a:name
                              endif
  460   0.018641   0.002031   call s:set(a:name, value)

FUNCTION  39()
Called 2422 times
Total time:   0.027732
 Self time:   0.008910

count  total (s)   self (s)
 2422   0.026881   0.008059     return nerdtree#runningWindows() ? '\' : '/'

FUNCTION  <SNR>19_SynSet()
Called 11 times
Total time:  13.324649
 Self time:   0.064999

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
   11              0.000155   syn clear
   11              0.000035   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
   11              0.000038   let s = expand("<amatch>")
   11              0.000023   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
   11              0.000012   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
   23              0.000088     for name in split(s, '\.')
   12  13.324042   0.064392       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
   12              0.000022     endfor
   11              0.000006   endif

FUNCTION  nerdtree#exec()
Called 50 times
Total time:   0.008199
 Self time:   0.008199

count  total (s)   self (s)
   50              0.000242     let old_ei = &ei
   50              0.000228     set ei=all
   50              0.007373     exec a:cmd
   50              0.000288     let &ei = old_ei

FUNCTION  <SNR>193_CoffeeWatchResetVars()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
                              " Variables defined in source buffer:
                              "   b:coffee_watch_buf: bufnr of output buffer
                              " Variables defined in output buffer:
                              "   b:coffee_src_buf: bufnr of source buffer
                              "   b:coffee_watch_pos: previous cursor position in output buffer
                            
    1              0.000002   let b:coffee_watch_buf = -1

FUNCTION  <SNR>188_Rgb2xterm()
Called 294 times
Total time:   3.141238
 Self time:   1.402441

count  total (s)   self (s)
  294              0.000517   let best_match=0
  294              0.000439   let smallest_distance = 10000000000
  294              0.001301   let r = eval('0x'.a:color[1].a:color[2])
  294              0.001158   let g = eval('0x'.a:color[3].a:color[4])
  294              0.001126   let b = eval('0x'.a:color[5].a:color[6])
75264              0.069582   for c in range(0,254)
74970   2.719686   0.980889     let d = s:pow(s:colortable[c][0]-r,2) + s:pow(s:colortable[c][1]-g,2) + s:pow(s:colortable[c][2]-b,2)
74970              0.096144     if d<smallest_distance
 1363              0.001874       let smallest_distance = d
 1363              0.001514       let best_match = c
 1363              0.000777     endif
74970              0.047964   endfor
  294              0.000301   return best_match

FUNCTION  <SNR>90_repo()
Called 756 times
Total time:   0.017681
 Self time:   0.017681

count  total (s)   self (s)
  756              0.004801   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
  756              0.001070   if dir !=# ''
  756              0.001717     if has_key(s:repos, dir)
  756              0.001957       let repo = get(s:repos, dir)
  756              0.000489     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
  756              0.004041     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  <SNR>78_ExtraMappings()
Called 20 times
Total time:   0.007152
 Self time:   0.005546

count  total (s)   self (s)
                              " If pair is empty, delete both delimiters:
   20              0.000328   inoremap <silent> <Plug>delimitMateBS <C-R>=delimitMate#BS()<CR>
   20              0.000323   if !hasmapto('<Plug>delimitMateBS','i')
   20              0.000160     if empty(maparg('<BS>', 'i'))
                                  silent! imap <unique> <buffer> <BS> <Plug>delimitMateBS
                                endif
   20              0.000197     if empty(maparg('<C-H>', 'i'))
                                  silent! imap <unique> <buffer> <C-h> <Plug>delimitMateBS
                                endif
   20              0.000010   endif
                              " If pair is empty, delete closing delimiter:
   20              0.000326   inoremap <silent> <expr> <Plug>delimitMateS-BS delimitMate#WithinEmptyPair() ? "\<Del>" : "\<S-BS>"
   20              0.000452   if !hasmapto('<Plug>delimitMateS-BS','i') && maparg('<S-BS>', 'i') == ''
   20              0.000232     silent! imap <unique> <buffer> <S-BS> <Plug>delimitMateS-BS
   20              0.000009   endif
                              " Expand return if inside an empty pair:
   20              0.000324   inoremap <expr><silent> <Plug>delimitMateCR <SID>TriggerAbb()."\<C-R>=delimitMate#ExpandReturn()\<CR>"
   20   0.000674   0.000112   if s:get('expand_cr') && !hasmapto('<Plug>delimitMateCR', 'i') && maparg('<CR>', 'i') == ''
                                silent! imap <unique> <buffer> <CR> <Plug>delimitMateCR
                              endif
                              " Expand space if inside an empty pair:
   20              0.000377   inoremap <expr><silent> <Plug>delimitMateSpace <SID>TriggerAbb()."\<C-R>=delimitMate#ExpandSpace()\<CR>"
   20   0.000636   0.000110   if s:get('expand_space') && !hasmapto('<Plug>delimitMateSpace', 'i') && maparg('<Space>', 'i') == ''
                                silent! imap <unique> <buffer> <Space> <Plug>delimitMateSpace
                              endif
                              " Jump over any delimiter:
   20              0.000368   inoremap <expr><silent> <Plug>delimitMateS-Tab <SID>TriggerAbb()."\<C-R>=delimitMate#JumpAny()\<CR>"
   20   0.001105   0.000587   if s:get('tab2exit') && !hasmapto('<Plug>delimitMateS-Tab', 'i') && maparg('<S-Tab>', 'i') == ''
   20              0.000240     silent! imap <unique> <buffer> <S-Tab> <Plug>delimitMateS-Tab
   20              0.000013   endif
                              " Jump over next delimiters
   20              0.000329   inoremap <expr><buffer> <Plug>delimitMateJumpMany <SID>TriggerAbb()."\<C-R>=delimitMate#JumpMany()\<CR>"
   20              0.000468   if !hasmapto('<Plug>delimitMateJumpMany', 'i') && maparg("<C-G>g", 'i') == ''
   20              0.000235     imap <silent> <buffer> <C-G>g <Plug>delimitMateJumpMany
   20              0.000029   endif

FUNCTION  <SNR>125_buffer_app()
Called 330 times
Total time:   0.014020
 Self time:   0.003843

count  total (s)   self (s)
  330   0.003899   0.001412   if self.getvar('rails_root') != ''
  330   0.009927   0.002237     return rails#app(self.getvar('rails_root'))
                              else
                                throw 'Not in a Rails app'
                              endif

FUNCTION  <SNR>78_get()
Called 700 times
Total time:   0.018569
 Self time:   0.003500

count  total (s)   self (s)
  700   0.018261   0.003192   return call('delimitMate#Get', a:000)

FUNCTION  <SNR>125_readable_calculate_file_type()
Called 61 times
Total time:   0.031538
 Self time:   0.018370

count  total (s)   self (s)
   61   0.010626   0.000260   let f = self.name()
   61              0.000205   let e = fnamemodify(f,':e')
   61              0.000077   let r = "-"
   61   0.002734   0.000253   let full_path = self.path()
   61              0.002885   let nr = bufnr('^'.full_path.'$')
   61              0.000150   if nr < 0 && exists('+shellslash') && ! &shellslash
                                let nr = bufnr('^'.s:gsub(full_path,'/','\\').'$')
                              endif
   61              0.000079   if f == ""
                                let r = f
                              elseif nr > 0 && getbufvar(nr,'rails_file_type') != ''
                                return getbufvar(nr,'rails_file_type')
                              elseif f =~ '_controller\.rb$' || f =~ '\<app/controllers/.*\.rb$'
                                if join(s:readfile(full_path,50),"\n") =~ '\<wsdl_service_name\>'
                                  let r = "controller-api"
                                else
                                  let r = "controller"
                                endif
                              elseif f =~ '\<app/apis/.*_api\.rb'
                                let r = "api"
                              elseif f =~ '\<test/test_helper\.rb$'
                                let r = "test"
                              elseif f =~ '\<spec/spec_helper\.rb$'
                                let r = "spec"
                              elseif f =~ '_helper\.rb$'
                                let r = "helper"
                              elseif f =~ '\<app/mailers/.*\.rb'
                                let r = "mailer"
                              elseif f =~ '\<app/models/'
                                let top = join(s:readfile(full_path,50),"\n")
                                let class = matchstr(top,'\<Acti\w\w\u\w\+\%(::\h\w*\)\+\>')
                                if class == "ActiveResource::Base"
                                  let class = "ares"
                                  let r = "model-ares"
                                elseif class == 'ActionMailer::Base'
                                  let r = "mailer"
                                elseif class != ''
                                  let class = tolower(s:gsub(class,'[^A-Z]',''))
                                  let r = "model-".class
                                elseif f =~ '_mailer\.rb$'
                                  let r = "mailer"
                                elseif top =~ '\<\%(self\.\%(table_name\|primary_key\)\|has_one\|has_many\|belongs_to\)\>'
                                  let r = "model-arb"
                                else
                                  let r = "model"
                                endif
                              elseif f =~ '\<app/views/.*/_\w\+\%(\.[[:alnum:]_+]\+\)\=\.\w\+$'
    1              0.000003     let r = "view-partial-" . e
    1              0.000001   elseif f =~ '\<app/views/layouts\>.*\.'
                                let r = "view-layout-" . e
                              elseif f =~ '\<app/views\>.*\.'
                                let r = "view-" . e
                              elseif f =~ '\<test/\%(unit\|models\|helpers\)/.*_test\.rb$'
                                let r = "test-unit"
                              elseif f =~ '\<test/\%(functional\|controllers\)/.*_test\.rb$'
                                let r = "test-functional"
                              elseif f =~ '\<test/integration/.*_test\.rb$'
                                let r = "test-integration"
                              elseif f =~ '\<test/lib/.*_test\.rb$'
                                let r = "test-lib"
                              elseif f =~ '\<test/\w*s/.*_test\.rb$'
                                let r = s:sub(f,'.*<test/(\w*)s/.*','test-\1')
                              elseif f =~ '\<test/.*_test\.rb'
                                let r = "test"
                              elseif f =~ '\<spec/lib/.*_spec\.rb$'
                                let r = 'spec-lib'
                              elseif f =~ '\<lib/.*\.rb$'
                                let r = 'lib'
                              elseif f =~ '\<spec/\w*s/.*_spec\.rb$'
   16   0.000495   0.000174     let r = s:sub(f,'.*<spec/(\w*)s/.*','spec-\1')
   16              0.000020   elseif f =~ '\<features/.*\.feature$'
                                let r = 'cucumber-feature'
                              elseif f =~ '\<features/step_definitions/.*_steps\.rb$'
                                let r = 'cucumber-steps'
                              elseif f =~ '\<features/.*\.rb$'
                                let r = 'cucumber'
                              elseif f =~ '\<spec/.*\.feature$'
                                let r = 'spec-feature'
                              elseif f =~ '\<\%(test\|spec\)/fixtures\>'
                                if e == "yml"
                                  let r = "fixtures-yaml"
                                else
                                  let r = "fixtures" . (e == "" ? "" : "-" . e)
                                endif
                              elseif f =~ '\<\%(test\|spec\)/\%(factories\|fabricators\)\>'
   13              0.000027     let r = "fixtures-replacement"
   13              0.000012   elseif f =~ '\<spec/.*_spec\.rb'
                                let r = "spec"
                              elseif f =~ '\<spec/support/.*\.rb'
                                let r = "spec"
                              elseif f =~ '\<db/migrate\>'
                                let r = "db-migration"
                              elseif f=~ '\<db/schema\.rb$'
   13              0.000019     let r = "db-schema"
   13              0.000019   elseif f =~ '\.rake$' || f =~ '\<\%(Rake\|Cap\)file$' || f =~ '\<config/deploy\.rb$' || f =~ '\<config/deploy/.*\.rb$'
                                let r = "task"
                              elseif f =~ '\<log/.*\.log$'
                                let r = "log"
                              elseif e == "css" || e =~ "s[ac]ss" || e == "less"
                                let r = "stylesheet-".e
                              elseif e == "js"
    1              0.000001     let r = "javascript"
    1              0.000000   elseif e == "coffee"
    1              0.000002     let r = "javascript-coffee"
    1              0.000001   elseif e == "html"
    2              0.000003     let r = e
    2              0.000002   elseif f =~ '\<config/routes\>.*\.rb$'
                                let r = "config-routes"
                              elseif f =~ '\<config/'
   14              0.000025     let r = "config"
   14              0.000009   endif
   61              0.000064   return r

FUNCTION  <SNR>73_Detect()
Called 10 times
Total time:   0.002915
 Self time:   0.000139

count  total (s)   self (s)
   10              0.000028   if !exists('b:rake_root')
   10   0.002836   0.000060     let dir = s:find_root(a:path)
   10              0.000013     if dir !=# ''
                                  let b:rake_root = dir
                                endif
   10              0.000007   endif

FUNCTION  121()
Called 23 times
Total time:   0.151570
 Self time:   0.000557

count  total (s)   self (s)
   23              0.000037     try
   23   0.067754   0.000211         let path = b:NERDTree.ui.getPath(line("."))
   23              0.000035         if path ==# {}
                                        return {}
                                    endif
   23   0.083591   0.000121         return b:NERDTreeRoot.findNode(path)
                                catch /^NERDTree/
                                    return {}
                                endtry

FUNCTION  <SNR>125_resetomnicomplete()
Called 20 times
Total time:   0.000211
 Self time:   0.000211

count  total (s)   self (s)
   20              0.000079   if exists("+completefunc") && &completefunc == 'syntaxcomplete#Complete'
                                if exists("g:loaded_syntax_completion")
                                  " Ugly but necessary, until we have our own completion
                                  unlet g:loaded_syntax_completion
                                  silent! delfunction syntaxcomplete#Complete
                                endif
                              endif

FUNCTION  <SNR>125_sub()
Called 1585 times
Total time:   0.011743
 Self time:   0.011743

count  total (s)   self (s)
 1585              0.010900   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  <SNR>31_savetofile()
Called 10 times
Total time:   0.012759
 Self time:   0.000077

count  total (s)   self (s)
   10   0.012758   0.000076 	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)

FUNCTION  <SNR>120_expand()
Called 120 times
Total time:   0.026864
 Self time:   0.026864

count  total (s)   self (s)
  120              0.000624   let [e, t, d, f] = [ s:lightline.component_expand, s:lightline.component_type, s:lightline.component, s:lightline.component_function ]
  120              0.000336   let [a, c, _] = [[], [], []]
  360              0.000658   for i in range(len(a:x))
  600              0.001674     if !len(_) || len(_[-1]) | call add(_, []) | call add(c, []) | endif
  660              0.001251     for j in range(len(a:x[i]))
  420              0.001243       if has_key(e, a:x[i][j])
                                    call s:_expand(a, c, _, e, t, i, j, a:x)
                                  elseif has_key(d, a:x[i][j]) || has_key(f, a:x[i][j])
  420              0.001628         if !len(a) || type(a[-1]) != type(i) || a[-1] != i
  240              0.000544           call add(a, i)
  240              0.000981           if len(_) && len(_[-1]) | call add(_, []) | call add(c, []) | endif
  240              0.000125         endif
  720              0.002377         call add(_[-1], a:x[i][j]) | call add(c[-1], 0)
  420              0.000289       endif
  420              0.000305     endfor
  240              0.000211   endfor
  120              0.000292   call add(a, len(a:x))
  120              0.000737   while len(_) && !len(_[-1]) | call remove(_, -1) | call remove(c, -1) | endwhile
  120              0.000181   return [a, c, _]

FUNCTION  <SNR>120_subseparator()
Called 180 times
Total time:   0.006735
 Self time:   0.006735

count  total (s)   self (s)
  180              0.000844   let [c, f, v] = [ s:lightline.component, s:lightline.component_function,  s:lightline.component_visible_condition ]
  180              0.005722   return '%{('.(a:a?'1':has_key(f,a:x)?'!!strlen(exists("*'.f[a:x].'")?'.f[a:x].'():"")':get(v,a:x,has_key(c,a:x)?'1': '0')).')*(('.join(map(range(len(a:y)),'(a:b[v:val]?"1":has_key(f,a:y[v:val])?"!!strlen(exists(\"*".f[a:y[v:val]]."\")?".f[a:y[v:val]]."():\"\")":get(v,a:y[v:val],has_key(c,a:y[v:val])?"1":"0"))'),')+(')."))?('".a:s."'):''}"

FUNCTION  <SNR>133_build_path()
Called 1 time
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000027   let path = join(map(copy(a:path), 'v:val ==# "." ? "" : v:val'), ',')
    1              0.000009   if &g:path !~# '\v^\.%(,/%(usr|emx)/include)=,,$'
                                let path = substitute(&g:path,',,$',',','') . ',' . path
                              endif
    1              0.000002   return path

FUNCTION  <SNR>90_shellslash()
Called 60 times
Total time:   0.000985
 Self time:   0.000566

count  total (s)   self (s)
   60   0.000657   0.000238   if s:winshell()
                                return s:gsub(a:path,'\\','/')
                              else
   60              0.000066     return a:path
                              endif

FUNCTION  rails#app()
Called 852 times
Total time:   0.013853
 Self time:   0.013853

count  total (s)   self (s)
  852              0.002869   let root = a:0 ? a:1 : get(b:, 'rails_root', '')
  852              0.001550   if !empty(root)
  852              0.002609     if !has_key(s:apps, root) && filereadable(root . '/config/environment.rb')
                                  let s:apps[root] = deepcopy(s:app_prototype)
                                  let s:apps[root].root = root
                                  let s:apps[root]._root = root
                                endif
  852              0.002082     return get(s:apps, root, {})
                              endif
                              return {}

FUNCTION  <SNR>125_app_gems()
Called 71 times
Total time:   0.023380
 Self time:   0.001352

count  total (s)   self (s)
   71   0.003197   0.000574   if self.has('bundler') && exists('*bundler#project')
   71   0.020142   0.000737     return bundler#project(self.path()).gems()
                              else
                                return {}
                              endif

FUNCTION  <SNR>73_shellslash()
Called 40 times
Total time:   0.000280
 Self time:   0.000280

count  total (s)   self (s)
   40              0.000104   if exists('+shellslash') && !&shellslash
                                return substitute(a:path, '\\', '/', 'g')
                              else
   40              0.000041     return a:path
                              endif

FUNCTION  339()
Called 10 times
Total time:   0.001065
 Self time:   0.000226

count  total (s)   self (s)
   10   0.000122   0.000045     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
   10   0.000129   0.000049     let old_signs = copy(self._bufSignIds())
   10   0.000178   0.000035     if self.enabled()
   10   0.000449   0.000042         call self._signErrors(a:loclist)
   10              0.000008     endif
   10   0.000168   0.000036     call self._removeSigns(old_signs)

FUNCTION  207()
Called 105 times
Total time:   0.000833
 Self time:   0.000833

count  total (s)   self (s)
  105              0.000469     let newObj = copy(self)
  105              0.000179     let newObj._flags = {}
  105              0.000104     return newObj

FUNCTION  209()
Called 81 times
Total time:   0.000941
 Self time:   0.000941

count  total (s)   self (s)
   81              0.000136     let flagstring = ""
   81              0.000224     for i in values(self._flags)
                                    let flagstring .= join(i)
                                endfor
                            
   81              0.000159     if len(flagstring) == 0
   81              0.000069         return ""
                                endif
                            
                                return '[' . flagstring . ']'

FUNCTION  rails#buffer_syntax()
Called 7 times
Total time:   0.050075
 Self time:   0.005333

count  total (s)   self (s)
    7              0.000023   if !exists("g:rails_no_syntax")
    7   0.000209   0.000035     let buffer = rails#buffer()
    7   0.012210   0.000155     let keywords = split(join(buffer.projected('keywords'), ' '))
    7              0.000031     let special = filter(copy(keywords), 'v:val =~# ''^\h\k*[?!]$''')
    7              0.000024     let regular = filter(copy(keywords), 'v:val =~# ''^\h\k*$''')
    7              0.000016     if &syntax == 'ruby'
    4              0.000006       if !empty(special)
                                    exe 'syn match rubyRailsMethod "\<\%('.join(special, '\|').'\)"'
                                  endif
    4              0.000009       if !empty(regular)
                                    exe 'syn keyword rubyRailsMethod '.join(regular, ' ')
                                  endif
    4   0.002274   0.000022       if buffer.type_name() == ''
                                    syn keyword rubyRailsMethod params request response session headers cookies flash
                                  endif
    4   0.004417   0.000035       if buffer.type_name() ==# 'model' || buffer.type_name('model-arb')
                                    syn keyword rubyRailsARMethod default_scope enum named_scope scope serialize store
                                    syn keyword rubyRailsARAssociationMethod belongs_to has_one has_many has_and_belongs_to_many composed_of accepts_nested_attributes_for
                                    syn keyword rubyRailsARCallbackMethod before_create before_destroy before_save before_update before_validation before_validation_on_create before_validation_on_update
                                    syn keyword rubyRailsARCallbackMethod after_create after_destroy after_save after_update after_validation after_validation_on_create after_validation_on_update
                                    syn keyword rubyRailsARCallbackMethod around_create around_destroy around_save around_update
                                    syn keyword rubyRailsARCallbackMethod after_commit after_find after_initialize after_rollback after_touch
                                    syn keyword rubyRailsARClassMethod attr_accessible attr_protected attr_readonly has_secure_password store_accessor
                                    syn keyword rubyRailsARValidationMethod validate validates validate_on_create validate_on_update validates_acceptance_of validates_associated validates_confirmation_of validates_each validates_exclusion_of validates_format_of validates_inclusion_of validates_length_of validates_numericality_of validates_presence_of validates_size_of validates_uniqueness_of validates_with
                                    syn keyword rubyRailsMethod logger
                                  endif
    4   0.002193   0.000020       if buffer.type_name('model-aro')
                                    syn keyword rubyRailsARMethod observe
                                  endif
    4   0.002208   0.000021       if buffer.type_name('mailer')
                                    syn keyword rubyRailsMethod logger url_for polymorphic_path polymorphic_url
                                    syn keyword rubyRailsRenderMethod mail render
                                    syn keyword rubyRailsControllerMethod attachments default helper helper_attr helper_method
                                  endif
    4   0.002235   0.000024       if buffer.type_name('helper','view')
                                    syn keyword rubyRailsViewMethod polymorphic_path polymorphic_url
                                    exe "syn keyword rubyRailsHelperMethod ".s:gsub(s:helpermethods(),'<%(content_for|select)\s+','')
                                    syn match rubyRailsHelperMethod '\<select\>\%(\s*{\|\s*do\>\|\s*(\=\s*&\)\@!'
                                    syn match rubyRailsHelperMethod '\<\%(content_for?\=\|current_page?\)'
                                    syn match rubyRailsViewMethod '\.\@<!\<\(h\|html_escape\|u\|url_encode\)\>'
                                    if buffer.type_name('view-partial')
                                      syn keyword rubyRailsMethod local_assigns
                                    endif
                                  elseif buffer.type_name('controller')
                                    syn keyword rubyRailsMethod params request response session headers cookies flash
                                    syn keyword rubyRailsRenderMethod render
                                    syn keyword rubyRailsMethod logger polymorphic_path polymorphic_url
                                    syn keyword rubyRailsControllerMethod helper helper_attr helper_method filter layout url_for serialize exempt_from_layout filter_parameter_logging hide_action cache_sweeper protect_from_forgery caches_page cache_page caches_action expire_page expire_action rescue_from
                                    syn keyword rubyRailsRenderMethod head redirect_to render_to_string respond_with
                                    syn match   rubyRailsRenderMethod '\<respond_to\>?\@!'
                                    syn keyword rubyRailsFilterMethod before_filter append_before_filter prepend_before_filter after_filter append_after_filter prepend_after_filter around_filter append_around_filter prepend_around_filter skip_before_filter skip_after_filter skip_filter before_action append_before_action prepend_before_action after_action append_after_action prepend_after_action around_action append_around_action prepend_around_action skip_before_action skip_after_action skip_action
                                    syn keyword rubyRailsFilterMethod verify
                                  endif
    4   0.002245   0.000024       if buffer.type_name('db-migration','db-schema')
    1              0.000007         syn keyword rubyRailsMigrationMethod create_table change_table drop_table rename_table create_join_table drop_join_table
    1              0.000011         syn keyword rubyRailsMigrationMethod add_column rename_column change_column change_column_default change_column_null remove_column remove_columns
    1              0.000004         syn keyword rubyRailsMigrationMethod add_timestamps remove_timestamps
    1              0.000003         syn keyword rubyRailsMigrationMethod add_reference remove_reference add_belongs_to remove_belongs_to
    1              0.000003         syn keyword rubyRailsMigrationMethod add_index remove_index rename_index
    1              0.000003         syn keyword rubyRailsMigrationMethod execute transaction reversible revert
    1              0.000000       endif
    4   0.002254   0.000020       if buffer.type_name('test')
                                    if !empty(rails#app().user_assertions())
                                      exe "syn keyword rubyRailsUserMethod ".join(rails#app().user_assertions())
                                    endif
                                    syn keyword rubyRailsTestMethod refute refute_empty refute_equal refute_in_delta refute_in_epsilon refute_includes refute_instance_of refute_kind_of refute_match refute_nil refute_operator refute_predicate refute_respond_to refute_same
                                    syn keyword rubyRailsTestMethod add_assertion assert assert_block assert_equal assert_in_delta assert_instance_of assert_kind_of assert_match assert_nil assert_no_match assert_not assert_not_equal assert_not_nil assert_not_same assert_nothing_raised assert_nothing_thrown assert_operator assert_raise assert_respond_to assert_same assert_send assert_throws assert_recognizes assert_generates assert_routing flunk fixtures fixture_path use_transactional_fixtures use_instantiated_fixtures assert_difference assert_no_difference assert_valid
                                    syn keyword rubyRailsTestMethod test setup teardown
                                    if !buffer.type_name('test-unit')
                                      syn match   rubyRailsTestControllerMethod  '\.\@<!\<\%(get\|post\|put\|patch\|delete\|head\|process\|assigns\)\>'
                                      syn keyword rubyRailsTestControllerMethod get_via_redirect post_via_redirect put_via_redirect delete_via_redirect request_via_redirect
                                      syn keyword rubyRailsTestControllerMethod assert_response assert_redirected_to assert_template assert_recognizes assert_generates assert_routing assert_dom_equal assert_dom_not_equal assert_select assert_select_rjs assert_select_encoded assert_select_email assert_tag assert_no_tag
                                    endif
                                  elseif buffer.type_name('spec')
    1              0.000023         syn keyword rubyRailsTestMethod describe context it its specify shared_context shared_examples shared_examples_for shared_context include_examples include_context it_should_behave_like it_behaves_like before after around subject fixtures controller_name helper_name scenario feature background given described_class
    1              0.000007         syn match rubyRailsTestMethod '\<let\>!\='
    1              0.000007         syn keyword rubyRailsTestMethod violated pending expect expect_any_instance_of allow allow_any_instance_of double instance_double mock mock_model stub_model xit
    1              0.000006         syn match rubyRailsTestMethod '\.\@<!\<stub\>!\@!'
    1   0.000561   0.000006         if !buffer.type_name('spec-model')
    1              0.000012           syn match   rubyRailsTestControllerMethod  '\.\@<!\<\%(get\|post\|put\|patch\|delete\|head\|process\|assigns\)\>'
    1              0.000005           syn keyword rubyRailsTestControllerMethod  integrate_views render_views
    1              0.000005           syn keyword rubyRailsMethod params request response session flash
    1              0.000004           syn keyword rubyRailsMethod polymorphic_path polymorphic_url
    1   0.000560   0.000005           if buffer.type_name('spec-view')
                                        syn keyword rubyRailsTestViewMethod render rendered assign
                                      elseif buffer.type_name('spec-helper')
                                        syn keyword RubyRailsTestHelperMethod helper
                                      endif
    1              0.000001         endif
    1              0.000000       endif
    4   0.002230   0.000020       if buffer.type_name('task')
                                    syn match rubyRailsRakeMethod '^\s*\zs\%(task\|file\|namespace\|desc\|before\|after\|on\)\>\%(\s*=\)\@!'
                                  endif
    4   0.002203   0.000020       if buffer.type_name('config-routes')
                                    syn match rubyRailsMethod '\.\zs\%(connect\|named_route\)\>'
                                    syn keyword rubyRailsMethod match get put patch post delete redirect root resource resources collection member nested scope namespace controller constraints mount concern
                                  endif
    4              0.000013       syn keyword rubyRailsMethod debugger
    4              0.000048       syn keyword rubyRailsMethod alias_attribute alias_method_chain attr_accessor_with_default attr_internal attr_internal_accessor attr_internal_reader attr_internal_writer concerning delegate mattr_accessor mattr_reader mattr_writer superclass_delegating_accessor superclass_delegating_reader superclass_delegating_writer with_options
    4              0.000036       syn keyword rubyRailsMethod cattr_accessor cattr_reader cattr_writer class_inheritable_accessor class_inheritable_array class_inheritable_array_writer class_inheritable_hash class_inheritable_hash_writer class_inheritable_option class_inheritable_reader class_inheritable_writer inheritable_attributes read_inheritable_attribute reset_inheritable_attributes write_inheritable_array write_inheritable_attribute write_inheritable_hash
    4              0.000012       syn keyword rubyRailsInclude require_dependency
                            
    4              0.000089       syn region  rubyString   matchgroup=rubyStringDelimiter start=+\%(:order\s*=>\s*\)\@<="+ skip=+\\\\\|\\"+ end=+"+ contains=@rubyStringSpecial,railsOrderSpecial
    4              0.000071       syn region  rubyString   matchgroup=rubyStringDelimiter start=+\%(:order\s*=>\s*\)\@<='+ skip=+\\\\\|\\'+ end=+'+ contains=@rubyStringSpecial,railsOrderSpecial
    4              0.000021       syn match   railsOrderSpecial +\c\<\%(DE\|A\)SC\>+ contained
    4              0.000072       syn region  rubyString   matchgroup=rubyStringDelimiter start=+\%(:conditions\s*=>\s*\[\s*\)\@<="+ skip=+\\\\\|\\"+ end=+"+ contains=@rubyStringSpecial,railsConditionsSpecial
    4              0.000074       syn region  rubyString   matchgroup=rubyStringDelimiter start=+\%(:conditions\s*=>\s*\[\s*\)\@<='+ skip=+\\\\\|\\'+ end=+'+ contains=@rubyStringSpecial,railsConditionsSpecial
    4              0.000020       syn match   railsConditionsSpecial +?\|:\h\w*+ contained
    4              0.000040       syn cluster rubyNotTop add=railsOrderSpecial,railsConditionsSpecial
                            
    4              0.000005     elseif &syntax =~# '^eruby\>' || &syntax == 'haml'
                                  let containedin = 'contained containedin=@'.&syntax.'RailsRegions'
                                  syn case match
                                  if !empty(special)
                                    exe 'syn match '.&syntax.'RailsMethod "\<\%('.join(special, '\|').'\)"' containedin
                                  endif
                                  if !empty(regular)
                                    exe 'syn keyword '.&syntax.'RailsMethod '.join(regular, ' ') containedin
                                  endif
                                  if &syntax == 'haml'
                                    exe 'syn cluster hamlRailsRegions contains=hamlRubyCodeIncluded,hamlRubyCode,hamlRubyHash,@hamlEmbeddedRuby,rubyInterpolation'
                                  else
                                    exe 'syn cluster erubyRailsRegions contains=erubyOneLiner,erubyBlock,erubyExpression,rubyInterpolation'
                                  endif
                                  exe 'syn keyword '.&syntax.'RailsHelperMethod '.s:gsub(s:helpermethods(),'<%(content_for|select)\s+','').' contained containedin=@'.&syntax.'RailsRegions'
                                  exe 'syn match '.&syntax.'RailsHelperMethod "\<select\>\%(\s*{\|\s*do\>\|\s*(\=\s*&\)\@!" contained containedin=@'.&syntax.'RailsRegions'
                                  exe 'syn match '.&syntax.'RailsHelperMethod "\<\%(content_for?\=\|current_page?\)" contained containedin=@'.&syntax.'RailsRegions'
                                  exe 'syn keyword '.&syntax.'RailsMethod debugger polymorphic_path polymorphic_url contained containedin=@'.&syntax.'RailsRegions'
                                  exe 'syn match '.&syntax.'RailsViewMethod "\.\@<!\<\(h\|html_escape\|u\|url_encode\)\>" contained containedin=@'.&syntax.'RailsRegions'
                                  if buffer.type_name('view-partial')
                                    exe 'syn keyword '.&syntax.'RailsMethod local_assigns contained containedin=@'.&syntax.'RailsRegions'
                                  endif
                                  exe 'syn keyword '.&syntax.'RailsRenderMethod render contained containedin=@'.&syntax.'RailsRegions'
                                  exe 'syn case match'
                                elseif &syntax == "yaml"
    1              0.000001       syn case match
    1              0.000002       unlet! b:current_syntax
    1              0.000002       let g:main_syntax = 'eruby'
    1   0.003948   0.001064       syn include @rubyTop syntax/ruby.vim
    1              0.000002       unlet g:main_syntax
    1              0.000020       syn cluster yamlRailsRegions contains=yamlRailsOneLiner,yamlRailsBlock,yamlRailsExpression
    1              0.000015       syn region  yamlRailsOneLiner   matchgroup=yamlRailsDelimiter start="^%%\@!" end="$"  contains=@rubyRailsTop      containedin=ALLBUT,@yamlRailsRegions,yamlRailsComment keepend oneline
    1              0.000012       syn region  yamlRailsBlock      matchgroup=yamlRailsDelimiter start="<%%\@!" end="%>" contains=@rubyTop           containedin=ALLBUT,@yamlRailsRegions,yamlRailsComment
    1              0.000011       syn region  yamlRailsExpression matchgroup=yamlRailsDelimiter start="<%="    end="%>" contains=@rubyTop           containedin=ALLBUT,@yamlRailsRegions,yamlRailsComment
    1              0.000014       syn region  yamlRailsComment    matchgroup=yamlRailsDelimiter start="<%#"    end="%>" contains=rubyTodo,@Spell    containedin=ALLBUT,@yamlRailsRegions,yamlRailsComment keepend
    1              0.000013       syn match yamlRailsMethod '\.\@<!\<\(h\|html_escape\|u\|url_encode\)\>' contained containedin=@yamlRailsRegions
    1              0.000003       let b:current_syntax = "yaml"
                            
    1              0.000001     elseif &syntax == "scss" || &syntax == "sass"
                                  syn match sassFunction "\<\%(\%(asset\|image\|font\|video\|audio\|javascript\|stylesheet\)-\%(url\|path\)\)\>(\@=" contained
                                  syn match sassFunction "\<\asset-data-url\>(\@=" contained
                                endif
    7              0.000006   endif
    7   0.001475   0.000040   call s:HiDefaults()

FUNCTION  <SNR>188_Xterm2rgb()
Called 255 times
Total time:   0.007236
 Self time:   0.007236

count  total (s)   self (s)
                              " 16 basic colors
  255              0.000282   let r=0
  255              0.000211   let g=0
  255              0.000206   let b=0
  255              0.000244   if a:color<16
   16              0.000038     let r = s:basic16[a:color][0]
   16              0.000036     let g = s:basic16[a:color][1]
   16              0.000032     let b = s:basic16[a:color][2]
   16              0.000013   endif
                            
                              " color cube color
  255              0.000319   if a:color>=16 && a:color<=232
  217              0.000412     let color=a:color-16
  217              0.000495     let r = s:valuerange[(color/36)%6]
  217              0.000429     let g = s:valuerange[(color/6)%6]
  217              0.000389     let b = s:valuerange[color%6]
  217              0.000124   endif
                            
                              " gray tone
  255              0.000299   if a:color>=233 && a:color<=253
   21              0.000045     let r=8+(a:color-232)*0x0a
   21              0.000021     let g=r
   21              0.000018     let b=r
   21              0.000007   endif
  255              0.000499   let rgb=[r,g,b]
  255              0.000220   return rgb

FUNCTION  <SNR>90_buffer_getline()
Called 30 times
Total time:   0.000158
 Self time:   0.000158

count  total (s)   self (s)
   30              0.000146   return get(getbufline(self['#'], a:lnum), 0, '')

FUNCTION  212()
Called 10 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
   10              0.000026     if g:NERDTreeQuitOnOpen && s:NERDTree.IsOpen()
                                    call s:NERDTree.Close()
                                endif

FUNCTION  215()
Called 36 times
Total time:   0.000221
 Self time:   0.000221

count  total (s)   self (s)
   36              0.000185     return exists("b:NERDTreeRoot")

FUNCTION  fugitive#is_git_dir()
Called 80 times
Total time:   0.001914
 Self time:   0.001209

count  total (s)   self (s)
   80   0.001155   0.000450   let path = s:sub(a:path, '[\/]$', '') . '/'
   80              0.000701   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10

FUNCTION  <SNR>125_app_path()
Called 751 times
Total time:   0.004063
 Self time:   0.004063

count  total (s)   self (s)
  751              0.003695   return join([self.root]+a:000,'/')

FUNCTION  <SNR>90_buffer_type()
Called 10 times
Total time:   0.002592
 Self time:   0.000987

count  total (s)   self (s)
   10   0.000074   0.000041   if self.getvar('fugitive_type') != ''
                                let type = self.getvar('fugitive_type')
                              elseif fnamemodify(self.spec(),':p') =~# '.\git/refs/\|\.git/\w*HEAD$'
                                let type = 'head'
                              elseif self.getline(1) =~ '^tree \x\{40\}$' && self.getline(2) == ''
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \w\{4\} \x\{40\}\>\t'
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \x\{40\}\> \d\t'
                                let type = 'index'
                              elseif isdirectory(self.spec())
                                let type = 'directory'
                              elseif self.spec() == ''
                                let type = 'null'
                              else
   10              0.000015     let type = 'file'
   10              0.000006   endif
   10              0.000007   if a:0
   10              0.000077     return !empty(filter(copy(a:000),'v:val ==# type'))
                              else
                                return type
                              endif

FUNCTION  222()
Called 997 times
Total time:   0.006509
 Self time:   0.006509

count  total (s)   self (s)
  997              0.002828     if !exists('s:NERDTree._PathFilters')
                                    let s:NERDTree._PathFilters = []
                                endif
  997              0.001192     return s:NERDTree._PathFilters

FUNCTION  223()
Called 13 times
Total time:   0.240462
 Self time:   0.000089

count  total (s)   self (s)
   13   0.240451   0.000078     call self.ui.render()

FUNCTION  225()
Called 13 times
Total time:   0.001578
 Self time:   0.001578

count  total (s)   self (s)
   13              0.000045     let old_h = @h
   13              0.000031     if b:treeShowHelp ==# 1
                                    let @h=   "\" NERD tree (" . nerdtree#version() . ") quickhelp~\n"
                                    let @h=@h."\" ============================\n"
                                    let @h=@h."\" File node mappings~\n"
                                    let @h=@h."\" ". (g:NERDTreeMouseMode ==# 3 ? "single" : "double") ."-click,\n"
                                    let @h=@h."\" <CR>,\n"
                                    if b:NERDTreeType ==# "primary"
                                        let @h=@h."\" ". g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let @h=@h."\" ". g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if b:NERDTreeType ==# "primary"
                                        let @h=@h."\" ". g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let @h=@h."\" middle-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenSplit .": open split\n"
                                    let @h=@h."\" ". g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let @h=@h."\" ". g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Directory node mappings~\n"
                                    let @h=@h."\" ". (g:NERDTreeMouseMode ==# 1 ? "double" : "single") ."-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapActivateNode .": open & close node\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let @h=@h."\" ". g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let @h=@h."\" ". g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let @h=@h."\"    current node recursively\n"
                                    let @h=@h."\" middle-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Bookmark table mappings~\n"
                                    let @h=@h."\" double-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let @h=@h."\" ". g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Tree navigation mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpRoot .": go to root\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpParent .": go to parent\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Filesystem mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let @h=@h."\"    selected dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let @h=@h."\"    but leave old root open\n"
                                    let @h=@h."\" ". g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let @h=@h."\" ". g:NERDTreeMapMenu .": Show menu\n"
                                    let @h=@h."\" ". g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let @h=@h."\"    selected dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Tree filtering mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleHidden .": hidden files (" . (b:NERDTreeShowHidden ? "on" : "off") . ")\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleFilters .": file filters (" . (b:NERDTreeIgnoreEnabled ? "on" : "off") . ")\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleFiles .": files (" . (b:NERDTreeShowFiles ? "on" : "off") . ")\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleBookmarks .": bookmarks (" . (b:NERDTreeShowBookmarks ? "on" : "off") . ")\n"
                            
                                    "add quickhelp entries for each custom key map
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let @h=@h."\" ". i.key .": ". i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Other mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let @h=@h."\"    the NERDTree window\n"
                                    let @h=@h."\" ". g:NERDTreeMapHelp .": toggle help\n"
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Bookmark commands~\n"
                                    let @h=@h."\" :Bookmark [<name>]\n"
                                    let @h=@h."\" :BookmarkToRoot <name>\n"
                                    let @h=@h."\" :RevealBookmark <name>\n"
                                    let @h=@h."\" :OpenBookmark <name>\n"
                                    let @h=@h."\" :ClearBookmarks [<names>]\n"
                                    let @h=@h."\" :ClearAllBookmarks\n"
                                    silent! put h
                                elseif g:NERDTreeMinimalUI == 0
                                    let @h="\" Press ". g:NERDTreeMapHelp ." for help\n"
                                    silent! put h
                                endif
                            
   13              0.000039     let @h = old_h

FUNCTION  227()
Called 23 times
Total time:   0.067543
 Self time:   0.016875

count  total (s)   self (s)
   23              0.000116     let line = getline(a:ln)
                            
   23   0.000620   0.000119     let rootLine = self.getRootLineNum()
                            
                                "check to see if we have the root node
   23              0.000031     if a:ln == rootLine
                                    return b:NERDTreeRoot.path
                                endif
                            
   23              0.000025     if !g:NERDTreeDirArrows
                                    " in case called from outside the tree
                                    if line !~# '^ *[|` ]' || line =~# '^$'
                                        return {}
                                    endif
                                endif
                            
   23   0.000169   0.000127     if line ==# s:UI.UpDirLine()
                                    return b:NERDTreeRoot.path.getParent()
                                endif
                            
   23   0.000791   0.000107     let indent = self._indentLevelFor(line)
                            
                                "remove the tree parts and the leading space
   23   0.001820   0.000134     let curFile = self._stripMarkup(line, 0)
                            
   23              0.000027     let wasdir = 0
   23              0.000078     if curFile =~# '/$'
   13              0.000018         let wasdir = 1
   13              0.000091         let curFile = substitute(curFile, '/\?$', '/', "")
   13              0.000007     endif
                            
   23              0.000032     let dir = ""
   23              0.000028     let lnum = a:ln
  473              0.000505     while lnum > 0
  473              0.000904         let lnum = lnum - 1
  473              0.001176         let curLine = getline(lnum)
  473   0.036477   0.002578         let curLineStripped = self._stripMarkup(curLine, 1)
                            
                                    "have we reached the top of the tree?
  473              0.000611         if lnum == rootLine
   23   0.001804   0.000218             let dir = b:NERDTreeRoot.path.str({'format': 'UI'}) . dir
   23              0.000019             break
                                    endif
  450              0.001520         if curLineStripped =~# '/$'
  206   0.006283   0.001240             let lpindent = self._indentLevelFor(curLine)
  206              0.000269             if lpindent < indent
   33              0.000057                 let indent = indent - 1
                            
   33              0.000203                 let dir = substitute (curLineStripped,'^\\', "", "") . dir
   33              0.000043                 continue
                                        endif
  173              0.000075         endif
  417              0.000386     endwhile
   23              0.000080     let curFile = b:NERDTreeRoot.path.drive . dir . curFile
   23   0.007358   0.000131     let toReturn = g:NERDTreePath.New(curFile)
   23              0.000023     return toReturn

FUNCTION  228()
Called 13 times
Total time:   0.026437
 Self time:   0.009969

count  total (s)   self (s)
                                "if the node is the root then return the root line no.
   13   0.002817   0.000046     if a:file_node.isRoot()
                                    return b:NERDTree.ui.getRootLineNum()
                                endif
                            
   13              0.000033     let totalLines = line("$")
                            
                                "the path components we have matched so far
   13   0.001050   0.000212     let pathcomponents = [substitute(b:NERDTreeRoot.path.str({'format': 'UI'}), '/ *$', '', '')]
                                "the index of the component we are searching for
   13              0.000024     let curPathComponent = 1
                            
   13   0.000934   0.000084     let fullpath = a:file_node.path.str({'format': 'UI'})
                            
   13   0.000232   0.000059     let lnum = b:NERDTree.ui.getRootLineNum()
  251              0.000272     while lnum > 0
  251              0.000457         let lnum = lnum + 1
                                    "have we reached the bottom of the tree?
  251              0.000401         if lnum ==# totalLines+1
                                        return -1
                                    endif
                            
  251              0.000593         let curLine = getline(lnum)
                            
  251   0.007032   0.001125         let indent = self._indentLevelFor(curLine)
  251              0.000373         if indent ==# curPathComponent
   80   0.006351   0.000422             let curLine = self._stripMarkup(curLine, 1)
                            
   80              0.000475             let curPath =  join(pathcomponents, '/') . '/' . curLine
   80              0.000253             if stridx(fullpath, curPath, 0) ==# 0
   26              0.000114                 if fullpath ==# curPath || strpart(fullpath, len(curPath)-1,1) ==# '/'
   26              0.000170                     let curLine = substitute(curLine, '/ *$', '', '')
   26              0.000077                     call add(pathcomponents, curLine)
   26              0.000063                     let curPathComponent = curPathComponent + 1
                            
   26              0.000044                     if fullpath ==# curPath
   13              0.000013                         return lnum
                                                endif
   13              0.000007                 endif
   13              0.000004             endif
   67              0.000028         endif
  238              0.000207     endwhile
                                return -1

FUNCTION  229()
Called 36 times
Total time:   0.000674
 Self time:   0.000674

count  total (s)   self (s)
   36              0.000068     let rootLine = 1
   36              0.000420     while getline(rootLine) !~# '^\(/\|<\)'
                                    let rootLine = rootLine + 1
                                endwhile
   36              0.000040     return rootLine

FUNCTION  <SNR>125_buffer_name()
Called 189 times
Total time:   0.032489
 Self time:   0.016668

count  total (s)   self (s)
  189   0.008804   0.000716   let app = self.app()
  189   0.010488   0.008416   let f = s:gsub(resolve(fnamemodify(bufname(self.number()),':p')),'\\ @!','/')
  189   0.002443   0.000954   let f = s:sub(f,'/$','')
  189              0.001670   let sep = matchstr(f,'^[^\\/]\{3,\}\zs[\\/]')
  189              0.000315   if sep != ""
                                let f = getcwd().sep.f
                              endif
  189   0.005961   0.002666   if s:startswith(tolower(f),s:gsub(tolower(app.path()),'\\ @!','/')) || f == ""
  189   0.001988   0.001111     return strpart(f,strlen(app.path())+1)
                              else
                                if !exists("s:path_warn") && &verbose
                                  let s:path_warn = 1
                                  call s:warn("File ".f." does not appear to be under the Rails root ".self.app().path().". Please report to the rails.vim author!")
                                endif
                                return f
                              endif

FUNCTION  <SNR>195_SetMakePrg()
Called 1 time
Total time:   0.000040
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000007   if &l:makeprg =~ s:pat
    1   0.000024   0.000008     let &l:makeprg = s:GetMakePrg()
    1              0.000002   elseif &g:makeprg =~ s:pat
                                let &g:makeprg = s:GetMakePrg()
                              else
                                return 0
                              endif
                            
    1              0.000000   return 1

FUNCTION  <SNR>125_BufNavCommands()
Called 10 times
Total time:   0.002100
 Self time:   0.002100

count  total (s)   self (s)
   10              0.000086   command! -buffer -bar -nargs=? -complete=customlist,s:Complete_cd Cd    :cd `=rails#app().path(<q-args>)`
   10              0.000059   command! -buffer -bar -nargs=? -complete=customlist,s:Complete_cd Lcd  :lcd `=rails#app().path(<q-args>)`
   10              0.000054   command! -buffer -bar -nargs=? -complete=customlist,s:Complete_cd Rcd   :cd `=rails#app().path(<q-args>)`
   10              0.000052   command! -buffer -bar -nargs=? -complete=customlist,s:Complete_cd Rlcd :lcd `=rails#app().path(<q-args>)`
   10              0.000156   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_related A     :call s:Alternate('<bang>', <line1>,<line2>,<count>,<f-args>)
   10              0.000140   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_related AE    :call s:Alternate('E<bang>',<line1>,<line2>,<count>,<f-args>)
   10              0.000136   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_related AS    :call s:Alternate('S<bang>',<line1>,<line2>,<count>,<f-args>)
   10              0.000140   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_related AV    :call s:Alternate('V<bang>',<line1>,<line2>,<count>,<f-args>)
   10              0.000144   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_related AT    :call s:Alternate('T<bang>',<line1>,<line2>,<count>,<f-args>)
   10              0.000138   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_related AD    :call s:Alternate('D<bang>',<line1>,<line2>,<count>,<f-args>)
   10              0.000137   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_related AR    :call s:Alternate('D<bang>',<line1>,<line2>,<count>,<f-args>)
   10              0.000135   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_related R     :call s:Related('<bang>' ,<line1>,<line2>,<count>,<f-args>)
   10              0.000143   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_related RE    :call s:Related('E<bang>',<line1>,<line2>,<count>,<f-args>)
   10              0.000138   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_related RS    :call s:Related('S<bang>',<line1>,<line2>,<count>,<f-args>)
   10              0.000138   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_related RV    :call s:Related('V<bang>',<line1>,<line2>,<count>,<f-args>)
   10              0.000135   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_related RT    :call s:Related('T<bang>',<line1>,<line2>,<count>,<f-args>)
   10              0.000135   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_related RD    :call s:Related('D<bang>',<line1>,<line2>,<count>,<f-args>)

FUNCTION  <SNR>90_buffer_getvar()
Called 50 times
Total time:   0.000210
 Self time:   0.000210

count  total (s)   self (s)
   50              0.000179   return getbufvar(self['#'],a:var)

FUNCTION  237()
Called 13 times
Total time:   0.240373
 Self time:   0.002536

count  total (s)   self (s)
   13              0.000073     setlocal modifiable
                            
                                "remember the top line of the buffer and the current line so we can
                                "restore the view exactly how it was
   13              0.000037     let curLine = line(".")
   13              0.000027     let curCol = col(".")
   13              0.000032     let topLine = line("w0")
                            
                                "delete all lines in the buffer (being careful not to clobber a register)
   13              0.000498     silent 1,$delete _
                            
   13   0.001698   0.000120     call self._dumpHelp()
                            
                                "delete the blank line before the help and add one after it
   13              0.000015     if g:NERDTreeMinimalUI == 0
                                    call setline(line(".")+1, "")
                                    call cursor(line(".")+1, col("."))
                                endif
                            
   13              0.000022     if b:NERDTreeShowBookmarks
                                    call self._renderBookmarks()
                                endif
                            
                                "add the 'up a dir' line
   13              0.000014     if !g:NERDTreeMinimalUI
                                    call setline(line(".")+1, s:UI.UpDirLine())
                                    call cursor(line(".")+1, col("."))
                                endif
                            
                                "draw the header line
   13   0.001214   0.000126     let header = b:NERDTreeRoot.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
   13              0.000111     call setline(line(".")+1, header)
   13              0.000066     call cursor(line(".")+1, col("."))
                            
                                "draw the tree
   13              0.000024     let old_o = @o
   13   0.235370   0.000199     let @o = b:NERDTreeRoot.renderToString()
   13              0.000197     silent put o
   13              0.000107     let @o = old_o
                            
                                "delete the blank line at the top of the buffer
   13              0.000069     silent 1,1delete _
                            
                                "restore the view
   13              0.000037     let old_scrolloff=&scrolloff
   13              0.000057     let &scrolloff=0
   13              0.000040     call cursor(topLine, 1)
   13              0.000241     normal! zt
   13              0.000042     call cursor(curLine, curCol)
   13              0.000039     let &scrolloff = old_scrolloff
                            
   13              0.000035     setlocal nomodifiable

FUNCTION  <SNR>125_AddTabExpand()
Called 2 times
Total time:   0.000152
 Self time:   0.000012

count  total (s)   self (s)
    2   0.000150   0.000010   call s:AddSelectiveExpand(a:abbr,'..',a:expn)

FUNCTION  <SNR>125_getlist()
Called 3 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    3              0.000009   let value = get(a:arg, a:key, [])
    3              0.000012   return type(value) == type([]) ? copy(value) : [value]

FUNCTION  MyFilename()
Called 789 times
Total time:   0.011082
 Self time:   0.006264

count  total (s)   self (s)
  789   0.010679   0.005861   return ('' != MyReadonly() ? MyReadonly() . ' ' : '') . ('' != expand('%') ? expand('%') : '[NoName]')

FUNCTION  230()
Called 480 times
Total time:   0.011634
 Self time:   0.010801

count  total (s)   self (s)
  480   0.005973   0.005140     let level = match(a:line, '[^ \-+~`|]') / s:UI.IndentWid()
                                " check if line includes arrows
  480              0.002944     if match(a:line, '[]') > -1
                                    " decrement level as arrow uses 3 ascii chars
  336              0.000767         let level = level - 1
  336              0.000237     endif
  480              0.000435     return level

FUNCTION  231()
Called 480 times
Total time:   0.000833
 Self time:   0.000833

count  total (s)   self (s)
  480              0.000580     return 2

FUNCTION  232()
Called 576 times
Total time:   0.002174
 Self time:   0.002174

count  total (s)   self (s)
  576              0.000748     if g:NERDTreeDirArrows
  576              0.001056         return '^\([] \| \+[] \| \+\)'
                                endif
                            
                                return '^[ `|]*[\-+~]'

FUNCTION  236()
Called 576 times
Total time:   0.041514
 Self time:   0.039340

count  total (s)   self (s)
  576              0.001061     let line = a:line
                                "remove the tree parts and the leading space
  576   0.009325   0.007151     let line = substitute (line, g:NERDTreeUI.MarkupReg(),"","")
                            
                                "strip off any read only flag
  576              0.003164     let line = substitute (line, ' \[RO\]', "","")
                            
                                "strip off any bookmark flags
  576              0.002879     let line = substitute (line, ' {[^}]*}', "","")
                            
                                "strip off any executable flags
  576              0.002992     let line = substitute (line, '*\ze\($\| \)', "","")
                            
                                "strip off any generic flags
  576              0.002849     let line = substitute (line, '\[[^]]*\]', "","")
                            
  576              0.000811     let wasdir = 0
  576              0.001795     if line =~# '/$'
  322              0.000427         let wasdir = 1
  322              0.000203     endif
  576              0.002747     let line = substitute (line,' -> .*',"","") " remove link to
  576              0.000681     if wasdir ==# 1
  322              0.002189         let line = substitute (line, '/\?$', '/', "")
  322              0.000250     endif
                            
  576              0.000682     if a:removeLeadingSpaces
  553              0.003137         let line = substitute (line, '^ *', '', '')
  553              0.000404     endif
                            
  576              0.000553     return line

FUNCTION  lightline#update_once()
Called 150 times
Total time:   0.001783
 Self time:   0.001783

count  total (s)   self (s)
  150              0.001505   if !exists('w:lightline') || w:lightline | call lightline#update() | endif

FUNCTION  <SNR>125_match_type()
Called 133 times
Total time:   0.001971
 Self time:   0.001971

count  total (s)   self (s)
  133              0.000163   if a:0
  115              0.001630     return !empty(filter(copy(a:000),'a:type =~# "^".v:val."\\%(-\\|$\\)"'))
                              else
   18              0.000017     return a:type
                              endif

FUNCTION  <SNR>130_in_file_browser()
Called 10 times
Total time:   0.001217
 Self time:   0.000250

count  total (s)   self (s)
   10   0.001006   0.000039   if s:nerd_tree_just_opened()
                                return 1
                              endif
                            
   10              0.000029   let patterns = ["NERD_tree", "vimpanel"]
   10              0.000031   if exists('g:eighties_bufname_additional_patterns')
                                let patterns = patterns + g:eighties_bufname_additional_patterns
                              endif
                            
   10              0.000019   for pattern in patterns
   10              0.000050     if bufname("%") =~ pattern
   10              0.000010       return 1
                                endif
                              endfor
                            
                              return

FUNCTION  <SNR>125_app_has()
Called 422 times
Total time:   0.015656
 Self time:   0.012877

count  total (s)   self (s)
  422              0.003787   let map = {'test': 'test/','spec': 'spec/','bundler': 'Gemfile|gems.locked','rails3': 'config/application.rb','cucumber': 'features/','turnip': 'spec/acceptance/','sass': 'public/stylesheets/sass/','lesscss': 'app/stylesheets/','coffee': 'app/scripts/'}
  422   0.002877   0.001566   if self.cache.needs('features')
                                call self.cache.set('features',{})
                              endif
  422   0.003528   0.002060   let features = self.cache.get('features')
  422              0.000988   if !has_key(features,a:feature)
                                let path = get(map,a:feature,a:feature.'/')
                                let features[a:feature] = !empty(filter(split(path, '|'), 'self.has_path(v:val)'))
                              endif
  422              0.000652   return features[a:feature]

FUNCTION  244()
Called 23 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
   23              0.000032     return '.. (up a dir)'

FUNCTION  245()
Called 82 times
Total time:   0.001061
 Self time:   0.001061

count  total (s)   self (s)
   82              0.000325     let newObj = copy(self)
   82              0.000157     let newObj.nerdtree = a:nerdtree
   82              0.000131     let newObj.subject = a:subject
   82              0.000139     let newObj.action = a:action
   82              0.000139     let newObj.params = a:params
   82              0.000076     return newObj

FUNCTION  247()
Called 82 times
Total time:   0.003495
 Self time:   0.001276

count  total (s)   self (s)
   82   0.001571   0.000510     let event = g:NERDTreeEvent.New(b:NERDTree, a:path, a:event, a:params)
                            
   82   0.001578   0.000420     for listener in s:Notifier.GetListenersForEvent(a:event)
                                    call {listener}(event)
                                endfor

FUNCTION  248()
Called 82 times
Total time:   0.000553
 Self time:   0.000553

count  total (s)   self (s)
   82              0.000240     if !exists("s:refreshListenersMap")
                                    let s:refreshListenersMap = {}
                                endif
   82              0.000095     return s:refreshListenersMap

FUNCTION  249()
Called 82 times
Total time:   0.001158
 Self time:   0.000605

count  total (s)   self (s)
   82   0.000880   0.000327     let listenersMap = s:Notifier.GetListenersMap()
   82              0.000217     return get(listenersMap, a:name, [])

FUNCTION  coffee#CoffeeSetUpErrorFormat()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000011   CompilerSet errorformat=Error:\ In\ %f\\,\ %m\ on\ line\ %l,Error:\ In\ %f\\,\ Parse\ error\ on\ line\ %l:\ %m,SyntaxError:\ In\ %f\\,\ %m,%f:%l:%c:\ error:\ %m,%-G%.%#

FUNCTION  251()
Called 10 times
Total time:   0.000584
 Self time:   0.000098

count  total (s)   self (s)
   10   0.000137   0.000048     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
   10   0.000437   0.000040     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  252()
Called 10 times
Total time:   0.000397
 Self time:   0.000212

count  total (s)   self (s)
   10   0.000117   0.000043     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
   10   0.000055   0.000031     if !a:loclist.isEmpty()
                                    if syntastic#util#var('auto_loc_list') == 1
                                        call a:loclist.show()
                                    endif
                                else
   10   0.000130   0.000043         if syntastic#util#var('auto_loc_list') > 0
                            
                                        "TODO: this will close the loc list window if one was opened by
                                        "something other than syntastic
   10              0.000010             lclose
   10              0.000005         endif
   10              0.000003     endif

FUNCTION  254()
Called 20 times
Total time:   0.000288
 Self time:   0.000112

count  total (s)   self (s)
   20   0.000277   0.000101     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  255()
Called 10 times
Total time:   0.000308
 Self time:   0.000147

count  total (s)   self (s)
   10              0.000015     unlet! b:syntastic_private_balloons
   10   0.000221   0.000060     if self.enabled() && !a:loclist.isEmpty()
                                    let b:syntastic_private_balloons = a:loclist.balloons()
                                    if !empty(b:syntastic_private_balloons)
                                        set ballooneval balloonexpr=SyntasticBalloonsExprNotifier()
                                    endif
                                endif

FUNCTION  <SNR>78_Map()
Called 20 times
Total time:   0.031704
 Self time:   0.001705

count  total (s)   self (s)
                              " Set mappings:
   20              0.000020   try
   20              0.000041     let save_keymap = &keymap
   20              0.000036     let save_iminsert = &iminsert
   20              0.000030     let save_imsearch = &imsearch
   20              0.000084     let save_cpo = &cpo
   20              0.000095     set keymap=
   20              0.000084     set cpo&vim
   20   0.000713   0.000431     silent! doautocmd <nomodeline> User delimitMate_map
   20   0.000698   0.000126     if s:get('autoclose')
   20   0.022091   0.000098       call s:AutoClose()
   20              0.000014     else
                                  call s:NoAutoClose()
                                endif
   20   0.007232   0.000080     call s:ExtraMappings()
   20              0.000017   finally
   20              0.000133     let &cpo = save_cpo
   20              0.000082     let &keymap = save_keymap
   20              0.000079     let &iminsert = save_iminsert
   20              0.000041     let &imsearch = save_imsearch
   20              0.000018   endtry
                            
   20              0.000037   let b:delimitMate_enabled = 1

FUNCTION  <SNR>125_readable_define_pattern()
Called 5 times
Total time:   0.002515
 Self time:   0.000179

count  total (s)   self (s)
    5   0.000912   0.000042   if self.name() =~ '\.yml$'
    1              0.000001     return '^\%(\h\k*:\)\@='
                              endif
    4              0.000007   let define = '^\s*def\s\+\(self\.\)\='
    4   0.000704   0.000030   if self.name() =~# '\.rake$'
                                let define .= "\\\|^\\s*\\%(task\\\|file\\)\\s\\+[:'\"]"
                              endif
    4   0.000689   0.000032   if self.name() =~# '/schema\.rb$'
    1              0.000004     let define .= "\\\|^\\s*create_table\\s\\+[:'\"]"
    1              0.000000   endif
    4   0.000153   0.000018   if self.type_name('test')
                                let define .= '\|^\s*test\s*[''"]'
                              endif
    4              0.000004   return define

FUNCTION  lightline#link()
Called 222 times
Total time:   0.002973
 Self time:   0.002973

count  total (s)   self (s)
  222              0.001892   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
  222              0.000725   if s:mode == mode | return '' | endif
                              let s:mode = mode
                              if !has_key(s:highlight, mode) | call lightline#highlight(mode) | endif
                              let [left, right, types] = [s:lightline.active.left, s:lightline.active.right, values(s:lightline.component_type)]
                              for i in range(len(left))
                                exec printf('hi link LightLineLeft_active_%d LightLineLeft_%s_%d', i, mode, i)
                                exec printf('hi link LightLineLeft_active_%d_%d LightLineLeft_%s_%d_%d', i, i + 1, mode, i, i + 1)
                                for j in types
                                  exec printf('hi link LightLineLeft_active_%d_%s LightLineLeft_%s_%d_%s', i, j, mode, i, j)
                                  exec printf('hi link LightLineLeft_active_%s_%d LightLineLeft_%s_%s_%d', j, i, mode, j, i)
                                endfor
                              endfor
                              exec printf('hi link LightLineMiddle_active LightLineMiddle_%s', mode)
                              for i in range(len(right))
                                exec printf('hi link LightLineRight_active_%d LightLineRight_%s_%d', i, mode, i)
                                exec printf('hi link LightLineRight_active_%d_%d LightLineRight_%s_%d_%d', i, i + 1, mode, i, i + 1)
                                for j in types
                                  exec printf('hi link LightLineRight_active_%d_%s LightLineRight_%s_%d_%s', i, j, mode, i, j)
                                  exec printf('hi link LightLineRight_active_%s_%d LightLineRight_%s_%s_%d', j, i, mode, j, i)
                                endfor
                              endfor
                              for j in types
                                exec printf('hi link LightLineLeft_active_%s LightLineLeft_%s_%s', j, mode, j)
                                exec printf('hi link LightLineRight_active_%s LightLineRight_%s_%s', j, mode, j)
                                exec printf('hi link LightLineLeft_active_%s_%d LightLineLeft_%s_%s_%d', j, len(left), mode, j, len(left))
                                exec printf('hi link LightLineLeft_active_%d_%s LightLineLeft_%s_%d_%s', len(left), j, mode, len(left), j)
                                exec printf('hi link LightLineRight_active_%s_%d LightLineRight_%s_%s_%d', j, len(right), mode, j, len(right))
                                exec printf('hi link LightLineRight_active_%d_%s LightLineRight_%s_%d_%s', len(right), j, mode, len(right), j)
                                for k in types
                                  exec printf('hi link LightLineLeft_active_%s_%s LightLineLeft_%s_%s_%s', j, k, mode, j, k)
                                  exec printf('hi link LightLineLeft_active_%s_%s LightLineLeft_%s_%s_%s', k, j, mode, k, j)
                                  exec printf('hi link LightLineRight_active_%s_%s LightLineRight_%s_%s_%s', j, k, mode, j, k)
                                  exec printf('hi link LightLineRight_active_%s_%s LightLineRight_%s_%s_%s', k, j, mode, k, j)
                                endfor
                              endfor
                              return ''

FUNCTION  <SNR>125_AddSelectiveExpand()
Called 152 times
Total time:   0.010360
 Self time:   0.006434

count  total (s)   self (s)
  152   0.003402   0.001296   let expn  = s:gsub(s:gsub(a:expn        ,'[\"|]','\\&'),'\<','\\<Lt>')
  152   0.003087   0.001267   let expn2 = s:gsub(s:gsub(a:0 ? a:1 : '','[\"|]','\\&'),'\<','\\<Lt>')
  152              0.000165   if a:0
   63              0.001239     exe "inoreabbrev <buffer> <silent> ".a:abbr." <C-R>=<SID>selectiveexpand(".string(a:pat).",\"".expn."\",".string(a:abbr).",\"".expn2."\")<CR>"
   63              0.000043   else
   89              0.001610     exe "inoreabbrev <buffer> <silent> ".a:abbr." <C-R>=<SID>selectiveexpand(".string(a:pat).",\"".expn."\",".string(a:abbr).")<CR>"
   89              0.000060   endif

FUNCTION  <SNR>193_CoffeeRunResetVars()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
                              " Variables defined in CoffeeRun source buffer:
                              "   b:coffee_run_buf: bufnr of output buffer
                              " Variables defined in CoffeeRun output buffer:
                              "   b:coffee_src_buf: bufnr of source buffer
                              "   b:coffee_run_pos: previous cursor position in output buffer
                            
    1              0.000002   let b:coffee_run_buf = -1

FUNCTION  <SNR>193_CoffeeCompileResetVars()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
                              " Variables defined in source buffer:
                              "   b:coffee_compile_buf: bufnr of output buffer
                              " Variables defined in output buffer:
                              "   b:coffee_src_buf: bufnr of source buffer
                              "   b:coffee_compile_pos: previous cursor position in output buffer
                            
    1              0.000003   let b:coffee_compile_buf = -1

FUNCTION  fugitive#buffer()
Called 10 times
Total time:   0.000341
 Self time:   0.000062

count  total (s)   self (s)
   10   0.000336   0.000057   return s:buffer(a:0 ? a:1 : '%')

FUNCTION  syntastic#util#var()
Called 90 times
Total time:   0.000790
 Self time:   0.000790

count  total (s)   self (s)
   90              0.000739     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''

FUNCTION  276()
Called 20 times
Total time:   0.000255
 Self time:   0.000081

count  total (s)   self (s)
   20   0.000247   0.000073     return syntastic#util#var('echo_current_error')

FUNCTION  277()
Called 10 times
Total time:   0.000351
 Self time:   0.000204

count  total (s)   self (s)
   10   0.000238   0.000091     if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
                                endif

FUNCTION  <SNR>125_uniq()
Called 10 times
Total time:   0.017312
 Self time:   0.017312

count  total (s)   self (s)
   10              0.000021   let i = 0
   10              0.000013   let seen = {}
 1002              0.001684   while i < len(a:list)
  992              0.004460     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
    1              0.000003       call remove(a:list,i)
    1              0.000001     elseif a:list[i] ==# ''
    6              0.000009       let i += 1
    6              0.000006       let empty = 1
    6              0.000001     else
  985              0.002975       let seen[a:list[i]] = 1
  985              0.001039       let i += 1
  985              0.000552     endif
  992              0.000626   endwhile
   10              0.000011   return a:list

FUNCTION  50()
Called 1198 times
Total time:   0.058015
 Self time:   0.021547

count  total (s)   self (s)
 1198   0.018673   0.004420     let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
 1198   0.012751   0.003705     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
 1198   0.021851   0.008682     return lead . join(self.pathSegments, s:Path.Slash())

FUNCTION  fugitive#head()
Called 378 times
Total time:   0.063090
 Self time:   0.005178

count  total (s)   self (s)
  378              0.001064   if !exists('b:git_dir')
                                return ''
                              endif
                            
  378   0.060971   0.003059   return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  <SNR>71_build_path_option()
Called 8 times
Total time:   0.017706
 Self time:   0.009760

count  total (s)   self (s)
    8   0.017700   0.009754   return join(map(copy(a:paths),'",".escape(s:shellslash(v:val."/".a:suffix),", ")'),'')

FUNCTION  281()
Called 10 times
Total time:   0.000840
 Self time:   0.000501

count  total (s)   self (s)
   10   0.000162   0.000033     if self.enabled()
   10   0.000130   0.000049         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
   10   0.000133   0.000033         call self._reset()
   10              0.000025         let buf = bufnr('')
   10   0.000083   0.000054         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
   10              0.000016         for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
                                    endfor
   10              0.000008     endif

FUNCTION  284()
Called 10 times
Total time:   0.000100
 Self time:   0.000100

count  total (s)   self (s)
   11              0.000032     for match in getmatches()
    1              0.000003         if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
    1              0.000001     endfor

FUNCTION  286()
Called 10 times
Total time:   0.000530
 Self time:   0.000131

count  total (s)   self (s)
   10              0.000035     if !exists('b:syntastic_loclist') || empty(b:syntastic_loclist)
   10   0.000464   0.000065         let b:syntastic_loclist = g:SyntasticLoclist.New([])
   10              0.000007     endif
   10              0.000012     return b:syntastic_loclist

FUNCTION  289()
Called 70 times
Total time:   0.000174
 Self time:   0.000174

count  total (s)   self (s)
   70              0.000147     return empty(self._rawLoclist)

FUNCTION  <SNR>79_set()
Called 460 times
Total time:   0.011777
 Self time:   0.011777

count  total (s)   self (s)
  460              0.000962   let scope = a:0 ? a:1 : 's'
  460              0.001034   let bufnr = bufnr('%')
  460              0.001423   if !exists('s:options[bufnr]')
   10              0.000027     let s:options[bufnr] = {}
   10              0.000007   endif
  460              0.000616   if scope == 's'
  460              0.001477     let name = 's:options.' . bufnr . '.' . a:name
  460              0.000275   else
                                let name = scope . ':delimitMate_' . a:name
                                if exists('name')
                                  exec 'unlet! ' . name
                                endif
                              endif
  460              0.002317   exec 'let ' . name . ' = a:value'

FUNCTION  nerdtree#ui_glue#invokeKeyMap()
Called 23 times
Total time:  14.806397
 Self time:   0.000224

count  total (s)   self (s)
   23  14.806364   0.000191     call g:NERDTreeKeyMap.Invoke(a:key)

FUNCTION  HtmlIndent_CheckUserSettings()
Called 4 times
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
    4              0.000014     if exists("g:html_indent_inctags")
                            	call s:AddITags(split(g:html_indent_inctags, ","))
                                endif
    4              0.000011     if exists("g:html_indent_autotags")
                            	call s:RemoveITags(split(g:html_indent_autotags, ","))
                                endif
                            
    4              0.000020     let indone = {"zero": 0,"auto": "indent(prevnonblank(v:lnum-1))","inc": "b:indent.blocktagind + s:ShiftWidth()"}
    4              0.000009     if exists("g:html_indent_script1")
                            	let s:js1indent = get(indone, g:html_indent_script1, indone.zero)
                                endif
    4              0.000010     if exists("g:html_indent_style1")
                            	let s:css1indent = get(indone, g:html_indent_style1, indone.zero)
                                endif

FUNCTION  <SNR>125_app_ruby_script_command()
Called 10 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
   10              0.000035   if has('win32')
                                return self.ruby_command(a:cmd)
                              else
   10              0.000010     return a:cmd
                              endif

FUNCTION  290()
Called 20 times
Total time:   0.000335
 Self time:   0.000172

count  total (s)   self (s)
   20              0.000046     if !exists('self._stamp')
   10              0.000018         let self._stamp = []
   10              0.000009         return 0
                                endif
   10   0.000219   0.000056     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  291()
Called 10 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
   10              0.000021     return copy(self._rawLoclist)

FUNCTION  <SNR>71_project_gems()
Called 71 times
Total time:   0.015226
 Self time:   0.000322

count  total (s)   self (s)
   71   0.015192   0.000288   return self.paths()

FUNCTION  <SNR>71_shellslash()
Called 1162 times
Total time:   0.008035
 Self time:   0.008035

count  total (s)   self (s)
 1162              0.002701   if exists('+shellslash') && !&shellslash
                                return s:gsub(a:path,'\\','/')
                              else
 1162              0.001265     return a:path
                              endif

FUNCTION  <SNR>90_buffer()
Called 30 times
Total time:   0.000796
 Self time:   0.000669

count  total (s)   self (s)
   30              0.000153   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
   30              0.000294   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
   30   0.000272   0.000145   if buffer.getvar('git_dir') !=# ''
   30              0.000032     return buffer
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  <SNR>31_mergelists()
Called 10 times
Total time:   0.004832
 Self time:   0.003204

count  total (s)   self (s)
   10   0.001622   0.000084 	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
   10              0.002669 	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
   10              0.000383 	let mrufs = s:mrufs + diskmrufs
   10   0.000146   0.000056 	retu s:chop(mrufs)

FUNCTION  <SNR>125_cache_needs()
Called 493 times
Total time:   0.001535
 Self time:   0.001535

count  total (s)   self (s)
  493              0.001300   return !has_key(self.dict,a:key)

FUNCTION  <SNR>90_sub()
Called 498 times
Total time:   0.005826
 Self time:   0.005826

count  total (s)   self (s)
  498              0.005549   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  <SNR>90_winshell()
Called 60 times
Total time:   0.000419
 Self time:   0.000419

count  total (s)   self (s)
   60              0.000386   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  delimitMate#Set()
Called 460 times
Total time:   0.014274
 Self time:   0.002497

count  total (s)   self (s)
  460   0.014082   0.002305   return call('s:set', a:000)

FUNCTION  <SNR>125_app_has_path()
Called 10 times
Total time:   0.000161
 Self time:   0.000105

count  total (s)   self (s)
   10   0.000159   0.000103   return getftime(self.path(a:path)) != -1

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   23  14.806397   0.000224  nerdtree#ui_glue#invokeKeyMap()
   23  14.806173   0.001444  81()
   23  14.651886   0.000348  80()
   10  14.314594   0.000087  <SNR>49_activateFileNode()
   10  14.314507   0.000143  109()
   10  14.314364   0.000127  126()
   10  14.313675   0.000100  176()
   10  14.313575   0.000277  177()
   10  14.298072   0.085859  22()
   11  13.324649   0.064999  <SNR>19_SynSet()
    2   7.014118   0.000411  <SNR>6_FThtml()
  147   3.155180   0.010249  <SNR>188_SetNamedColor()
  294   3.141238   1.402441  <SNR>188_Rgb2xterm()
224910   1.738797             <SNR>188_pow()
  855   0.633479   0.546634  135()
   10   0.394783   0.057712  rails#buffer_setup()
   13   0.336944   0.000059  <SNR>49_activateDirNode()
   13   0.336885   0.000211  137()
   13   0.240462   0.000089  223()
   13   0.240373   0.002536  237()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
224910              1.738797  <SNR>188_pow()
  294   3.141238   1.402441  <SNR>188_Rgb2xterm()
  855   0.633479   0.546634  135()
   10   0.159689   0.145482  <SNR>16_LoadFTPlugin()
   10  14.298072   0.085859  22()
  110   0.073941   0.072927  <SNR>125_define_navcommand()
   11  13.324649   0.064999  <SNR>19_SynSet()
   10   0.394783   0.057712  rails#buffer_setup()
 1283   0.121354   0.054516  45()
  202   0.192048   0.042893  142()
   10   0.049319   0.040192  <SNR>17_LoadIndent()
  576   0.041514   0.039340  236()
  997   0.099217   0.037869  33()
  100   0.044687   0.036527  <SNR>125_addfilecmds()
   60   0.065891   0.032292  <SNR>120_line()
 3984              0.030815  nerdtree#runningWindows()
   61   0.055886   0.029223  <SNR>125_app_projections()
 2496              0.027429  28()
  120              0.026864  <SNR>120_expand()
  997   0.037745   0.026728  34()

